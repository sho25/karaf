begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|log
operator|.
name|core
operator|.
name|internal
operator|.
name|layout
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ManagementFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|ops4j
operator|.
name|pax
operator|.
name|logging
operator|.
name|PaxLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|ops4j
operator|.
name|pax
operator|.
name|logging
operator|.
name|spi
operator|.
name|PaxLocationInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|ops4j
operator|.
name|pax
operator|.
name|logging
operator|.
name|spi
operator|.
name|PaxLoggingEvent
import|;
end_import

begin_comment
comment|/**  * Copied from log4j  */
end_comment

begin_comment
comment|/**    Most of the work of the {@link org.apache.log4j.PatternLayout} class    is delegated to the PatternParser class.     @since 0.8.2 */
end_comment

begin_class
specifier|public
class|class
name|PatternParser
block|{
specifier|private
specifier|static
specifier|final
name|String
name|LINE_SEP
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|ESCAPE_CHAR
init|=
literal|'%'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|LITERAL_STATE
init|=
literal|0
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|CONVERTER_STATE
init|=
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MINUS_STATE
init|=
literal|2
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DOT_STATE
init|=
literal|3
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MIN_STATE
init|=
literal|4
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MAX_STATE
init|=
literal|5
decl_stmt|;
specifier|static
specifier|final
name|int
name|FULL_LOCATION_CONVERTER
init|=
literal|1000
decl_stmt|;
specifier|static
specifier|final
name|int
name|METHOD_LOCATION_CONVERTER
init|=
literal|1001
decl_stmt|;
specifier|static
specifier|final
name|int
name|CLASS_LOCATION_CONVERTER
init|=
literal|1002
decl_stmt|;
specifier|static
specifier|final
name|int
name|LINE_LOCATION_CONVERTER
init|=
literal|1003
decl_stmt|;
specifier|static
specifier|final
name|int
name|FILE_LOCATION_CONVERTER
init|=
literal|1004
decl_stmt|;
specifier|static
specifier|final
name|int
name|RELATIVE_TIME_CONVERTER
init|=
literal|2000
decl_stmt|;
specifier|static
specifier|final
name|int
name|THREAD_CONVERTER
init|=
literal|2001
decl_stmt|;
specifier|static
specifier|final
name|int
name|LEVEL_CONVERTER
init|=
literal|2002
decl_stmt|;
specifier|static
specifier|final
name|int
name|NDC_CONVERTER
init|=
literal|2003
decl_stmt|;
specifier|static
specifier|final
name|int
name|MESSAGE_CONVERTER
init|=
literal|2004
decl_stmt|;
name|int
name|state
decl_stmt|;
specifier|protected
name|StringBuffer
name|currentLiteral
init|=
operator|new
name|StringBuffer
argument_list|(
literal|32
argument_list|)
decl_stmt|;
specifier|protected
name|int
name|patternLength
decl_stmt|;
specifier|protected
name|int
name|i
decl_stmt|;
name|PatternConverter
name|head
decl_stmt|;
name|PatternConverter
name|tail
decl_stmt|;
specifier|protected
name|FormattingInfo
name|formattingInfo
init|=
operator|new
name|FormattingInfo
argument_list|()
decl_stmt|;
specifier|protected
name|String
name|pattern
decl_stmt|;
specifier|public
name|PatternParser
parameter_list|(
name|String
name|pattern
parameter_list|)
block|{
name|this
operator|.
name|pattern
operator|=
name|pattern
expr_stmt|;
name|patternLength
operator|=
name|pattern
operator|.
name|length
argument_list|()
expr_stmt|;
name|state
operator|=
name|LITERAL_STATE
expr_stmt|;
block|}
specifier|private
name|void
name|addToList
parameter_list|(
name|PatternConverter
name|pc
parameter_list|)
block|{
if|if
condition|(
name|head
operator|==
literal|null
condition|)
block|{
name|head
operator|=
name|tail
operator|=
name|pc
expr_stmt|;
block|}
else|else
block|{
name|tail
operator|.
name|next
operator|=
name|pc
expr_stmt|;
name|tail
operator|=
name|pc
expr_stmt|;
block|}
block|}
specifier|protected
name|String
name|extractOption
parameter_list|()
block|{
if|if
condition|(
operator|(
name|i
operator|<
name|patternLength
operator|)
operator|&&
operator|(
name|pattern
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'{'
operator|)
condition|)
block|{
name|int
name|end
init|=
name|i
decl_stmt|;
name|int
name|nb
init|=
literal|1
decl_stmt|;
while|while
condition|(
operator|++
name|end
operator|<
name|patternLength
condition|)
block|{
switch|switch
condition|(
name|pattern
operator|.
name|charAt
argument_list|(
name|end
argument_list|)
condition|)
block|{
case|case
literal|'{'
case|:
name|nb
operator|++
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
if|if
condition|(
operator|--
name|nb
operator|==
literal|0
condition|)
block|{
name|String
name|r
init|=
name|pattern
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|end
argument_list|)
decl_stmt|;
name|i
operator|=
name|end
operator|+
literal|1
expr_stmt|;
return|return
name|r
return|;
block|}
break|break;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * The option is expected to be in decimal and positive.    * In case of error, zero is returned.    *    * @return The precision value, or zero in case of error.    */
specifier|protected
name|int
name|extractPrecisionOption
parameter_list|()
block|{
name|String
name|opt
init|=
name|extractOption
argument_list|()
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|opt
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|r
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<=
literal|0
condition|)
block|{
comment|//LogLog.error("Precision option (" + opt + ") isn't a positive integer.");
name|r
operator|=
literal|0
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
comment|//LogLog.error("Category option \""+opt+"\" not a decimal integer.", e);
block|}
block|}
return|return
name|r
return|;
block|}
specifier|public
name|PatternConverter
name|parse
parameter_list|()
block|{
name|char
name|c
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|patternLength
condition|)
block|{
name|c
operator|=
name|pattern
operator|.
name|charAt
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|LITERAL_STATE
case|:
comment|// In literal state, the last char is always a literal.
if|if
condition|(
name|i
operator|==
name|patternLength
condition|)
block|{
name|currentLiteral
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
name|ESCAPE_CHAR
condition|)
block|{
comment|// peek at the next char.
switch|switch
condition|(
name|pattern
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
name|ESCAPE_CHAR
case|:
name|currentLiteral
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|// move pointer
break|break;
case|case
literal|'n'
case|:
name|currentLiteral
operator|.
name|append
argument_list|(
name|LINE_SEP
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|// move pointer
break|break;
default|default:
if|if
condition|(
name|currentLiteral
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|addToList
argument_list|(
operator|new
name|LiteralPatternConverter
argument_list|(
name|currentLiteral
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//LogLog.debug("Parsed LITERAL converter: \""
comment|//           +currentLiteral+"\".");
block|}
name|currentLiteral
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|currentLiteral
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|// append %
name|state
operator|=
name|CONVERTER_STATE
expr_stmt|;
name|formattingInfo
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|currentLiteral
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONVERTER_STATE
case|:
name|currentLiteral
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'-'
case|:
name|formattingInfo
operator|.
name|leftAlign
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|state
operator|=
name|DOT_STATE
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|formattingInfo
operator|.
name|min
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|state
operator|=
name|MIN_STATE
expr_stmt|;
block|}
else|else
name|finalizeConverter
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|// switch
break|break;
case|case
name|MIN_STATE
case|:
name|currentLiteral
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|formattingInfo
operator|.
name|min
operator|=
name|formattingInfo
operator|.
name|min
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
name|state
operator|=
name|DOT_STATE
expr_stmt|;
else|else
block|{
name|finalizeConverter
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DOT_STATE
case|:
name|currentLiteral
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|formattingInfo
operator|.
name|max
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|state
operator|=
name|MAX_STATE
expr_stmt|;
block|}
else|else
block|{
comment|//LogLog.error("Error occured in position "+i+".\n Was expecting digit, instead got char \""+c+"\".");
name|state
operator|=
name|LITERAL_STATE
expr_stmt|;
block|}
break|break;
case|case
name|MAX_STATE
case|:
name|currentLiteral
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|formattingInfo
operator|.
name|max
operator|=
name|formattingInfo
operator|.
name|max
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
block|{
name|finalizeConverter
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|LITERAL_STATE
expr_stmt|;
block|}
break|break;
block|}
comment|// switch
block|}
comment|// while
if|if
condition|(
name|currentLiteral
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|addToList
argument_list|(
operator|new
name|LiteralPatternConverter
argument_list|(
name|currentLiteral
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//LogLog.debug("Parsed LITERAL converter: \""+currentLiteral+"\".");
block|}
return|return
name|head
return|;
block|}
specifier|protected
name|void
name|finalizeConverter
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|PatternConverter
name|pc
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
name|pc
operator|=
operator|new
name|CategoryPatternConverter
argument_list|(
name|formattingInfo
argument_list|,
name|extractPrecisionOption
argument_list|()
argument_list|)
expr_stmt|;
comment|//LogLog.debug("CATEGORY converter.");
comment|//formattingInfo.dump();
name|currentLiteral
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|pc
operator|=
operator|new
name|ClassNamePatternConverter
argument_list|(
name|formattingInfo
argument_list|,
name|extractPrecisionOption
argument_list|()
argument_list|)
expr_stmt|;
comment|//LogLog.debug("CLASS_NAME converter.");
comment|//formattingInfo.dump();
name|currentLiteral
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|String
name|dateFormatStr
init|=
name|AbsoluteTimeDateFormat
operator|.
name|ISO8601_DATE_FORMAT
decl_stmt|;
name|DateFormat
name|df
decl_stmt|;
name|String
name|dOpt
init|=
name|extractOption
argument_list|()
decl_stmt|;
if|if
condition|(
name|dOpt
operator|!=
literal|null
condition|)
name|dateFormatStr
operator|=
name|dOpt
expr_stmt|;
if|if
condition|(
name|dateFormatStr
operator|.
name|equalsIgnoreCase
argument_list|(
name|AbsoluteTimeDateFormat
operator|.
name|ISO8601_DATE_FORMAT
argument_list|)
condition|)
name|df
operator|=
operator|new
name|ISO8601DateFormat
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|dateFormatStr
operator|.
name|equalsIgnoreCase
argument_list|(
name|AbsoluteTimeDateFormat
operator|.
name|ABS_TIME_DATE_FORMAT
argument_list|)
condition|)
name|df
operator|=
operator|new
name|AbsoluteTimeDateFormat
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|dateFormatStr
operator|.
name|equalsIgnoreCase
argument_list|(
name|AbsoluteTimeDateFormat
operator|.
name|DATE_AND_TIME_DATE_FORMAT
argument_list|)
condition|)
name|df
operator|=
operator|new
name|DateTimeDateFormat
argument_list|()
expr_stmt|;
else|else
block|{
try|try
block|{
name|df
operator|=
operator|new
name|SimpleDateFormat
argument_list|(
name|dateFormatStr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|//LogLog.error("Could not instantiate SimpleDateFormat with " + dateFormatStr, e);
name|df
operator|=
operator|new
name|ISO8601DateFormat
argument_list|()
expr_stmt|;
block|}
block|}
name|pc
operator|=
operator|new
name|DatePatternConverter
argument_list|(
name|formattingInfo
argument_list|,
name|df
argument_list|)
expr_stmt|;
comment|//LogLog.debug("DATE converter {"+dateFormatStr+"}.");
comment|//formattingInfo.dump();
name|currentLiteral
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|pc
operator|=
operator|new
name|LocationPatternConverter
argument_list|(
name|formattingInfo
argument_list|,
name|FILE_LOCATION_CONVERTER
argument_list|)
expr_stmt|;
comment|//LogLog.debug("File name converter.");
comment|//formattingInfo.dump();
name|currentLiteral
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|String
name|pat
init|=
name|extractOption
argument_list|()
decl_stmt|;
name|String
name|style
init|=
name|extractOption
argument_list|()
decl_stmt|;
name|pc
operator|=
operator|new
name|HighlightPatternConverter
argument_list|(
name|formattingInfo
argument_list|,
name|pat
argument_list|,
name|style
argument_list|)
expr_stmt|;
name|currentLiteral
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/*case 'l':       pc = new LocationPatternConverter(formattingInfo, 					FULL_LOCATION_CONVERTER);       //LogLog.debug("Location converter.");       //formattingInfo.dump();       currentLiteral.setLength(0);       break;*/
case|case
literal|'L'
case|:
name|pc
operator|=
operator|new
name|LocationPatternConverter
argument_list|(
name|formattingInfo
argument_list|,
name|LINE_LOCATION_CONVERTER
argument_list|)
expr_stmt|;
comment|//LogLog.debug("LINE NUMBER converter.");
comment|//formattingInfo.dump();
name|currentLiteral
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|pc
operator|=
operator|new
name|BasicPatternConverter
argument_list|(
name|formattingInfo
argument_list|,
name|MESSAGE_CONVERTER
argument_list|)
expr_stmt|;
comment|//LogLog.debug("MESSAGE converter.");
comment|//formattingInfo.dump();
name|currentLiteral
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|pc
operator|=
operator|new
name|LocationPatternConverter
argument_list|(
name|formattingInfo
argument_list|,
name|METHOD_LOCATION_CONVERTER
argument_list|)
expr_stmt|;
comment|//LogLog.debug("METHOD converter.");
comment|//formattingInfo.dump();
name|currentLiteral
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|pc
operator|=
operator|new
name|BasicPatternConverter
argument_list|(
name|formattingInfo
argument_list|,
name|LEVEL_CONVERTER
argument_list|)
expr_stmt|;
comment|//LogLog.debug("LEVEL converter.");
comment|//formattingInfo.dump();
name|currentLiteral
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|pc
operator|=
operator|new
name|BasicPatternConverter
argument_list|(
name|formattingInfo
argument_list|,
name|RELATIVE_TIME_CONVERTER
argument_list|)
expr_stmt|;
comment|//LogLog.debug("RELATIVE time converter.");
comment|//formattingInfo.dump();
name|currentLiteral
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|pc
operator|=
operator|new
name|BasicPatternConverter
argument_list|(
name|formattingInfo
argument_list|,
name|THREAD_CONVERTER
argument_list|)
expr_stmt|;
comment|//LogLog.debug("THREAD converter.");
comment|//formattingInfo.dump();
name|currentLiteral
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/*case 'u':       if(i< patternLength) { 	char cNext = pattern.charAt(i); 	if(cNext>= '0'&& cNext<= '9') { 	  pc = new UserFieldPatternConverter(formattingInfo, cNext - '0'); 	  LogLog.debug("USER converter ["+cNext+"]."); 	  formattingInfo.dump(); 	  currentLiteral.setLength(0); 	  i++; 	} 	else 	  LogLog.error("Unexpected char" +cNext+" at position "+i);       }       break;*/
comment|/*case 'x':       pc = new BasicPatternConverter(formattingInfo, NDC_CONVERTER);       //LogLog.debug("NDC converter.");       currentLiteral.setLength(0);       break;*/
case|case
literal|'X'
case|:
name|String
name|xOpt
init|=
name|extractOption
argument_list|()
decl_stmt|;
name|pc
operator|=
operator|new
name|MDCPatternConverter
argument_list|(
name|formattingInfo
argument_list|,
name|xOpt
argument_list|)
expr_stmt|;
name|currentLiteral
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|//LogLog.error("Unexpected char [" +c+"] at position "+i+" in conversion patterrn.");
name|pc
operator|=
operator|new
name|LiteralPatternConverter
argument_list|(
name|currentLiteral
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|currentLiteral
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|addConverter
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|addConverter
parameter_list|(
name|PatternConverter
name|pc
parameter_list|)
block|{
name|currentLiteral
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Add the pattern converter to the list.
name|addToList
argument_list|(
name|pc
argument_list|)
expr_stmt|;
comment|// Next pattern is assumed to be a literal.
name|state
operator|=
name|LITERAL_STATE
expr_stmt|;
comment|// Reset formatting info
name|formattingInfo
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
comment|// ---------------------------------------------------------------------
comment|//                      PatternConverters
comment|// ---------------------------------------------------------------------
specifier|private
specifier|static
class|class
name|BasicPatternConverter
extends|extends
name|PatternConverter
block|{
name|int
name|type
decl_stmt|;
name|BasicPatternConverter
parameter_list|(
name|FormattingInfo
name|formattingInfo
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|super
argument_list|(
name|formattingInfo
argument_list|)
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
specifier|public
name|String
name|convert
parameter_list|(
name|PaxLoggingEvent
name|event
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RELATIVE_TIME_CONVERTER
case|:
return|return
operator|(
name|Long
operator|.
name|toString
argument_list|(
name|event
operator|.
name|getTimeStamp
argument_list|()
operator|-
name|getStartTime
argument_list|()
argument_list|)
operator|)
return|;
case|case
name|THREAD_CONVERTER
case|:
return|return
name|event
operator|.
name|getThreadName
argument_list|()
return|;
case|case
name|LEVEL_CONVERTER
case|:
return|return
name|event
operator|.
name|getLevel
argument_list|()
operator|.
name|toString
argument_list|()
return|;
comment|//  case NDC_CONVERTER:
comment|//return event.getNDC();
case|case
name|MESSAGE_CONVERTER
case|:
block|{
return|return
name|event
operator|.
name|getRenderedMessage
argument_list|()
return|;
block|}
default|default:
return|return
literal|null
return|;
block|}
block|}
block|}
specifier|private
specifier|static
class|class
name|LiteralPatternConverter
extends|extends
name|PatternConverter
block|{
specifier|private
name|String
name|literal
decl_stmt|;
name|LiteralPatternConverter
parameter_list|(
name|String
name|value
parameter_list|)
block|{
name|literal
operator|=
name|value
expr_stmt|;
block|}
specifier|public
specifier|final
name|void
name|format
parameter_list|(
name|StringBuffer
name|sbuf
parameter_list|,
name|PaxLoggingEvent
name|event
parameter_list|)
block|{
name|sbuf
operator|.
name|append
argument_list|(
name|literal
argument_list|)
expr_stmt|;
block|}
specifier|public
name|String
name|convert
parameter_list|(
name|PaxLoggingEvent
name|event
parameter_list|)
block|{
return|return
name|literal
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|DatePatternConverter
extends|extends
name|PatternConverter
block|{
specifier|private
name|DateFormat
name|df
decl_stmt|;
specifier|private
name|Date
name|date
decl_stmt|;
name|DatePatternConverter
parameter_list|(
name|FormattingInfo
name|formattingInfo
parameter_list|,
name|DateFormat
name|df
parameter_list|)
block|{
name|super
argument_list|(
name|formattingInfo
argument_list|)
expr_stmt|;
name|date
operator|=
operator|new
name|Date
argument_list|()
expr_stmt|;
name|this
operator|.
name|df
operator|=
name|df
expr_stmt|;
block|}
specifier|public
name|String
name|convert
parameter_list|(
name|PaxLoggingEvent
name|event
parameter_list|)
block|{
name|date
operator|.
name|setTime
argument_list|(
name|event
operator|.
name|getTimeStamp
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|converted
init|=
literal|null
decl_stmt|;
try|try
block|{
name|converted
operator|=
name|df
operator|.
name|format
argument_list|(
name|date
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
comment|//LogLog.error("Error occured while converting date.", ex);
block|}
return|return
name|converted
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|HighlightPatternConverter
extends|extends
name|PatternConverter
block|{
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|SEQUENCES
decl_stmt|;
static|static
block|{
name|SEQUENCES
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"csi"
argument_list|,
literal|"\u001b["
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"suffix"
argument_list|,
literal|"m"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"separator"
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"normal"
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"bold"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"bright"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"dim"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"underline"
argument_list|,
literal|"3"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"blink"
argument_list|,
literal|"5"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"reverse"
argument_list|,
literal|"7"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"hidden"
argument_list|,
literal|"8"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"black"
argument_list|,
literal|"30"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"fg_black"
argument_list|,
literal|"30"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"red"
argument_list|,
literal|"31"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"fg_red"
argument_list|,
literal|"31"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"green"
argument_list|,
literal|"32"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"fg_green"
argument_list|,
literal|"32"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"yellow"
argument_list|,
literal|"33"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"fg_yellow"
argument_list|,
literal|"33"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"blue"
argument_list|,
literal|"34"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"fg_blue"
argument_list|,
literal|"34"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"magenta"
argument_list|,
literal|"35"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"fg_magenta"
argument_list|,
literal|"35"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"cyan"
argument_list|,
literal|"36"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"fg_cyan"
argument_list|,
literal|"36"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"white"
argument_list|,
literal|"37"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"fg_white"
argument_list|,
literal|"37"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"default"
argument_list|,
literal|"39"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"fg_default"
argument_list|,
literal|"39"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"bg_black"
argument_list|,
literal|"40"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"bg_red"
argument_list|,
literal|"41"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"bg_green"
argument_list|,
literal|"42"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"bg_yellow"
argument_list|,
literal|"43"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"bg_blue"
argument_list|,
literal|"44"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"bg_magenta"
argument_list|,
literal|"45"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"bg_cyan"
argument_list|,
literal|"46"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"bg_white"
argument_list|,
literal|"47"
argument_list|)
expr_stmt|;
name|SEQUENCES
operator|.
name|put
argument_list|(
literal|"bg_default"
argument_list|,
literal|"49"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|PatternConverter
name|pattern
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|style
decl_stmt|;
name|HighlightPatternConverter
parameter_list|(
name|FormattingInfo
name|formattingInfo
parameter_list|,
name|String
name|pattern
parameter_list|,
name|String
name|style
parameter_list|)
block|{
name|super
argument_list|(
name|formattingInfo
argument_list|)
expr_stmt|;
name|this
operator|.
name|pattern
operator|=
operator|new
name|PatternParser
argument_list|(
name|pattern
argument_list|)
operator|.
name|parse
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|unparsed
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|unparsed
operator|.
name|put
argument_list|(
literal|"trace"
argument_list|,
literal|"cyan"
argument_list|)
expr_stmt|;
name|unparsed
operator|.
name|put
argument_list|(
literal|"debug"
argument_list|,
literal|"cyan"
argument_list|)
expr_stmt|;
name|unparsed
operator|.
name|put
argument_list|(
literal|"info"
argument_list|,
literal|"bright green"
argument_list|)
expr_stmt|;
name|unparsed
operator|.
name|put
argument_list|(
literal|"warn"
argument_list|,
literal|"bright yellow"
argument_list|)
expr_stmt|;
name|unparsed
operator|.
name|put
argument_list|(
literal|"error"
argument_list|,
literal|"bright red"
argument_list|)
expr_stmt|;
name|unparsed
operator|.
name|put
argument_list|(
literal|"fatal"
argument_list|,
literal|"bright red"
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|!=
literal|null
condition|)
block|{
name|style
operator|=
name|style
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|)
operator|<
literal|0
operator|&&
name|style
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|)
operator|<
literal|0
condition|)
block|{
name|unparsed
operator|.
name|put
argument_list|(
literal|"trace"
argument_list|,
name|style
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|unparsed
operator|.
name|put
argument_list|(
literal|"debug"
argument_list|,
name|style
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|unparsed
operator|.
name|put
argument_list|(
literal|"info"
argument_list|,
name|style
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|unparsed
operator|.
name|put
argument_list|(
literal|"warn"
argument_list|,
name|style
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|unparsed
operator|.
name|put
argument_list|(
literal|"error"
argument_list|,
name|style
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|unparsed
operator|.
name|put
argument_list|(
literal|"fatal"
argument_list|,
name|style
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
index|[]
name|keys
init|=
name|style
operator|.
name|split
argument_list|(
literal|"\\s*,\\s*"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|keys
control|)
block|{
name|String
index|[]
name|val
init|=
name|key
operator|.
name|split
argument_list|(
literal|"\\s*=\\s*"
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|unparsed
operator|.
name|put
argument_list|(
name|val
index|[
literal|0
index|]
operator|.
name|trim
argument_list|()
argument_list|,
name|val
index|[
literal|1
index|]
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|this
operator|.
name|style
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|e
range|:
name|unparsed
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|this
operator|.
name|style
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|createSequence
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|split
argument_list|(
literal|"\\s"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|String
name|createSequence
parameter_list|(
name|String
modifier|...
name|names
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|SEQUENCES
operator|.
name|get
argument_list|(
literal|"csi"
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
name|name
operator|=
name|name
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|SEQUENCES
operator|.
name|get
argument_list|(
literal|"separator"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
literal|false
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|SEQUENCES
operator|.
name|getOrDefault
argument_list|(
name|name
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|SEQUENCES
operator|.
name|get
argument_list|(
literal|"suffix"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|String
name|convert
parameter_list|(
name|PaxLoggingEvent
name|event
parameter_list|)
block|{
name|String
name|s
decl_stmt|;
switch|switch
condition|(
name|event
operator|.
name|getLevel
argument_list|()
operator|.
name|toInt
argument_list|()
condition|)
block|{
case|case
name|PaxLogger
operator|.
name|LEVEL_TRACE
case|:
name|s
operator|=
literal|"trace"
expr_stmt|;
break|break;
case|case
name|PaxLogger
operator|.
name|LEVEL_DEBUG
case|:
name|s
operator|=
literal|"debug"
expr_stmt|;
break|break;
case|case
name|PaxLogger
operator|.
name|LEVEL_INFO
case|:
name|s
operator|=
literal|"info"
expr_stmt|;
break|break;
case|case
name|PaxLogger
operator|.
name|LEVEL_WARNING
case|:
name|s
operator|=
literal|"warn"
expr_stmt|;
break|break;
default|default:
name|s
operator|=
literal|"error"
expr_stmt|;
break|break;
block|}
name|String
name|str
init|=
name|style
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
operator|!=
literal|null
condition|)
block|{
return|return
name|str
operator|+
name|pattern
operator|.
name|convert
argument_list|(
name|event
argument_list|)
operator|+
name|SEQUENCES
operator|.
name|get
argument_list|(
literal|"csi"
argument_list|)
operator|+
name|SEQUENCES
operator|.
name|get
argument_list|(
literal|"suffix"
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|pattern
operator|.
name|convert
argument_list|(
name|event
argument_list|)
return|;
block|}
block|}
block|}
specifier|private
class|class
name|LocationPatternConverter
extends|extends
name|PatternConverter
block|{
name|int
name|type
decl_stmt|;
name|LocationPatternConverter
parameter_list|(
name|FormattingInfo
name|formattingInfo
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|super
argument_list|(
name|formattingInfo
argument_list|)
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
specifier|public
name|String
name|convert
parameter_list|(
name|PaxLoggingEvent
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|event
operator|.
name|locationInformationExists
argument_list|()
condition|)
block|{
return|return
literal|"?"
return|;
block|}
name|PaxLocationInfo
name|locationInfo
init|=
name|event
operator|.
name|getLocationInformation
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
comment|/*case FULL_LOCATION_CONVERTER: 	return locationInfo.fullInfo;*/
case|case
name|METHOD_LOCATION_CONVERTER
case|:
return|return
name|locationInfo
operator|.
name|getMethodName
argument_list|()
return|;
case|case
name|LINE_LOCATION_CONVERTER
case|:
return|return
name|locationInfo
operator|.
name|getLineNumber
argument_list|()
return|;
case|case
name|FILE_LOCATION_CONVERTER
case|:
return|return
name|locationInfo
operator|.
name|getFileName
argument_list|()
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
block|}
specifier|private
specifier|static
specifier|abstract
class|class
name|NamedPatternConverter
extends|extends
name|PatternConverter
block|{
name|int
name|precision
decl_stmt|;
name|NamedPatternConverter
parameter_list|(
name|FormattingInfo
name|formattingInfo
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
name|super
argument_list|(
name|formattingInfo
argument_list|)
expr_stmt|;
name|this
operator|.
name|precision
operator|=
name|precision
expr_stmt|;
block|}
specifier|abstract
name|String
name|getFullyQualifiedName
parameter_list|(
name|PaxLoggingEvent
name|event
parameter_list|)
function_decl|;
specifier|public
name|String
name|convert
parameter_list|(
name|PaxLoggingEvent
name|event
parameter_list|)
block|{
name|String
name|n
init|=
name|getFullyQualifiedName
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|precision
operator|<=
literal|0
condition|)
return|return
name|n
return|;
else|else
block|{
name|int
name|len
init|=
name|n
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// We substract 1 from 'len' when assigning to 'end' to avoid out of
comment|// bounds exception in return r.substring(end+1, len). This can happen if
comment|// precision is 1 and the category name ends with a dot.
name|int
name|end
init|=
name|len
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|precision
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|end
operator|=
name|n
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|,
name|end
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
operator|-
literal|1
condition|)
return|return
name|n
return|;
block|}
return|return
name|n
operator|.
name|substring
argument_list|(
name|end
operator|+
literal|1
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
block|}
specifier|private
class|class
name|ClassNamePatternConverter
extends|extends
name|NamedPatternConverter
block|{
name|ClassNamePatternConverter
parameter_list|(
name|FormattingInfo
name|formattingInfo
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
name|super
argument_list|(
name|formattingInfo
argument_list|,
name|precision
argument_list|)
expr_stmt|;
block|}
name|String
name|getFullyQualifiedName
parameter_list|(
name|PaxLoggingEvent
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|event
operator|.
name|locationInformationExists
argument_list|()
condition|)
block|{
return|return
literal|"?"
return|;
block|}
return|return
name|event
operator|.
name|getLocationInformation
argument_list|()
operator|.
name|getClassName
argument_list|()
return|;
block|}
block|}
specifier|private
class|class
name|CategoryPatternConverter
extends|extends
name|NamedPatternConverter
block|{
name|CategoryPatternConverter
parameter_list|(
name|FormattingInfo
name|formattingInfo
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
name|super
argument_list|(
name|formattingInfo
argument_list|,
name|precision
argument_list|)
expr_stmt|;
block|}
name|String
name|getFullyQualifiedName
parameter_list|(
name|PaxLoggingEvent
name|event
parameter_list|)
block|{
return|return
name|event
operator|.
name|getLoggerName
argument_list|()
return|;
block|}
block|}
specifier|private
class|class
name|MDCPatternConverter
extends|extends
name|PatternConverter
block|{
name|String
name|key
decl_stmt|;
name|MDCPatternConverter
parameter_list|(
name|FormattingInfo
name|formattingInfo
parameter_list|,
name|String
name|key
parameter_list|)
block|{
name|super
argument_list|(
name|formattingInfo
argument_list|)
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
block|}
specifier|public
name|String
name|convert
parameter_list|(
name|PaxLoggingEvent
name|event
parameter_list|)
block|{
name|Map
name|properties
init|=
name|event
operator|.
name|getProperties
argument_list|()
decl_stmt|;
if|if
condition|(
name|properties
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|(
literal|"{"
argument_list|)
decl_stmt|;
if|if
condition|(
name|properties
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Object
index|[]
name|keys
init|=
name|properties
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|()
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|keys
argument_list|)
expr_stmt|;
for|for
control|(
name|Object
name|key
range|:
name|keys
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|properties
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
block|}
name|buf
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
else|else
block|{
name|Object
name|val
init|=
name|properties
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|val
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
block|}
specifier|private
specifier|static
name|long
name|startTime
init|=
literal|0
decl_stmt|;
specifier|private
specifier|static
name|long
name|getStartTime
parameter_list|()
block|{
if|if
condition|(
name|startTime
operator|==
literal|0
condition|)
block|{
synchronized|synchronized
init|(
name|PatternParser
operator|.
name|class
init|)
block|{
try|try
block|{
name|startTime
operator|=
name|ManagementFactory
operator|.
name|getRuntimeMXBean
argument_list|()
operator|.
name|getStartTime
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|startTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|startTime
return|;
block|}
block|}
end_class

end_unit

