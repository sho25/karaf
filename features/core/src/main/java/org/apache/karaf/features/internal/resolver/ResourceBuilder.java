begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|features
operator|.
name|internal
operator|.
name|resolver
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|utils
operator|.
name|version
operator|.
name|VersionRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|BundleException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|Version
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|namespace
operator|.
name|IdentityNamespace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|wiring
operator|.
name|BundleRevision
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|namespace
operator|.
name|service
operator|.
name|ServiceNamespace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|resource
operator|.
name|Capability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|resource
operator|.
name|Requirement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|resource
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|repository
operator|.
name|ContentNamespace
import|;
end_import

begin_class
specifier|public
specifier|final
class|class
name|ResourceBuilder
block|{
specifier|public
specifier|static
specifier|final
name|String
name|RESOLUTION_DYNAMIC
init|=
literal|"dynamic"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|EOF
init|=
operator|(
name|char
operator|)
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|CLAUSE_START
init|=
literal|0
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|PARAMETER_START
init|=
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|KEY
init|=
literal|2
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DIRECTIVE_OR_TYPEDATTRIBUTE
init|=
literal|4
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|ARGUMENT
init|=
literal|8
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|VALUE
init|=
literal|16
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|CHAR
init|=
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DELIMITER
init|=
literal|2
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|STARTQUOTE
init|=
literal|4
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|ENDQUOTE
init|=
literal|8
decl_stmt|;
specifier|private
name|ResourceBuilder
parameter_list|()
block|{     }
specifier|public
specifier|static
name|ResourceImpl
name|build
parameter_list|(
name|String
name|uri
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|headerMap
parameter_list|)
throws|throws
name|BundleException
block|{
comment|// Verify that only manifest version 2 is specified.
name|String
name|manifestVersion
init|=
name|getManifestVersion
argument_list|(
name|headerMap
argument_list|)
decl_stmt|;
if|if
condition|(
name|manifestVersion
operator|==
literal|null
operator|||
operator|!
name|manifestVersion
operator|.
name|equals
argument_list|(
literal|"2"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Unsupported 'Bundle-ManifestVersion' value: "
operator|+
name|manifestVersion
argument_list|)
throw|;
block|}
comment|//
comment|// Parse bundle version.
comment|//
name|Version
name|bundleVersion
init|=
name|Version
operator|.
name|emptyVersion
decl_stmt|;
if|if
condition|(
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|BUNDLE_VERSION
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|bundleVersion
operator|=
name|Version
operator|.
name|parseVersion
argument_list|(
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|BUNDLE_VERSION
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Parse bundle symbolic name.
comment|//
name|String
name|bundleSymbolicName
decl_stmt|;
name|ParsedHeaderClause
name|bundleCap
init|=
name|parseBundleSymbolicName
argument_list|(
name|headerMap
argument_list|)
decl_stmt|;
if|if
condition|(
name|bundleCap
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Bundle manifest must include bundle symbolic name"
argument_list|)
throw|;
block|}
name|bundleSymbolicName
operator|=
operator|(
name|String
operator|)
name|bundleCap
operator|.
name|attrs
operator|.
name|get
argument_list|(
name|BundleRevision
operator|.
name|BUNDLE_NAMESPACE
argument_list|)
expr_stmt|;
comment|// Now that we have symbolic name and version, create the resource
name|String
name|type
init|=
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|FRAGMENT_HOST
argument_list|)
operator|==
literal|null
condition|?
name|IdentityNamespace
operator|.
name|TYPE_BUNDLE
else|:
name|IdentityNamespace
operator|.
name|TYPE_FRAGMENT
decl_stmt|;
name|ResourceImpl
name|resource
init|=
operator|new
name|ResourceImpl
argument_list|(
name|bundleSymbolicName
argument_list|,
name|type
argument_list|,
name|bundleVersion
argument_list|)
decl_stmt|;
if|if
condition|(
name|uri
operator|!=
literal|null
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|attrs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|attrs
operator|.
name|put
argument_list|(
name|ContentNamespace
operator|.
name|CAPABILITY_URL_ATTRIBUTE
argument_list|,
name|uri
argument_list|)
expr_stmt|;
name|resource
operator|.
name|addCapability
argument_list|(
operator|new
name|CapabilityImpl
argument_list|(
name|resource
argument_list|,
name|ContentNamespace
operator|.
name|CONTENT_NAMESPACE
argument_list|,
name|Collections
operator|.
expr|<
name|String
argument_list|,
name|String
operator|>
name|emptyMap
argument_list|()
argument_list|,
name|attrs
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Add a bundle and host capability to all
comment|// non-fragment bundles. A host capability is the same
comment|// as a require capability, but with a different capability
comment|// namespace. Bundle capabilities resolve required-bundle
comment|// dependencies, while host capabilities resolve fragment-host
comment|// dependencies.
if|if
condition|(
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|FRAGMENT_HOST
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// All non-fragment bundles have bundle capability.
name|resource
operator|.
name|addCapability
argument_list|(
operator|new
name|CapabilityImpl
argument_list|(
name|resource
argument_list|,
name|BundleRevision
operator|.
name|BUNDLE_NAMESPACE
argument_list|,
name|bundleCap
operator|.
name|dirs
argument_list|,
name|bundleCap
operator|.
name|attrs
argument_list|)
argument_list|)
expr_stmt|;
comment|// A non-fragment bundle can choose to not have a host capability.
name|String
name|attachment
init|=
name|bundleCap
operator|.
name|dirs
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|FRAGMENT_ATTACHMENT_DIRECTIVE
argument_list|)
decl_stmt|;
name|attachment
operator|=
operator|(
name|attachment
operator|==
literal|null
operator|)
condition|?
name|Constants
operator|.
name|FRAGMENT_ATTACHMENT_RESOLVETIME
else|:
name|attachment
expr_stmt|;
if|if
condition|(
operator|!
name|attachment
operator|.
name|equalsIgnoreCase
argument_list|(
name|Constants
operator|.
name|FRAGMENT_ATTACHMENT_NEVER
argument_list|)
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|hostAttrs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|bundleCap
operator|.
name|attrs
argument_list|)
decl_stmt|;
name|Object
name|value
init|=
name|hostAttrs
operator|.
name|remove
argument_list|(
name|BundleRevision
operator|.
name|BUNDLE_NAMESPACE
argument_list|)
decl_stmt|;
name|hostAttrs
operator|.
name|put
argument_list|(
name|BundleRevision
operator|.
name|HOST_NAMESPACE
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|resource
operator|.
name|addCapability
argument_list|(
operator|new
name|CapabilityImpl
argument_list|(
name|resource
argument_list|,
name|BundleRevision
operator|.
name|HOST_NAMESPACE
argument_list|,
name|bundleCap
operator|.
name|dirs
argument_list|,
name|hostAttrs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// Parse Fragment-Host.
comment|//
name|List
argument_list|<
name|RequirementImpl
argument_list|>
name|hostReqs
init|=
name|parseFragmentHost
argument_list|(
name|resource
argument_list|,
name|headerMap
argument_list|)
decl_stmt|;
comment|//
comment|// Parse Require-Bundle
comment|//
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|rbClauses
init|=
name|parseStandardHeader
argument_list|(
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|REQUIRE_BUNDLE
argument_list|)
argument_list|)
decl_stmt|;
name|rbClauses
operator|=
name|normalizeRequireClauses
argument_list|(
name|rbClauses
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Requirement
argument_list|>
name|rbReqs
init|=
name|convertRequires
argument_list|(
name|rbClauses
argument_list|,
name|resource
argument_list|)
decl_stmt|;
comment|//
comment|// Parse Import-Package.
comment|//
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|importClauses
init|=
name|parseStandardHeader
argument_list|(
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|IMPORT_PACKAGE
argument_list|)
argument_list|)
decl_stmt|;
name|importClauses
operator|=
name|normalizeImportClauses
argument_list|(
name|importClauses
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Requirement
argument_list|>
name|importReqs
init|=
name|convertImports
argument_list|(
name|importClauses
argument_list|,
name|resource
argument_list|)
decl_stmt|;
comment|//
comment|// Parse DynamicImport-Package.
comment|//
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|dynamicClauses
init|=
name|parseStandardHeader
argument_list|(
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|DYNAMICIMPORT_PACKAGE
argument_list|)
argument_list|)
decl_stmt|;
name|dynamicClauses
operator|=
name|normalizeDynamicImportClauses
argument_list|(
name|dynamicClauses
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Requirement
argument_list|>
name|dynamicReqs
init|=
name|convertImports
argument_list|(
name|dynamicClauses
argument_list|,
name|resource
argument_list|)
decl_stmt|;
comment|//
comment|// Parse Require-Capability.
comment|//
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|requireClauses
init|=
name|parseStandardHeader
argument_list|(
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|REQUIRE_CAPABILITY
argument_list|)
argument_list|)
decl_stmt|;
name|requireClauses
operator|=
name|normalizeRequireCapabilityClauses
argument_list|(
name|requireClauses
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Requirement
argument_list|>
name|requireReqs
init|=
name|convertRequireCapabilities
argument_list|(
name|requireClauses
argument_list|,
name|resource
argument_list|)
decl_stmt|;
comment|//
comment|// Parse Export-Package.
comment|//
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|exportClauses
init|=
name|parseStandardHeader
argument_list|(
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|EXPORT_PACKAGE
argument_list|)
argument_list|)
decl_stmt|;
name|exportClauses
operator|=
name|normalizeExportClauses
argument_list|(
name|exportClauses
argument_list|,
name|bundleSymbolicName
argument_list|,
name|bundleVersion
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Capability
argument_list|>
name|exportCaps
init|=
name|convertExports
argument_list|(
name|exportClauses
argument_list|,
name|resource
argument_list|)
decl_stmt|;
comment|//
comment|// Parse Provide-Capability.
comment|//
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|provideClauses
init|=
name|parseStandardHeader
argument_list|(
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|PROVIDE_CAPABILITY
argument_list|)
argument_list|)
decl_stmt|;
name|provideClauses
operator|=
name|normalizeProvideCapabilityClauses
argument_list|(
name|provideClauses
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Capability
argument_list|>
name|provideCaps
init|=
name|convertProvideCapabilities
argument_list|(
name|provideClauses
argument_list|,
name|resource
argument_list|)
decl_stmt|;
comment|//
comment|// Parse Import-Service and Export-Service
comment|// if Require-Capability and Provide-Capability are not set for services
comment|//
name|boolean
name|hasServiceReferenceCapability
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Capability
name|cap
range|:
name|exportCaps
control|)
block|{
name|hasServiceReferenceCapability
operator||=
name|ServiceNamespace
operator|.
name|SERVICE_NAMESPACE
operator|.
name|equals
argument_list|(
name|cap
operator|.
name|getNamespace
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasServiceReferenceCapability
condition|)
block|{
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|exportServices
init|=
name|parseStandardHeader
argument_list|(
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|EXPORT_SERVICE
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Capability
argument_list|>
name|caps
init|=
name|convertExportService
argument_list|(
name|exportServices
argument_list|,
name|resource
argument_list|)
decl_stmt|;
name|provideCaps
operator|.
name|addAll
argument_list|(
name|caps
argument_list|)
expr_stmt|;
block|}
name|boolean
name|hasServiceReferenceRequirement
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Requirement
name|req
range|:
name|requireReqs
control|)
block|{
name|hasServiceReferenceRequirement
operator||=
name|ServiceNamespace
operator|.
name|SERVICE_NAMESPACE
operator|.
name|equals
argument_list|(
name|req
operator|.
name|getNamespace
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasServiceReferenceRequirement
condition|)
block|{
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|importServices
init|=
name|parseStandardHeader
argument_list|(
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|IMPORT_SERVICE
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Requirement
argument_list|>
name|reqs
init|=
name|convertImportService
argument_list|(
name|importServices
argument_list|,
name|resource
argument_list|)
decl_stmt|;
name|requireReqs
operator|.
name|addAll
argument_list|(
name|reqs
argument_list|)
expr_stmt|;
block|}
comment|// Combine all capabilities.
name|resource
operator|.
name|addCapabilities
argument_list|(
name|exportCaps
argument_list|)
expr_stmt|;
name|resource
operator|.
name|addCapabilities
argument_list|(
name|provideCaps
argument_list|)
expr_stmt|;
comment|// Combine all requirements.
name|resource
operator|.
name|addRequirements
argument_list|(
name|hostReqs
argument_list|)
expr_stmt|;
name|resource
operator|.
name|addRequirements
argument_list|(
name|importReqs
argument_list|)
expr_stmt|;
name|resource
operator|.
name|addRequirements
argument_list|(
name|rbReqs
argument_list|)
expr_stmt|;
name|resource
operator|.
name|addRequirements
argument_list|(
name|requireReqs
argument_list|)
expr_stmt|;
name|resource
operator|.
name|addRequirements
argument_list|(
name|dynamicReqs
argument_list|)
expr_stmt|;
return|return
name|resource
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|Requirement
argument_list|>
name|parseRequirement
parameter_list|(
name|Resource
name|resource
parameter_list|,
name|String
name|requirement
parameter_list|)
throws|throws
name|BundleException
block|{
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|requireClauses
init|=
name|parseStandardHeader
argument_list|(
name|requirement
argument_list|)
decl_stmt|;
name|requireClauses
operator|=
name|normalizeRequireCapabilityClauses
argument_list|(
name|requireClauses
argument_list|)
expr_stmt|;
return|return
name|convertRequireCapabilities
argument_list|(
name|requireClauses
argument_list|,
name|resource
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|Capability
argument_list|>
name|parseCapability
parameter_list|(
name|Resource
name|resource
parameter_list|,
name|String
name|capability
parameter_list|)
throws|throws
name|BundleException
block|{
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|provideClauses
init|=
name|parseStandardHeader
argument_list|(
name|capability
argument_list|)
decl_stmt|;
name|provideClauses
operator|=
name|normalizeProvideCapabilityClauses
argument_list|(
name|provideClauses
argument_list|)
expr_stmt|;
return|return
name|convertProvideCapabilities
argument_list|(
name|provideClauses
argument_list|,
name|resource
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|private
specifier|static
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|normalizeImportClauses
parameter_list|(
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|clauses
parameter_list|)
throws|throws
name|BundleException
block|{
comment|// Verify that the values are equals if the package specifies
comment|// both version and specification-version attributes.
name|Set
argument_list|<
name|String
argument_list|>
name|dupeSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ParsedHeaderClause
name|clause
range|:
name|clauses
control|)
block|{
comment|// Check for "version" and "specification-version" attributes
comment|// and verify they are the same if both are specified.
name|Object
name|v
init|=
name|clause
operator|.
name|attrs
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|VERSION_ATTRIBUTE
argument_list|)
decl_stmt|;
name|Object
name|sv
init|=
name|clause
operator|.
name|attrs
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|PACKAGE_SPECIFICATION_VERSION
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|sv
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// Verify they are equal.
if|if
condition|(
operator|!
operator|(
operator|(
name|String
operator|)
name|v
operator|)
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|String
operator|)
name|sv
operator|)
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Both version and specification-version are specified, but they are not equal."
argument_list|)
throw|;
block|}
block|}
comment|// Ensure that only the "version" attribute is used and convert
comment|// it to the VersionRange type.
if|if
condition|(
operator|(
name|v
operator|!=
literal|null
operator|)
operator|||
operator|(
name|sv
operator|!=
literal|null
operator|)
condition|)
block|{
name|clause
operator|.
name|attrs
operator|.
name|remove
argument_list|(
name|Constants
operator|.
name|PACKAGE_SPECIFICATION_VERSION
argument_list|)
expr_stmt|;
name|v
operator|=
operator|(
name|v
operator|==
literal|null
operator|)
condition|?
name|sv
else|:
name|v
expr_stmt|;
name|clause
operator|.
name|attrs
operator|.
name|put
argument_list|(
name|Constants
operator|.
name|VERSION_ATTRIBUTE
argument_list|,
name|VersionRange
operator|.
name|parseVersionRange
argument_list|(
name|v
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If bundle version is specified, then convert its type to VersionRange.
name|v
operator|=
name|clause
operator|.
name|attrs
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|BUNDLE_VERSION_ATTRIBUTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
literal|null
condition|)
block|{
name|clause
operator|.
name|attrs
operator|.
name|put
argument_list|(
name|Constants
operator|.
name|BUNDLE_VERSION_ATTRIBUTE
argument_list|,
name|VersionRange
operator|.
name|parseVersionRange
argument_list|(
name|v
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Verify java.* is not imported, nor any duplicate imports.
for|for
control|(
name|String
name|pkgName
range|:
name|clause
operator|.
name|paths
control|)
block|{
if|if
condition|(
operator|!
name|dupeSet
operator|.
name|contains
argument_list|(
name|pkgName
argument_list|)
condition|)
block|{
comment|// Verify that java.* packages are not imported.
if|if
condition|(
name|pkgName
operator|.
name|startsWith
argument_list|(
literal|"java."
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Importing java.* packages not allowed: "
operator|+
name|pkgName
argument_list|)
throw|;
comment|// The character "." has no meaning in the OSGi spec except
comment|// when placed on the bundle class path. Some people, however,
comment|// mistakenly think it means the default package when imported
comment|// or exported. This is not correct. It is invalid.
block|}
elseif|else
if|if
condition|(
name|pkgName
operator|.
name|equals
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Importing '.' is invalid."
argument_list|)
throw|;
comment|// Make sure a package name was specified.
block|}
elseif|else
if|if
condition|(
name|pkgName
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Imported package names cannot be zero length."
argument_list|)
throw|;
block|}
name|dupeSet
operator|.
name|add
argument_list|(
name|pkgName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Duplicate import: "
operator|+
name|pkgName
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|clauses
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Capability
argument_list|>
name|convertExportService
parameter_list|(
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|clauses
parameter_list|,
name|Resource
name|resource
parameter_list|)
block|{
name|List
argument_list|<
name|Capability
argument_list|>
name|capList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ParsedHeaderClause
name|clause
range|:
name|clauses
control|)
block|{
for|for
control|(
name|String
name|path
range|:
name|clause
operator|.
name|paths
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|dirs
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|dirs
operator|.
name|put
argument_list|(
name|ServiceNamespace
operator|.
name|CAPABILITY_EFFECTIVE_DIRECTIVE
argument_list|,
name|ServiceNamespace
operator|.
name|EFFECTIVE_ACTIVE
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|attrs
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|attrs
operator|.
name|put
argument_list|(
name|Constants
operator|.
name|OBJECTCLASS
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|putAll
argument_list|(
name|clause
operator|.
name|attrs
argument_list|)
expr_stmt|;
name|capList
operator|.
name|add
argument_list|(
operator|new
name|CapabilityImpl
argument_list|(
name|resource
argument_list|,
name|ServiceNamespace
operator|.
name|SERVICE_NAMESPACE
argument_list|,
name|dirs
argument_list|,
name|attrs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|capList
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Requirement
argument_list|>
name|convertImportService
parameter_list|(
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|clauses
parameter_list|,
name|Resource
name|resource
parameter_list|)
throws|throws
name|BundleException
block|{
try|try
block|{
name|List
argument_list|<
name|Requirement
argument_list|>
name|reqList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ParsedHeaderClause
name|clause
range|:
name|clauses
control|)
block|{
for|for
control|(
name|String
name|path
range|:
name|clause
operator|.
name|paths
control|)
block|{
name|String
name|multiple
init|=
name|clause
operator|.
name|dirs
operator|.
name|get
argument_list|(
literal|"multiple"
argument_list|)
decl_stmt|;
name|String
name|avail
init|=
name|clause
operator|.
name|dirs
operator|.
name|get
argument_list|(
literal|"availability"
argument_list|)
decl_stmt|;
name|String
name|filter
init|=
operator|(
name|String
operator|)
name|clause
operator|.
name|attrs
operator|.
name|get
argument_list|(
literal|"filter"
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|dirs
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|dirs
operator|.
name|put
argument_list|(
name|ServiceNamespace
operator|.
name|REQUIREMENT_EFFECTIVE_DIRECTIVE
argument_list|,
name|ServiceNamespace
operator|.
name|EFFECTIVE_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"optional"
operator|.
name|equals
argument_list|(
name|avail
argument_list|)
condition|)
block|{
name|dirs
operator|.
name|put
argument_list|(
name|ServiceNamespace
operator|.
name|REQUIREMENT_RESOLUTION_DIRECTIVE
argument_list|,
name|ServiceNamespace
operator|.
name|RESOLUTION_OPTIONAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|"true"
operator|.
name|equals
argument_list|(
name|multiple
argument_list|)
condition|)
block|{
name|dirs
operator|.
name|put
argument_list|(
name|ServiceNamespace
operator|.
name|REQUIREMENT_CARDINALITY_DIRECTIVE
argument_list|,
name|ServiceNamespace
operator|.
name|CARDINALITY_MULTIPLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
block|{
name|filter
operator|=
literal|"("
operator|+
name|Constants
operator|.
name|OBJECTCLASS
operator|+
literal|"="
operator|+
name|path
operator|+
literal|")"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|filter
operator|.
name|startsWith
argument_list|(
literal|"("
argument_list|)
operator|&&
operator|!
name|filter
operator|.
name|endsWith
argument_list|(
literal|")"
argument_list|)
condition|)
block|{
name|filter
operator|=
literal|"(&("
operator|+
name|Constants
operator|.
name|OBJECTCLASS
operator|+
literal|"="
operator|+
name|path
operator|+
literal|")("
operator|+
name|filter
operator|+
literal|"))"
expr_stmt|;
block|}
else|else
block|{
name|filter
operator|=
literal|"(&("
operator|+
name|Constants
operator|.
name|OBJECTCLASS
operator|+
literal|"="
operator|+
name|path
operator|+
literal|")"
operator|+
name|filter
operator|+
literal|")"
expr_stmt|;
block|}
name|dirs
operator|.
name|put
argument_list|(
name|ServiceNamespace
operator|.
name|REQUIREMENT_FILTER_DIRECTIVE
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|reqList
operator|.
name|add
argument_list|(
operator|new
name|RequirementImpl
argument_list|(
name|resource
argument_list|,
name|ServiceNamespace
operator|.
name|SERVICE_NAMESPACE
argument_list|,
name|dirs
argument_list|,
name|Collections
operator|.
expr|<
name|String
argument_list|,
name|Object
operator|>
name|emptyMap
argument_list|()
argument_list|,
name|SimpleFilter
operator|.
name|parse
argument_list|(
name|filter
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|reqList
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Error creating requirement: "
operator|+
name|ex
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Requirement
argument_list|>
name|convertImports
parameter_list|(
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|clauses
parameter_list|,
name|Resource
name|resource
parameter_list|)
block|{
comment|// Now convert generic header clauses into requirements.
name|List
argument_list|<
name|Requirement
argument_list|>
name|reqList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ParsedHeaderClause
name|clause
range|:
name|clauses
control|)
block|{
for|for
control|(
name|String
name|path
range|:
name|clause
operator|.
name|paths
control|)
block|{
comment|// Prepend the package name to the array of attributes.
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|attrs
init|=
name|clause
operator|.
name|attrs
decl_stmt|;
comment|// Note that we use a linked hash map here to ensure the
comment|// package attribute is first, which will make indexing
comment|// more efficient.
comment|// TODO: OSGi R4.3 - This is ordering is kind of hacky.
comment|// Prepend the package name to the array of attributes.
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|newAttrs
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|attrs
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|// We want this first from an indexing perspective.
name|newAttrs
operator|.
name|put
argument_list|(
name|BundleRevision
operator|.
name|PACKAGE_NAMESPACE
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|newAttrs
operator|.
name|putAll
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
comment|// But we need to put it again to make sure it wasn't overwritten.
name|newAttrs
operator|.
name|put
argument_list|(
name|BundleRevision
operator|.
name|PACKAGE_NAMESPACE
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|// Create filter now so we can inject filter directive.
name|SimpleFilter
name|sf
init|=
name|SimpleFilter
operator|.
name|convert
argument_list|(
name|newAttrs
argument_list|)
decl_stmt|;
comment|// Inject filter directive.
comment|// TODO: OSGi R4.3 - Can we insert this on demand somehow?
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|dirs
init|=
name|clause
operator|.
name|dirs
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|newDirs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|dirs
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|newDirs
operator|.
name|putAll
argument_list|(
name|dirs
argument_list|)
expr_stmt|;
name|newDirs
operator|.
name|put
argument_list|(
name|Constants
operator|.
name|FILTER_DIRECTIVE
argument_list|,
name|sf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Create package requirement and add to requirement list.
name|reqList
operator|.
name|add
argument_list|(
operator|new
name|RequirementImpl
argument_list|(
name|resource
argument_list|,
name|BundleRevision
operator|.
name|PACKAGE_NAMESPACE
argument_list|,
name|newDirs
argument_list|,
name|Collections
operator|.
expr|<
name|String
argument_list|,
name|Object
operator|>
name|emptyMap
argument_list|()
argument_list|,
name|sf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|reqList
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|private
specifier|static
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|normalizeDynamicImportClauses
parameter_list|(
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|clauses
parameter_list|)
throws|throws
name|BundleException
block|{
comment|// Verify that the values are equals if the package specifies
comment|// both version and specification-version attributes.
for|for
control|(
name|ParsedHeaderClause
name|clause
range|:
name|clauses
control|)
block|{
comment|// Add the resolution directive to indicate that these are
comment|// dynamic imports.
name|clause
operator|.
name|dirs
operator|.
name|put
argument_list|(
name|Constants
operator|.
name|RESOLUTION_DIRECTIVE
argument_list|,
name|RESOLUTION_DYNAMIC
argument_list|)
expr_stmt|;
comment|// Check for "version" and "specification-version" attributes
comment|// and verify they are the same if both are specified.
name|Object
name|v
init|=
name|clause
operator|.
name|attrs
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|VERSION_ATTRIBUTE
argument_list|)
decl_stmt|;
name|Object
name|sv
init|=
name|clause
operator|.
name|attrs
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|PACKAGE_SPECIFICATION_VERSION
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|sv
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// Verify they are equal.
if|if
condition|(
operator|!
operator|(
operator|(
name|String
operator|)
name|v
operator|)
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|String
operator|)
name|sv
operator|)
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Both version and specification-version are specified, but they are not equal."
argument_list|)
throw|;
block|}
block|}
comment|// Ensure that only the "version" attribute is used and convert
comment|// it to the VersionRange type.
if|if
condition|(
operator|(
name|v
operator|!=
literal|null
operator|)
operator|||
operator|(
name|sv
operator|!=
literal|null
operator|)
condition|)
block|{
name|clause
operator|.
name|attrs
operator|.
name|remove
argument_list|(
name|Constants
operator|.
name|PACKAGE_SPECIFICATION_VERSION
argument_list|)
expr_stmt|;
name|v
operator|=
operator|(
name|v
operator|==
literal|null
operator|)
condition|?
name|sv
else|:
name|v
expr_stmt|;
name|clause
operator|.
name|attrs
operator|.
name|put
argument_list|(
name|Constants
operator|.
name|VERSION_ATTRIBUTE
argument_list|,
name|VersionRange
operator|.
name|parseVersionRange
argument_list|(
name|v
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If bundle version is specified, then convert its type to VersionRange.
name|v
operator|=
name|clause
operator|.
name|attrs
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|BUNDLE_VERSION_ATTRIBUTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
literal|null
condition|)
block|{
name|clause
operator|.
name|attrs
operator|.
name|put
argument_list|(
name|Constants
operator|.
name|BUNDLE_VERSION_ATTRIBUTE
argument_list|,
name|VersionRange
operator|.
name|parseVersionRange
argument_list|(
name|v
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Dynamic imports can have duplicates, so verify that java.*
comment|// packages are not imported.
for|for
control|(
name|String
name|pkgName
range|:
name|clause
operator|.
name|paths
control|)
block|{
if|if
condition|(
name|pkgName
operator|.
name|startsWith
argument_list|(
literal|"java."
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Dynamically importing java.* packages not allowed: "
operator|+
name|pkgName
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|!
name|pkgName
operator|.
name|equals
argument_list|(
literal|"*"
argument_list|)
operator|&&
name|pkgName
operator|.
name|endsWith
argument_list|(
literal|"*"
argument_list|)
operator|&&
operator|!
name|pkgName
operator|.
name|endsWith
argument_list|(
literal|".*"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Partial package name wild carding is not allowed: "
operator|+
name|pkgName
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|clauses
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|normalizeRequireCapabilityClauses
parameter_list|(
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|clauses
parameter_list|)
throws|throws
name|BundleException
block|{
return|return
name|clauses
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|normalizeProvideCapabilityClauses
parameter_list|(
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|clauses
parameter_list|)
throws|throws
name|BundleException
block|{
comment|// Convert attributes into specified types.
for|for
control|(
name|ParsedHeaderClause
name|clause
range|:
name|clauses
control|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|clause
operator|.
name|types
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|type
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|equals
argument_list|(
literal|"String"
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Double"
argument_list|)
condition|)
block|{
name|clause
operator|.
name|attrs
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
operator|new
name|Double
argument_list|(
name|clause
operator|.
name|attrs
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Version"
argument_list|)
condition|)
block|{
name|clause
operator|.
name|attrs
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
operator|new
name|Version
argument_list|(
name|clause
operator|.
name|attrs
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Long"
argument_list|)
condition|)
block|{
name|clause
operator|.
name|attrs
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
operator|new
name|Long
argument_list|(
name|clause
operator|.
name|attrs
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|startsWith
argument_list|(
literal|"List"
argument_list|)
condition|)
block|{
name|int
name|startIdx
init|=
name|type
operator|.
name|indexOf
argument_list|(
literal|'<'
argument_list|)
decl_stmt|;
name|int
name|endIdx
init|=
name|type
operator|.
name|indexOf
argument_list|(
literal|'>'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|startIdx
operator|>
literal|0
operator|)
operator|&&
operator|(
name|endIdx
operator|<=
name|startIdx
operator|)
operator|)
operator|||
operator|(
operator|(
name|startIdx
operator|<
literal|0
operator|)
operator|&&
operator|(
name|endIdx
operator|>
literal|0
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Invalid Provide-Capability attribute list type for '"
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|"' : "
operator|+
name|type
argument_list|)
throw|;
block|}
name|String
name|listType
init|=
literal|"String"
decl_stmt|;
if|if
condition|(
name|endIdx
operator|>
name|startIdx
condition|)
block|{
name|listType
operator|=
name|type
operator|.
name|substring
argument_list|(
name|startIdx
operator|+
literal|1
argument_list|,
name|endIdx
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|tokens
init|=
name|parseDelimitedString
argument_list|(
name|clause
operator|.
name|attrs
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
literal|","
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|values
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|tokens
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|token
range|:
name|tokens
control|)
block|{
switch|switch
condition|(
name|listType
condition|)
block|{
case|case
literal|"String"
case|:
name|values
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"Double"
case|:
name|values
operator|.
name|add
argument_list|(
operator|new
name|Double
argument_list|(
name|token
operator|.
name|trim
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"Version"
case|:
name|values
operator|.
name|add
argument_list|(
operator|new
name|Version
argument_list|(
name|token
operator|.
name|trim
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"Long"
case|:
name|values
operator|.
name|add
argument_list|(
operator|new
name|Long
argument_list|(
name|token
operator|.
name|trim
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Unknown Provide-Capability attribute list type for '"
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|"' : "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
name|clause
operator|.
name|attrs
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Unknown Provide-Capability attribute type for '"
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|"' : "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
block|}
block|}
return|return
name|clauses
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Requirement
argument_list|>
name|convertRequireCapabilities
parameter_list|(
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|clauses
parameter_list|,
name|Resource
name|resource
parameter_list|)
throws|throws
name|BundleException
block|{
comment|// Now convert generic header clauses into requirements.
name|List
argument_list|<
name|Requirement
argument_list|>
name|reqList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ParsedHeaderClause
name|clause
range|:
name|clauses
control|)
block|{
try|try
block|{
name|String
name|filterStr
init|=
name|clause
operator|.
name|dirs
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|FILTER_DIRECTIVE
argument_list|)
decl_stmt|;
name|SimpleFilter
name|sf
init|=
operator|(
name|filterStr
operator|!=
literal|null
operator|)
condition|?
name|SimpleFilter
operator|.
name|parse
argument_list|(
name|filterStr
argument_list|)
else|:
operator|new
name|SimpleFilter
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|SimpleFilter
operator|.
name|MATCH_ALL
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|path
range|:
name|clause
operator|.
name|paths
control|)
block|{
comment|// Create requirement and add to requirement list.
name|reqList
operator|.
name|add
argument_list|(
operator|new
name|RequirementImpl
argument_list|(
name|resource
argument_list|,
name|path
argument_list|,
name|clause
operator|.
name|dirs
argument_list|,
name|clause
operator|.
name|attrs
argument_list|,
name|sf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Error creating requirement: "
operator|+
name|ex
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
return|return
name|reqList
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Capability
argument_list|>
name|convertProvideCapabilities
parameter_list|(
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|clauses
parameter_list|,
name|Resource
name|resource
parameter_list|)
throws|throws
name|BundleException
block|{
name|List
argument_list|<
name|Capability
argument_list|>
name|capList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ParsedHeaderClause
name|clause
range|:
name|clauses
control|)
block|{
for|for
control|(
name|String
name|path
range|:
name|clause
operator|.
name|paths
control|)
block|{
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
literal|"osgi.wiring."
argument_list|)
condition|)
block|{
comment|//                    throw new BundleException("Manifest cannot use Provide-Capability for '" + path + "' namespace.");
block|}
comment|// Create package capability and add to capability list.
name|capList
operator|.
name|add
argument_list|(
operator|new
name|CapabilityImpl
argument_list|(
name|resource
argument_list|,
name|path
argument_list|,
name|clause
operator|.
name|dirs
argument_list|,
name|clause
operator|.
name|attrs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|capList
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|private
specifier|static
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|normalizeExportClauses
parameter_list|(
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|clauses
parameter_list|,
name|String
name|bsn
parameter_list|,
name|Version
name|bv
parameter_list|)
throws|throws
name|BundleException
block|{
comment|// Verify that "java.*" packages are not exported.
for|for
control|(
name|ParsedHeaderClause
name|clause
range|:
name|clauses
control|)
block|{
comment|// Verify that the named package has not already been declared.
for|for
control|(
name|String
name|pkgName
range|:
name|clause
operator|.
name|paths
control|)
block|{
comment|// Verify that java.* packages are not exported.
if|if
condition|(
name|pkgName
operator|.
name|startsWith
argument_list|(
literal|"java."
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Exporting java.* packages not allowed: "
operator|+
name|pkgName
argument_list|)
throw|;
comment|// The character "." has no meaning in the OSGi spec except
comment|// when placed on the bundle class path. Some people, however,
comment|// mistakenly think it means the default package when imported
comment|// or exported. This is not correct. It is invalid.
block|}
elseif|else
if|if
condition|(
name|pkgName
operator|.
name|equals
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Exporing '.' is invalid."
argument_list|)
throw|;
comment|// Make sure a package name was specified.
block|}
elseif|else
if|if
condition|(
name|pkgName
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Exported package names cannot be zero length."
argument_list|)
throw|;
block|}
block|}
comment|// Check for "version" and "specification-version" attributes
comment|// and verify they are the same if both are specified.
name|Object
name|v
init|=
name|clause
operator|.
name|attrs
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|VERSION_ATTRIBUTE
argument_list|)
decl_stmt|;
name|Object
name|sv
init|=
name|clause
operator|.
name|attrs
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|PACKAGE_SPECIFICATION_VERSION
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|sv
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// Verify they are equal.
if|if
condition|(
operator|!
operator|(
operator|(
name|String
operator|)
name|v
operator|)
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|String
operator|)
name|sv
operator|)
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Both version and specification-version are specified, but they are not equal."
argument_list|)
throw|;
block|}
block|}
comment|// Always add the default version if not specified.
if|if
condition|(
operator|(
name|v
operator|==
literal|null
operator|)
operator|&&
operator|(
name|sv
operator|==
literal|null
operator|)
condition|)
block|{
name|v
operator|=
name|Version
operator|.
name|emptyVersion
expr_stmt|;
block|}
comment|// Ensure that only the "version" attribute is used and convert
comment|// it to the appropriate type.
if|if
condition|(
operator|(
name|v
operator|!=
literal|null
operator|)
operator|||
operator|(
name|sv
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// Convert version attribute to type Version.
name|clause
operator|.
name|attrs
operator|.
name|remove
argument_list|(
name|Constants
operator|.
name|PACKAGE_SPECIFICATION_VERSION
argument_list|)
expr_stmt|;
name|v
operator|=
operator|(
name|v
operator|==
literal|null
operator|)
condition|?
name|sv
else|:
name|v
expr_stmt|;
name|clause
operator|.
name|attrs
operator|.
name|put
argument_list|(
name|Constants
operator|.
name|VERSION_ATTRIBUTE
argument_list|,
name|Version
operator|.
name|parseVersion
argument_list|(
name|v
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Find symbolic name and version attribute, if present.
if|if
condition|(
name|clause
operator|.
name|attrs
operator|.
name|containsKey
argument_list|(
name|Constants
operator|.
name|BUNDLE_VERSION_ATTRIBUTE
argument_list|)
operator|||
name|clause
operator|.
name|attrs
operator|.
name|containsKey
argument_list|(
name|Constants
operator|.
name|BUNDLE_SYMBOLICNAME_ATTRIBUTE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Exports must not specify bundle symbolic name or bundle version."
argument_list|)
throw|;
block|}
comment|// Now that we know that there are no bundle symbolic name and version
comment|// attributes, add them since the spec says they are there implicitly.
name|clause
operator|.
name|attrs
operator|.
name|put
argument_list|(
name|Constants
operator|.
name|BUNDLE_SYMBOLICNAME_ATTRIBUTE
argument_list|,
name|bsn
argument_list|)
expr_stmt|;
name|clause
operator|.
name|attrs
operator|.
name|put
argument_list|(
name|Constants
operator|.
name|BUNDLE_VERSION_ATTRIBUTE
argument_list|,
name|bv
argument_list|)
expr_stmt|;
block|}
return|return
name|clauses
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Capability
argument_list|>
name|convertExports
parameter_list|(
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|clauses
parameter_list|,
name|Resource
name|resource
parameter_list|)
block|{
name|List
argument_list|<
name|Capability
argument_list|>
name|capList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ParsedHeaderClause
name|clause
range|:
name|clauses
control|)
block|{
for|for
control|(
name|String
name|pkgName
range|:
name|clause
operator|.
name|paths
control|)
block|{
comment|// Prepend the package name to the array of attributes.
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|attrs
init|=
name|clause
operator|.
name|attrs
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|newAttrs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|attrs
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|newAttrs
operator|.
name|putAll
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
name|newAttrs
operator|.
name|put
argument_list|(
name|BundleRevision
operator|.
name|PACKAGE_NAMESPACE
argument_list|,
name|pkgName
argument_list|)
expr_stmt|;
comment|// Create package capability and add to capability list.
name|capList
operator|.
name|add
argument_list|(
operator|new
name|CapabilityImpl
argument_list|(
name|resource
argument_list|,
name|BundleRevision
operator|.
name|PACKAGE_NAMESPACE
argument_list|,
name|clause
operator|.
name|dirs
argument_list|,
name|newAttrs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|capList
return|;
block|}
specifier|private
specifier|static
name|String
name|getManifestVersion
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|headerMap
parameter_list|)
block|{
name|String
name|manifestVersion
init|=
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|BUNDLE_MANIFESTVERSION
argument_list|)
decl_stmt|;
return|return
operator|(
name|manifestVersion
operator|==
literal|null
operator|)
condition|?
literal|"1"
else|:
name|manifestVersion
operator|.
name|trim
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|ParsedHeaderClause
name|parseBundleSymbolicName
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|headerMap
parameter_list|)
throws|throws
name|BundleException
block|{
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|clauses
init|=
name|parseStandardHeader
argument_list|(
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|BUNDLE_SYMBOLICNAME
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|clauses
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|clauses
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
name|clauses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|paths
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Cannot have multiple symbolic names: "
operator|+
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|BUNDLE_SYMBOLICNAME
argument_list|)
argument_list|)
throw|;
block|}
comment|// Get bundle version.
name|Version
name|bundleVersion
init|=
name|Version
operator|.
name|emptyVersion
decl_stmt|;
if|if
condition|(
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|BUNDLE_VERSION
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|bundleVersion
operator|=
name|Version
operator|.
name|parseVersion
argument_list|(
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|BUNDLE_VERSION
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Create a require capability and return it.
name|ParsedHeaderClause
name|clause
init|=
name|clauses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|symName
init|=
name|clause
operator|.
name|paths
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|clause
operator|.
name|attrs
operator|.
name|put
argument_list|(
name|BundleRevision
operator|.
name|BUNDLE_NAMESPACE
argument_list|,
name|symName
argument_list|)
expr_stmt|;
name|clause
operator|.
name|attrs
operator|.
name|put
argument_list|(
name|Constants
operator|.
name|BUNDLE_VERSION_ATTRIBUTE
argument_list|,
name|bundleVersion
argument_list|)
expr_stmt|;
return|return
name|clause
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|RequirementImpl
argument_list|>
name|parseFragmentHost
parameter_list|(
name|Resource
name|resource
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|headerMap
parameter_list|)
throws|throws
name|BundleException
block|{
name|List
argument_list|<
name|RequirementImpl
argument_list|>
name|reqs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|clauses
init|=
name|parseStandardHeader
argument_list|(
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|FRAGMENT_HOST
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|clauses
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Make sure that only one fragment host symbolic name is specified.
if|if
condition|(
name|clauses
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
name|clauses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|paths
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|BundleException
argument_list|(
literal|"Fragments cannot have multiple hosts: "
operator|+
name|headerMap
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|FRAGMENT_HOST
argument_list|)
argument_list|)
throw|;
block|}
comment|// If the bundle-version attribute is specified, then convert
comment|// it to the proper type.
name|Object
name|value
init|=
name|clauses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|attrs
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|BUNDLE_VERSION_ATTRIBUTE
argument_list|)
decl_stmt|;
name|value
operator|=
operator|(
name|value
operator|==
literal|null
operator|)
condition|?
literal|"0.0.0"
else|:
name|value
expr_stmt|;
name|clauses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|attrs
operator|.
name|put
argument_list|(
name|Constants
operator|.
name|BUNDLE_VERSION_ATTRIBUTE
argument_list|,
name|VersionRange
operator|.
name|parseVersionRange
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Note that we use a linked hash map here to ensure the
comment|// host symbolic name is first, which will make indexing
comment|// more efficient.
comment|// TODO: OSGi R4.3 - This is ordering is kind of hacky.
comment|// Prepend the host symbolic name to the map of attributes.
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|attrs
init|=
name|clauses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|attrs
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|newAttrs
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|attrs
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|// We want this first from an indexing perspective.
name|newAttrs
operator|.
name|put
argument_list|(
name|BundleRevision
operator|.
name|HOST_NAMESPACE
argument_list|,
name|clauses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|paths
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|newAttrs
operator|.
name|putAll
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
comment|// But we need to put it again to make sure it wasn't overwritten.
name|newAttrs
operator|.
name|put
argument_list|(
name|BundleRevision
operator|.
name|HOST_NAMESPACE
argument_list|,
name|clauses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|paths
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create filter now so we can inject filter directive.
name|SimpleFilter
name|sf
init|=
name|SimpleFilter
operator|.
name|convert
argument_list|(
name|newAttrs
argument_list|)
decl_stmt|;
comment|// Inject filter directive.
comment|// TODO: OSGi R4.3 - Can we insert this on demand somehow?
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|dirs
init|=
name|clauses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|dirs
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|newDirs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|dirs
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|newDirs
operator|.
name|putAll
argument_list|(
name|dirs
argument_list|)
expr_stmt|;
name|newDirs
operator|.
name|put
argument_list|(
name|Constants
operator|.
name|FILTER_DIRECTIVE
argument_list|,
name|sf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|reqs
operator|.
name|add
argument_list|(
operator|new
name|RequirementImpl
argument_list|(
name|resource
argument_list|,
name|BundleRevision
operator|.
name|HOST_NAMESPACE
argument_list|,
name|newDirs
argument_list|,
name|newAttrs
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|reqs
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|normalizeRequireClauses
parameter_list|(
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|clauses
parameter_list|)
block|{
comment|// Convert bundle version attribute to VersionRange type.
for|for
control|(
name|ParsedHeaderClause
name|clause
range|:
name|clauses
control|)
block|{
name|Object
name|value
init|=
name|clause
operator|.
name|attrs
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|BUNDLE_VERSION_ATTRIBUTE
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|clause
operator|.
name|attrs
operator|.
name|put
argument_list|(
name|Constants
operator|.
name|BUNDLE_VERSION_ATTRIBUTE
argument_list|,
name|VersionRange
operator|.
name|parseVersionRange
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|clauses
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Requirement
argument_list|>
name|convertRequires
parameter_list|(
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|clauses
parameter_list|,
name|Resource
name|resource
parameter_list|)
block|{
name|List
argument_list|<
name|Requirement
argument_list|>
name|reqList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ParsedHeaderClause
name|clause
range|:
name|clauses
control|)
block|{
for|for
control|(
name|String
name|path
range|:
name|clause
operator|.
name|paths
control|)
block|{
comment|// Prepend the bundle symbolic name to the array of attributes.
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|attrs
init|=
name|clause
operator|.
name|attrs
decl_stmt|;
comment|// Note that we use a linked hash map here to ensure the
comment|// symbolic name attribute is first, which will make indexing
comment|// more efficient.
comment|// TODO: OSGi R4.3 - This is ordering is kind of hacky.
comment|// Prepend the symbolic name to the array of attributes.
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|newAttrs
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|attrs
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|// We want this first from an indexing perspective.
name|newAttrs
operator|.
name|put
argument_list|(
name|BundleRevision
operator|.
name|BUNDLE_NAMESPACE
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|newAttrs
operator|.
name|putAll
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
comment|// But we need to put it again to make sure it wasn't overwritten.
name|newAttrs
operator|.
name|put
argument_list|(
name|BundleRevision
operator|.
name|BUNDLE_NAMESPACE
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|// Create filter now so we can inject filter directive.
name|SimpleFilter
name|sf
init|=
name|SimpleFilter
operator|.
name|convert
argument_list|(
name|newAttrs
argument_list|)
decl_stmt|;
comment|// Inject filter directive.
comment|// TODO: OSGi R4.3 - Can we insert this on demand somehow?
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|dirs
init|=
name|clause
operator|.
name|dirs
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|newDirs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|dirs
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|newDirs
operator|.
name|putAll
argument_list|(
name|dirs
argument_list|)
expr_stmt|;
name|newDirs
operator|.
name|put
argument_list|(
name|Constants
operator|.
name|FILTER_DIRECTIVE
argument_list|,
name|sf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Create package requirement and add to requirement list.
name|reqList
operator|.
name|add
argument_list|(
operator|new
name|RequirementImpl
argument_list|(
name|resource
argument_list|,
name|BundleRevision
operator|.
name|BUNDLE_NAMESPACE
argument_list|,
name|newDirs
argument_list|,
name|newAttrs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|reqList
return|;
block|}
specifier|private
specifier|static
name|char
name|charAt
parameter_list|(
name|int
name|pos
parameter_list|,
name|String
name|headers
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|>=
name|length
condition|)
block|{
return|return
name|EOF
return|;
block|}
return|return
name|headers
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|,
literal|"rawtypes"
block|}
argument_list|)
specifier|private
specifier|static
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|parseStandardHeader
parameter_list|(
name|String
name|header
parameter_list|)
block|{
name|List
argument_list|<
name|ParsedHeaderClause
argument_list|>
name|clauses
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|header
operator|==
literal|null
condition|)
block|{
return|return
name|clauses
return|;
block|}
name|ParsedHeaderClause
name|clause
init|=
literal|null
decl_stmt|;
name|String
name|key
init|=
literal|null
decl_stmt|;
name|Map
name|targetMap
init|=
literal|null
decl_stmt|;
name|int
name|state
init|=
name|CLAUSE_START
decl_stmt|;
name|int
name|currentPosition
init|=
literal|0
decl_stmt|;
name|int
name|startPosition
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
name|header
operator|.
name|length
argument_list|()
decl_stmt|;
name|boolean
name|quoted
init|=
literal|false
decl_stmt|;
name|boolean
name|escaped
init|=
literal|false
decl_stmt|;
name|char
name|currentChar
decl_stmt|;
do|do
block|{
name|currentChar
operator|=
name|charAt
argument_list|(
name|currentPosition
argument_list|,
name|header
argument_list|,
name|length
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|CLAUSE_START
case|:
name|clause
operator|=
operator|new
name|ParsedHeaderClause
argument_list|()
expr_stmt|;
name|clauses
operator|.
name|add
argument_list|(
name|clause
argument_list|)
expr_stmt|;
comment|// Fall through
case|case
name|PARAMETER_START
case|:
name|startPosition
operator|=
name|currentPosition
expr_stmt|;
name|state
operator|=
name|KEY
expr_stmt|;
comment|// Fall through
case|case
name|KEY
case|:
switch|switch
condition|(
name|currentChar
condition|)
block|{
case|case
literal|':'
case|:
case|case
literal|'='
case|:
name|key
operator|=
name|header
operator|.
name|substring
argument_list|(
name|startPosition
argument_list|,
name|currentPosition
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
name|startPosition
operator|=
name|currentPosition
operator|+
literal|1
expr_stmt|;
name|targetMap
operator|=
name|clause
operator|.
name|attrs
expr_stmt|;
name|state
operator|=
name|currentChar
operator|==
literal|':'
condition|?
name|DIRECTIVE_OR_TYPEDATTRIBUTE
else|:
name|ARGUMENT
expr_stmt|;
break|break;
case|case
name|EOF
case|:
case|case
literal|','
case|:
case|case
literal|';'
case|:
name|clause
operator|.
name|paths
operator|.
name|add
argument_list|(
name|header
operator|.
name|substring
argument_list|(
name|startPosition
argument_list|,
name|currentPosition
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|state
operator|=
name|currentChar
operator|==
literal|','
condition|?
name|CLAUSE_START
else|:
name|PARAMETER_START
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|currentPosition
operator|++
expr_stmt|;
break|break;
case|case
name|DIRECTIVE_OR_TYPEDATTRIBUTE
case|:
switch|switch
condition|(
name|currentChar
condition|)
block|{
case|case
literal|'='
case|:
if|if
condition|(
name|startPosition
operator|!=
name|currentPosition
condition|)
block|{
name|clause
operator|.
name|types
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|header
operator|.
name|substring
argument_list|(
name|startPosition
argument_list|,
name|currentPosition
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|targetMap
operator|=
name|clause
operator|.
name|dirs
expr_stmt|;
block|}
name|state
operator|=
name|ARGUMENT
expr_stmt|;
name|startPosition
operator|=
name|currentPosition
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|currentPosition
operator|++
expr_stmt|;
break|break;
case|case
name|ARGUMENT
case|:
if|if
condition|(
name|currentChar
operator|==
literal|'\"'
condition|)
block|{
name|quoted
operator|=
literal|true
expr_stmt|;
name|currentPosition
operator|++
expr_stmt|;
block|}
else|else
block|{
name|quoted
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|currentChar
argument_list|)
condition|)
block|{
name|state
operator|=
name|VALUE
expr_stmt|;
block|}
else|else
block|{
name|currentPosition
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|VALUE
case|:
if|if
condition|(
name|escaped
condition|)
block|{
name|escaped
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|currentChar
operator|==
literal|'\\'
condition|)
block|{
name|escaped
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|quoted
operator|&&
name|currentChar
operator|==
literal|'\"'
condition|)
block|{
name|quoted
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|quoted
condition|)
block|{
name|String
name|value
decl_stmt|;
switch|switch
condition|(
name|currentChar
condition|)
block|{
case|case
name|EOF
case|:
case|case
literal|';'
case|:
case|case
literal|','
case|:
name|value
operator|=
name|header
operator|.
name|substring
argument_list|(
name|startPosition
argument_list|,
name|currentPosition
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|startsWith
argument_list|(
literal|"\""
argument_list|)
operator|&&
name|value
operator|.
name|endsWith
argument_list|(
literal|"\""
argument_list|)
condition|)
block|{
name|value
operator|=
name|value
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|value
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetMap
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Duplicate '"
operator|+
name|key
operator|+
literal|"' in: "
operator|+
name|header
argument_list|)
throw|;
block|}
name|state
operator|=
name|currentChar
operator|==
literal|';'
condition|?
name|PARAMETER_START
else|:
name|CLAUSE_START
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|currentPosition
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
do|while
condition|(
name|currentChar
operator|!=
name|EOF
condition|)
do|;
if|if
condition|(
name|state
operator|>
name|PARAMETER_START
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to parse header: "
operator|+
name|header
argument_list|)
throw|;
block|}
return|return
name|clauses
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|parseDelimitedString
parameter_list|(
name|String
name|value
parameter_list|,
name|String
name|delim
parameter_list|)
block|{
return|return
name|parseDelimitedString
argument_list|(
name|value
argument_list|,
name|delim
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Parses delimited string and returns an array containing the tokens. This      * parser obeys quotes, so the delimiter character will be ignored if it is      * inside of a quote. This method assumes that the quote character is not      * included in the set of delimiter characters.      *      * @param value the delimited string to parse.      * @param delim the characters delimiting the tokens.      * @return a list of string or an empty list if there are none.      */
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|parseDelimitedString
parameter_list|(
name|String
name|value
parameter_list|,
name|String
name|delim
parameter_list|,
name|boolean
name|trim
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|value
operator|=
literal|""
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|expecting
init|=
name|CHAR
operator||
name|DELIMITER
operator||
name|STARTQUOTE
decl_stmt|;
name|boolean
name|isEscaped
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|value
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|value
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|boolean
name|isDelimiter
init|=
name|delim
operator|.
name|indexOf
argument_list|(
name|c
argument_list|)
operator|>=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|isEscaped
operator|&&
name|c
operator|==
literal|'\\'
condition|)
block|{
name|isEscaped
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isEscaped
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDelimiter
operator|&&
operator|(
operator|(
name|expecting
operator|&
name|DELIMITER
operator|)
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|trim
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|delete
argument_list|(
literal|0
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|expecting
operator|=
name|CHAR
operator||
name|DELIMITER
operator||
name|STARTQUOTE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'"'
operator|)
operator|&&
operator|(
name|expecting
operator|&
name|STARTQUOTE
operator|)
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|expecting
operator|=
name|CHAR
operator||
name|ENDQUOTE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'"'
operator|)
operator|&&
operator|(
name|expecting
operator|&
name|ENDQUOTE
operator|)
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|expecting
operator|=
name|CHAR
operator||
name|STARTQUOTE
operator||
name|DELIMITER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|expecting
operator|&
name|CHAR
operator|)
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid delimited string: "
operator|+
name|value
argument_list|)
throw|;
block|}
name|isEscaped
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|trim
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
specifier|static
class|class
name|ParsedHeaderClause
block|{
specifier|public
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|paths
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|dirs
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|attrs
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|types
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
block|}
block|}
end_class

end_unit

