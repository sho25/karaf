begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *   * http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|util
operator|.
name|collections
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ConcurrentModificationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_comment
comment|/**  * Implements a {@link java.util.ArrayList} variant that is thread-safe. All  * write operation result in a new copy of the underlying data being created.  * Iterators reflect the state of the CopyOnWriteArrayIdentityList at the time they were  * created. They are not updated to reflect subsequent changes to the list. In  * addition, these iterators cannot be used for modifying the underlying  * CopyOnWriteArrayIdentityList.  *  * In addition, elements are compared based on reference equality instead of  * object equality when comparing values.  *  * @param<E> the element type  */
end_comment

begin_class
specifier|public
class|class
name|CopyOnWriteArrayIdentityList
parameter_list|<
name|E
parameter_list|>
implements|implements
name|List
argument_list|<
name|E
argument_list|>
implements|,
name|RandomAccess
implements|,
name|Cloneable
implements|,
name|Serializable
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|8673264195747942595L
decl_stmt|;
specifier|private
specifier|transient
specifier|volatile
name|E
index|[]
name|arr
decl_stmt|;
comment|/**      * Lock for the queue write methods      */
specifier|private
specifier|final
specifier|transient
name|ReentrantLock
name|lock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
comment|/**      * Creates a new, empty instance of CopyOnWriteArrayList.      */
specifier|public
name|CopyOnWriteArrayIdentityList
parameter_list|()
block|{     }
comment|/**      * Creates a new instance of CopyOnWriteArrayList and fills it with the      * contents of a given Collection.      *      * @param c     the collection the elements of which are to be copied into      *              the new instance.      */
specifier|public
name|CopyOnWriteArrayIdentityList
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
name|this
argument_list|(
operator|(
name|E
index|[]
operator|)
name|c
operator|.
name|toArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new instance of CopyOnWriteArrayList and fills it with the      * contents of a given array.      *      * @param array the array the elements of which are to be copied into the      *              new instance.      */
specifier|public
name|CopyOnWriteArrayIdentityList
parameter_list|(
name|E
index|[]
name|array
parameter_list|)
block|{
name|int
name|size
init|=
name|array
operator|.
name|length
decl_stmt|;
name|E
index|[]
name|data
init|=
name|newElementArray
argument_list|(
name|size
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
name|array
index|[
name|i
index|]
expr_stmt|;
block|}
name|arr
operator|=
name|data
expr_stmt|;
block|}
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|E
index|[]
name|data
decl_stmt|;
name|E
index|[]
name|old
init|=
name|getData
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|old
operator|.
name|length
decl_stmt|;
name|data
operator|=
name|newElementArray
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|old
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|data
index|[
name|size
index|]
operator|=
name|e
expr_stmt|;
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|add
parameter_list|(
name|int
name|index
parameter_list|,
name|E
name|e
parameter_list|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|E
index|[]
name|data
decl_stmt|;
name|E
index|[]
name|old
init|=
name|getData
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|old
operator|.
name|length
decl_stmt|;
name|checkIndexInclusive
argument_list|(
name|index
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|data
operator|=
name|newElementArray
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|old
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|data
index|[
name|index
index|]
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|index
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|old
argument_list|,
name|index
argument_list|,
name|data
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|size
operator|-
name|index
argument_list|)
expr_stmt|;
block|}
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
name|Iterator
name|it
init|=
name|c
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|ssize
init|=
name|c
operator|.
name|size
argument_list|()
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|size
init|=
name|size
argument_list|()
decl_stmt|;
name|E
index|[]
name|data
decl_stmt|;
name|E
index|[]
name|old
init|=
name|getData
argument_list|()
decl_stmt|;
name|int
name|nSize
init|=
name|size
operator|+
name|ssize
decl_stmt|;
name|data
operator|=
name|newElementArray
argument_list|(
name|nSize
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|old
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|data
index|[
name|size
operator|++
index|]
operator|=
operator|(
name|E
operator|)
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|addAll
parameter_list|(
name|int
name|index
parameter_list|,
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
name|Iterator
name|it
init|=
name|c
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|ssize
init|=
name|c
operator|.
name|size
argument_list|()
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|size
init|=
name|size
argument_list|()
decl_stmt|;
name|checkIndexInclusive
argument_list|(
name|index
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|E
index|[]
name|data
decl_stmt|;
name|E
index|[]
name|old
init|=
name|getData
argument_list|()
decl_stmt|;
name|int
name|nSize
init|=
name|size
operator|+
name|ssize
decl_stmt|;
name|data
operator|=
name|newElementArray
argument_list|(
name|nSize
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|old
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|int
name|i
init|=
name|index
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|data
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|E
operator|)
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
name|index
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|old
argument_list|,
name|index
argument_list|,
name|data
argument_list|,
name|index
operator|+
name|ssize
argument_list|,
name|size
operator|-
name|index
argument_list|)
expr_stmt|;
block|}
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Adds to this CopyOnWriteArrayList all those elements from a given      * collection that are not yet part of the list.      *      * @param c     the collection from which the potential new elements are      *              taken.      *      * @return the number of elements actually added to this list.      */
specifier|public
name|int
name|addAllAbsent
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|E
index|[]
name|old
init|=
name|getData
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|old
operator|.
name|length
decl_stmt|;
name|E
index|[]
name|toAdd
init|=
name|newElementArray
argument_list|(
name|c
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|E
name|o
range|:
name|c
control|)
block|{
if|if
condition|(
name|indexOf
argument_list|(
name|o
argument_list|)
operator|<
literal|0
condition|)
block|{
name|toAdd
index|[
name|i
operator|++
index|]
operator|=
name|o
expr_stmt|;
block|}
block|}
name|E
index|[]
name|data
init|=
name|newElementArray
argument_list|(
name|size
operator|+
name|i
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|old
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|toAdd
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Adds to this CopyOnWriteArrayList another element, given that this      * element is not yet part of the list.      *      * @param e     the potential new element.      *      * @return true if the element was added, or false otherwise.      */
specifier|public
name|boolean
name|addIfAbsent
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|E
index|[]
name|data
decl_stmt|;
name|E
index|[]
name|old
init|=
name|getData
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|old
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|indexOf
argument_list|(
name|e
argument_list|)
operator|>=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|data
operator|=
name|newElementArray
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|old
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|data
index|[
name|size
index|]
operator|=
name|e
expr_stmt|;
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|setData
argument_list|(
name|newElementArray
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Object
name|clone
parameter_list|()
block|{
try|try
block|{
name|CopyOnWriteArrayIdentityList
name|thisClone
init|=
operator|(
name|CopyOnWriteArrayIdentityList
operator|)
name|super
operator|.
name|clone
argument_list|()
decl_stmt|;
name|thisClone
operator|.
name|setData
argument_list|(
name|this
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|thisClone
return|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"CloneNotSupportedException is not expected here"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|indexOf
argument_list|(
name|o
argument_list|)
operator|>=
literal|0
return|;
block|}
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
name|E
index|[]
name|data
init|=
name|getData
argument_list|()
decl_stmt|;
return|return
name|containsAll
argument_list|(
name|c
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|List
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
name|l
init|=
operator|(
name|List
operator|)
name|o
decl_stmt|;
name|Iterator
name|it
init|=
name|l
operator|.
name|listIterator
argument_list|()
decl_stmt|;
name|Iterator
name|ourIt
init|=
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|ourIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Object
name|thisListElem
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|Object
name|anotherListElem
init|=
name|ourIt
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|thisListElem
operator|!=
name|anotherListElem
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
operator|!
name|ourIt
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|E
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|E
index|[]
name|data
init|=
name|getData
argument_list|()
decl_stmt|;
return|return
name|data
index|[
name|index
index|]
return|;
block|}
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|hashCode
init|=
literal|1
decl_stmt|;
for|for
control|(
name|Object
name|obj
range|:
name|this
control|)
block|{
name|hashCode
operator|=
literal|31
operator|*
name|hashCode
operator|+
operator|(
name|obj
operator|==
literal|null
condition|?
literal|0
else|:
name|obj
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
block|}
return|return
name|hashCode
return|;
block|}
comment|/**      * Returns the index of a given element, starting the search from a given      * position in the list.      *      * @param e     the element to search.      * @param index the index at which to start the search.      *      * @return the index of the element or null, if the element has not been      * found at or beyond the given start index.      */
specifier|public
name|int
name|indexOf
parameter_list|(
name|E
name|e
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|E
index|[]
name|data
init|=
name|getData
argument_list|()
decl_stmt|;
return|return
name|indexOf
argument_list|(
name|e
argument_list|,
name|data
argument_list|,
name|index
argument_list|,
name|data
operator|.
name|length
operator|-
name|index
argument_list|)
return|;
block|}
specifier|public
name|int
name|indexOf
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|E
index|[]
name|data
init|=
name|getData
argument_list|()
decl_stmt|;
return|return
name|indexOf
argument_list|(
name|o
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|ListIteratorImpl
argument_list|(
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**      * Returns the last index of a given element, starting the search from      * a given position in the list and going backwards.      *      * @param e     the element to search.      * @param index the index at which to start the search.      *      * @return the index of the element or null, if the element has not been      * found at or before the given start index.      */
specifier|public
name|int
name|lastIndexOf
parameter_list|(
name|E
name|e
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|E
index|[]
name|data
init|=
name|getData
argument_list|()
decl_stmt|;
return|return
name|lastIndexOf
argument_list|(
name|e
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|index
argument_list|)
return|;
block|}
specifier|public
name|int
name|lastIndexOf
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|E
index|[]
name|data
init|=
name|getData
argument_list|()
decl_stmt|;
return|return
name|lastIndexOf
argument_list|(
name|o
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|)
return|;
block|}
specifier|public
name|ListIterator
argument_list|<
name|E
argument_list|>
name|listIterator
parameter_list|()
block|{
return|return
operator|new
name|ListIteratorImpl
argument_list|(
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|public
name|ListIterator
argument_list|<
name|E
argument_list|>
name|listIterator
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|E
index|[]
name|data
init|=
name|getData
argument_list|()
decl_stmt|;
name|checkIndexInclusive
argument_list|(
name|index
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
operator|new
name|ListIteratorImpl
argument_list|(
name|data
argument_list|,
name|index
argument_list|)
return|;
block|}
specifier|public
name|E
name|remove
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|removeRange
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|index
init|=
name|indexOf
argument_list|(
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
name|remove
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|removeAll
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
name|getData
argument_list|()
operator|.
name|length
argument_list|)
operator|!=
literal|0
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|retainAll
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
name|getData
argument_list|()
operator|.
name|length
argument_list|)
operator|!=
literal|0
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|E
name|set
parameter_list|(
name|int
name|index
parameter_list|,
name|E
name|e
parameter_list|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|size
init|=
name|size
argument_list|()
decl_stmt|;
name|checkIndexExlusive
argument_list|(
name|index
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|E
index|[]
name|data
decl_stmt|;
name|data
operator|=
name|newElementArray
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|E
index|[]
name|oldArr
init|=
name|getData
argument_list|()
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|oldArr
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|E
name|old
init|=
name|data
index|[
name|index
index|]
decl_stmt|;
name|data
index|[
name|index
index|]
operator|=
name|e
expr_stmt|;
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|old
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|getData
argument_list|()
operator|.
name|length
return|;
block|}
specifier|public
name|List
argument_list|<
name|E
argument_list|>
name|subList
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
return|return
operator|new
name|SubList
argument_list|(
name|this
argument_list|,
name|fromIndex
argument_list|,
name|toIndex
argument_list|)
return|;
block|}
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
name|E
index|[]
name|data
init|=
name|getData
argument_list|()
decl_stmt|;
return|return
name|toArray
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|)
return|;
block|}
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|a
parameter_list|)
block|{
name|E
index|[]
name|data
init|=
name|getData
argument_list|()
decl_stmt|;
return|return
operator|(
name|T
index|[]
operator|)
name|toArray
argument_list|(
name|a
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"["
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|this
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// private and package private methods
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|final
name|E
index|[]
name|newElementArray
parameter_list|(
name|int
name|size
parameter_list|)
block|{
return|return
operator|(
name|E
index|[]
operator|)
operator|new
name|Object
index|[
name|size
index|]
return|;
block|}
comment|/**      * sets the internal data array      *      * @param data array to set      */
specifier|private
specifier|final
name|void
name|setData
parameter_list|(
name|E
index|[]
name|data
parameter_list|)
block|{
name|arr
operator|=
name|data
expr_stmt|;
block|}
comment|/**      * gets the internal data array (or a new array if it is null)      *      * @return the data array      */
specifier|final
name|E
index|[]
name|getData
parameter_list|()
block|{
if|if
condition|(
name|arr
operator|==
literal|null
condition|)
block|{
return|return
name|newElementArray
argument_list|(
literal|0
argument_list|)
return|;
block|}
return|return
name|arr
return|;
block|}
comment|/**      * Removes from the specified range of this list      * all the elements that are contained in the specified collection      *<p/>      * !should be called under lock      *      * @return Returns the number of removed elements      */
specifier|final
name|int
name|removeAll
parameter_list|(
name|Collection
name|c
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|ssize
init|=
name|c
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|ssize
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|Object
index|[]
name|old
init|=
name|getData
argument_list|()
decl_stmt|;
name|int
name|arrsize
init|=
name|old
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|arrsize
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|Object
index|[]
name|data
init|=
operator|new
name|Object
index|[
name|size
index|]
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
operator|(
name|start
operator|+
name|size
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|c
operator|.
name|contains
argument_list|(
name|old
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|data
index|[
name|j
operator|++
index|]
operator|=
name|old
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
operator|!=
name|size
condition|)
block|{
name|E
index|[]
name|result
init|=
name|newElementArray
argument_list|(
name|arrsize
operator|-
operator|(
name|size
operator|-
name|j
operator|)
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|old
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
name|start
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|old
argument_list|,
name|start
operator|+
name|size
argument_list|,
name|result
argument_list|,
name|start
operator|+
name|j
argument_list|,
name|arrsize
operator|-
operator|(
name|start
operator|+
name|size
operator|)
argument_list|)
expr_stmt|;
name|setData
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|-
name|j
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/**      * Retains only the elements in the specified range of this list      * that are contained in the specified collection      *      * @return Returns the number of removed elements      */
comment|// should be called under lock
name|int
name|retainAll
parameter_list|(
name|Collection
name|c
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|Object
index|[]
name|old
init|=
name|getData
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|c
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|E
index|[]
name|data
decl_stmt|;
if|if
condition|(
name|size
operator|==
name|old
operator|.
name|length
condition|)
block|{
name|data
operator|=
name|newElementArray
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
name|newElementArray
argument_list|(
name|old
operator|.
name|length
operator|-
name|size
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|old
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|old
argument_list|,
name|start
operator|+
name|size
argument_list|,
name|data
argument_list|,
name|start
argument_list|,
name|old
operator|.
name|length
operator|-
name|start
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
name|Object
index|[]
name|temp
init|=
operator|new
name|Object
index|[
name|size
index|]
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
operator|(
name|start
operator|+
name|size
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|.
name|contains
argument_list|(
name|old
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|temp
index|[
name|pos
operator|++
index|]
operator|=
name|old
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pos
operator|==
name|size
condition|)
block|{
return|return
literal|0
return|;
block|}
name|E
index|[]
name|data
init|=
name|newElementArray
argument_list|(
name|pos
operator|+
name|old
operator|.
name|length
operator|-
name|size
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|old
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
name|start
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|old
argument_list|,
name|start
operator|+
name|size
argument_list|,
name|data
argument_list|,
name|start
operator|+
name|pos
argument_list|,
name|old
operator|.
name|length
operator|-
name|start
operator|-
name|size
argument_list|)
expr_stmt|;
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|-
name|pos
operator|)
return|;
block|}
comment|/**      * Removes specified range from this list      */
name|E
name|removeRange
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|sizeArr
init|=
name|size
argument_list|()
decl_stmt|;
name|checkIndexExlusive
argument_list|(
name|start
argument_list|,
name|sizeArr
argument_list|)
expr_stmt|;
name|checkIndexInclusive
argument_list|(
name|start
operator|+
name|size
argument_list|,
name|sizeArr
argument_list|)
expr_stmt|;
name|E
index|[]
name|data
decl_stmt|;
name|data
operator|=
name|newElementArray
argument_list|(
name|sizeArr
operator|-
name|size
argument_list|)
expr_stmt|;
name|E
index|[]
name|oldArr
init|=
name|getData
argument_list|()
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|oldArr
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|E
name|old
init|=
name|oldArr
index|[
name|start
index|]
decl_stmt|;
if|if
condition|(
name|sizeArr
operator|>
operator|(
name|start
operator|+
name|size
operator|)
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|oldArr
argument_list|,
name|start
operator|+
name|size
argument_list|,
name|data
argument_list|,
name|start
argument_list|,
name|sizeArr
operator|-
operator|(
name|start
operator|+
name|size
operator|)
argument_list|)
expr_stmt|;
block|}
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|old
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// some util static functions to use by iterators and methods
comment|/**      * Returns an array containing all of the elements      * in the specified range of the array in proper sequence      */
specifier|static
name|Object
index|[]
name|toArray
parameter_list|(
name|Object
index|[]
name|data
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|Object
index|[]
name|result
init|=
operator|new
name|Object
index|[
name|size
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
name|start
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**      * Returns an array containing all of the elements      * in the specified range of the array in proper sequence,      * stores the result in the array, specified by first parameter      * (as for public instance method toArray(Object[] to)      */
specifier|static
name|Object
index|[]
name|toArray
parameter_list|(
name|Object
index|[]
name|to
parameter_list|,
name|Object
index|[]
name|data
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|l
init|=
name|data
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|to
operator|.
name|length
operator|<
name|l
condition|)
block|{
name|to
operator|=
operator|(
name|Object
index|[]
operator|)
name|Array
operator|.
name|newInstance
argument_list|(
name|to
operator|.
name|getClass
argument_list|()
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|to
operator|.
name|length
operator|>
name|l
condition|)
block|{
name|to
index|[
name|l
index|]
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
name|start
argument_list|,
name|to
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|to
return|;
block|}
comment|/**      * Checks if the specified range of the      * array contains all of the elements in the collection      *      * @param c     collection with elements      * @param data  array where to search the elements      * @param start start index      * @param size  size of the range      */
specifier|static
specifier|final
name|boolean
name|containsAll
parameter_list|(
name|Collection
name|c
parameter_list|,
name|Object
index|[]
name|data
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|Object
name|next
range|:
name|c
control|)
block|{
if|if
condition|(
name|indexOf
argument_list|(
name|next
argument_list|,
name|data
argument_list|,
name|start
argument_list|,
name|size
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Returns the index in the specified range of the data array      * of the last occurrence of the specified element      *      * @param o     element to search      * @param data  array where to search      * @param start start index      * @param size  size of the range      * @return      */
specifier|static
specifier|final
name|int
name|lastIndexOf
parameter_list|(
name|Object
name|o
parameter_list|,
name|Object
index|[]
name|data
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|int
name|i
init|=
name|start
operator|+
name|size
operator|-
literal|1
init|;
name|i
operator|>
name|start
operator|-
literal|1
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|==
name|o
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**      * Returns the index in the specified range of the data array      * of the first occurrence of the specified element      *      * @param o     element to search      * @param data  array where to search      * @param start start index      * @param size  end index      * @return      */
specifier|static
specifier|final
name|int
name|indexOf
parameter_list|(
name|Object
name|o
parameter_list|,
name|Object
index|[]
name|data
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|start
operator|+
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|==
name|o
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**      * Throws<code>IndexOutOfBoundsException</code> if<code>index</code>      * is out of the list bounds.      *      * @param index element index to check.      */
specifier|static
specifier|final
name|void
name|checkIndexInclusive
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|index
argument_list|<
literal|0
operator|||
name|index
argument_list|>
name|size
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"Index is "
operator|+
name|index
operator|+
literal|", size is "
operator|+
name|size
argument_list|)
throw|;
block|}
block|}
comment|/**      * Throws<code>IndexOutOfBoundsException</code> if<code>index</code>      * is out of the list bounds. Excluding the last element.      *      * @param index element index to check.      */
specifier|static
specifier|final
name|void
name|checkIndexExlusive
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|size
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"Index is "
operator|+
name|index
operator|+
literal|", size is "
operator|+
name|size
argument_list|)
throw|;
block|}
block|}
comment|/**      * gets the internal data array      *      * @return the data array      */
specifier|final
name|E
index|[]
name|getArray
parameter_list|()
block|{
return|return
name|arr
return|;
block|}
comment|/**      * list iterator implementation,      * when created gets snapshot of the list,      * so never throws ConcurrentModificationException      */
specifier|private
specifier|static
class|class
name|ListIteratorImpl
implements|implements
name|ListIterator
block|{
specifier|private
specifier|final
name|Object
index|[]
name|arr
decl_stmt|;
specifier|private
name|int
name|current
decl_stmt|;
specifier|private
specifier|final
name|int
name|size
decl_stmt|;
specifier|final
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
specifier|public
name|ListIteratorImpl
parameter_list|(
name|Object
index|[]
name|data
parameter_list|,
name|int
name|current
parameter_list|)
block|{
name|this
operator|.
name|current
operator|=
name|current
expr_stmt|;
name|arr
operator|=
name|data
expr_stmt|;
name|size
operator|=
name|data
operator|.
name|length
expr_stmt|;
block|}
specifier|public
name|void
name|add
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unsupported operation add"
argument_list|)
throw|;
block|}
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|current
operator|<
name|size
return|;
block|}
specifier|public
name|boolean
name|hasPrevious
parameter_list|()
block|{
return|return
name|current
operator|>
literal|0
return|;
block|}
specifier|public
name|Object
name|next
parameter_list|()
block|{
if|if
condition|(
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|arr
index|[
name|current
operator|++
index|]
return|;
block|}
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
literal|"pos is "
operator|+
name|current
operator|+
literal|", size is "
operator|+
name|size
argument_list|)
throw|;
block|}
specifier|public
name|int
name|nextIndex
parameter_list|()
block|{
return|return
name|current
return|;
block|}
specifier|public
name|Object
name|previous
parameter_list|()
block|{
if|if
condition|(
name|hasPrevious
argument_list|()
condition|)
block|{
return|return
name|arr
index|[
operator|--
name|current
index|]
return|;
block|}
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
literal|"pos is "
operator|+
operator|(
name|current
operator|-
literal|1
operator|)
operator|+
literal|", size is "
operator|+
name|size
argument_list|)
throw|;
block|}
specifier|public
name|int
name|previousIndex
parameter_list|()
block|{
return|return
name|current
operator|-
literal|1
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unsupported operation remove"
argument_list|)
throw|;
block|}
specifier|public
name|void
name|set
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unsupported operation set"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Keeps a state of sublist implementation,      * size and array declared as final,      * so we'll never get the unconsistent state      */
specifier|static
specifier|final
class|class
name|SubListReadData
block|{
specifier|final
name|int
name|size
decl_stmt|;
specifier|final
name|Object
index|[]
name|data
decl_stmt|;
name|SubListReadData
parameter_list|(
name|int
name|size
parameter_list|,
name|Object
index|[]
name|data
parameter_list|)
block|{
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|this
operator|.
name|data
operator|=
name|data
expr_stmt|;
block|}
block|}
comment|/**      * Represents a list returned by<code>sublist()</code>.      */
specifier|static
class|class
name|SubList
implements|implements
name|List
block|{
specifier|private
specifier|final
name|CopyOnWriteArrayIdentityList
name|list
decl_stmt|;
specifier|private
specifier|volatile
name|SubListReadData
name|read
decl_stmt|;
specifier|private
specifier|final
name|int
name|start
decl_stmt|;
comment|/**          * Sublist constructor.          *          * @param list    backing list.          * @param fromIdx startingIndex, inclusive          * @param toIdx   endIndex, exclusive          */
specifier|public
name|SubList
parameter_list|(
name|CopyOnWriteArrayIdentityList
name|list
parameter_list|,
name|int
name|fromIdx
parameter_list|,
name|int
name|toIdx
parameter_list|)
block|{
name|this
operator|.
name|list
operator|=
name|list
expr_stmt|;
name|Object
index|[]
name|data
init|=
name|list
operator|.
name|getData
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|toIdx
operator|-
name|fromIdx
decl_stmt|;
name|checkIndexExlusive
argument_list|(
name|fromIdx
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|checkIndexInclusive
argument_list|(
name|toIdx
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|read
operator|=
operator|new
name|SubListReadData
argument_list|(
name|size
argument_list|,
name|list
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
name|start
operator|=
name|fromIdx
expr_stmt|;
block|}
comment|/**          * throws ConcurrentModificationException when the list          * is structurally modified in the other way other than via this subList          *<p/>          * Should be called under lock!          */
specifier|private
name|void
name|checkModifications
parameter_list|()
block|{
if|if
condition|(
name|read
operator|.
name|data
operator|!=
name|list
operator|.
name|getData
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
block|}
block|}
comment|/**          * @see java.util.List#listIterator(int)          */
specifier|public
name|ListIterator
name|listIterator
parameter_list|(
name|int
name|startIdx
parameter_list|)
block|{
return|return
operator|new
name|SubListIterator
argument_list|(
name|startIdx
argument_list|,
name|read
argument_list|)
return|;
block|}
comment|/**          * @see java.util.List#set(int, java.lang.Object)          */
specifier|public
name|Object
name|set
parameter_list|(
name|int
name|index
parameter_list|,
name|Object
name|obj
parameter_list|)
block|{
name|list
operator|.
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkIndexExlusive
argument_list|(
name|index
argument_list|,
name|read
operator|.
name|size
argument_list|)
expr_stmt|;
name|checkModifications
argument_list|()
expr_stmt|;
name|Object
name|result
init|=
name|list
operator|.
name|set
argument_list|(
name|index
operator|+
name|start
argument_list|,
name|obj
argument_list|)
decl_stmt|;
name|read
operator|=
operator|new
name|SubListReadData
argument_list|(
name|read
operator|.
name|size
argument_list|,
name|list
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
finally|finally
block|{
name|list
operator|.
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**          * @see java.util.List#get(int)          */
specifier|public
name|Object
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|SubListReadData
name|data
init|=
name|read
decl_stmt|;
if|if
condition|(
name|data
operator|.
name|data
operator|!=
name|list
operator|.
name|getData
argument_list|()
condition|)
block|{
name|list
operator|.
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|data
operator|=
name|read
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|data
operator|!=
name|list
operator|.
name|getData
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
block|}
block|}
finally|finally
block|{
name|list
operator|.
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
name|checkIndexExlusive
argument_list|(
name|index
argument_list|,
name|data
operator|.
name|size
argument_list|)
expr_stmt|;
return|return
name|data
operator|.
name|data
index|[
name|index
operator|+
name|start
index|]
return|;
block|}
comment|/**          * @see java.util.Collection#size()          */
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|read
operator|.
name|size
return|;
block|}
comment|/**          * @see java.util.List#remove(int)          */
specifier|public
name|Object
name|remove
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|list
operator|.
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkIndexExlusive
argument_list|(
name|index
argument_list|,
name|read
operator|.
name|size
argument_list|)
expr_stmt|;
name|checkModifications
argument_list|()
expr_stmt|;
name|Object
name|obj
init|=
name|list
operator|.
name|remove
argument_list|(
name|index
operator|+
name|start
argument_list|)
decl_stmt|;
name|read
operator|=
operator|new
name|SubListReadData
argument_list|(
name|read
operator|.
name|size
operator|-
literal|1
argument_list|,
name|list
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|obj
return|;
block|}
finally|finally
block|{
name|list
operator|.
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**          * @see java.util.List#add(int, java.lang.Object)          */
specifier|public
name|void
name|add
parameter_list|(
name|int
name|index
parameter_list|,
name|Object
name|object
parameter_list|)
block|{
name|list
operator|.
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkIndexInclusive
argument_list|(
name|index
argument_list|,
name|read
operator|.
name|size
argument_list|)
expr_stmt|;
name|checkModifications
argument_list|()
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|index
operator|+
name|start
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|read
operator|=
operator|new
name|SubListReadData
argument_list|(
name|read
operator|.
name|size
operator|+
literal|1
argument_list|,
name|list
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|list
operator|.
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|add
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|list
operator|.
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkModifications
argument_list|()
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|start
operator|+
name|read
operator|.
name|size
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|read
operator|=
operator|new
name|SubListReadData
argument_list|(
name|read
operator|.
name|size
operator|+
literal|1
argument_list|,
name|list
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|list
operator|.
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
name|c
parameter_list|)
block|{
name|list
operator|.
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkModifications
argument_list|()
expr_stmt|;
name|int
name|d
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
name|list
operator|.
name|addAll
argument_list|(
name|start
operator|+
name|read
operator|.
name|size
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|read
operator|=
operator|new
name|SubListReadData
argument_list|(
name|read
operator|.
name|size
operator|+
operator|(
name|list
operator|.
name|size
argument_list|()
operator|-
name|d
operator|)
argument_list|,
name|list
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|list
operator|.
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|list
operator|.
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkModifications
argument_list|()
expr_stmt|;
name|list
operator|.
name|removeRange
argument_list|(
name|start
argument_list|,
name|read
operator|.
name|size
argument_list|)
expr_stmt|;
name|read
operator|=
operator|new
name|SubListReadData
argument_list|(
literal|0
argument_list|,
name|list
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|list
operator|.
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|indexOf
argument_list|(
name|o
argument_list|)
operator|!=
operator|-
literal|1
return|;
block|}
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
name|c
parameter_list|)
block|{
name|SubListReadData
name|b
init|=
name|read
decl_stmt|;
return|return
name|CopyOnWriteArrayIdentityList
operator|.
name|containsAll
argument_list|(
name|c
argument_list|,
name|b
operator|.
name|data
argument_list|,
name|start
argument_list|,
name|b
operator|.
name|size
argument_list|)
return|;
block|}
specifier|public
name|int
name|indexOf
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|SubListReadData
name|b
init|=
name|read
decl_stmt|;
name|int
name|ind
init|=
name|CopyOnWriteArrayIdentityList
operator|.
name|indexOf
argument_list|(
name|o
argument_list|,
name|b
operator|.
name|data
argument_list|,
name|start
argument_list|,
name|b
operator|.
name|size
argument_list|)
operator|-
name|start
decl_stmt|;
return|return
name|ind
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
name|ind
return|;
block|}
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|read
operator|.
name|size
operator|==
literal|0
return|;
block|}
specifier|public
name|Iterator
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|SubListIterator
argument_list|(
literal|0
argument_list|,
name|read
argument_list|)
return|;
block|}
specifier|public
name|int
name|lastIndexOf
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|SubListReadData
name|b
init|=
name|read
decl_stmt|;
name|int
name|ind
init|=
name|CopyOnWriteArrayIdentityList
operator|.
name|lastIndexOf
argument_list|(
name|o
argument_list|,
name|b
operator|.
name|data
argument_list|,
name|start
argument_list|,
name|b
operator|.
name|size
argument_list|)
operator|-
name|start
decl_stmt|;
return|return
name|ind
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
name|ind
return|;
block|}
specifier|public
name|ListIterator
name|listIterator
parameter_list|()
block|{
return|return
operator|new
name|SubListIterator
argument_list|(
literal|0
argument_list|,
name|read
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|list
operator|.
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkModifications
argument_list|()
expr_stmt|;
name|int
name|i
init|=
name|indexOf
argument_list|(
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|result
init|=
name|list
operator|.
name|remove
argument_list|(
name|i
operator|+
name|start
argument_list|)
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|read
operator|=
operator|new
name|SubListReadData
argument_list|(
name|read
operator|.
name|size
operator|-
literal|1
argument_list|,
name|list
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
finally|finally
block|{
name|list
operator|.
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
name|c
parameter_list|)
block|{
name|list
operator|.
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkModifications
argument_list|()
expr_stmt|;
name|int
name|removed
init|=
name|list
operator|.
name|removeAll
argument_list|(
name|c
argument_list|,
name|start
argument_list|,
name|read
operator|.
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|removed
operator|>
literal|0
condition|)
block|{
name|read
operator|=
operator|new
name|SubListReadData
argument_list|(
name|read
operator|.
name|size
operator|-
name|removed
argument_list|,
name|list
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
finally|finally
block|{
name|list
operator|.
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
name|c
parameter_list|)
block|{
name|list
operator|.
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkModifications
argument_list|()
expr_stmt|;
name|int
name|removed
init|=
name|list
operator|.
name|retainAll
argument_list|(
name|c
argument_list|,
name|start
argument_list|,
name|read
operator|.
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|removed
operator|>
literal|0
condition|)
block|{
name|read
operator|=
operator|new
name|SubListReadData
argument_list|(
name|read
operator|.
name|size
operator|-
name|removed
argument_list|,
name|list
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|list
operator|.
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|List
name|subList
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
return|return
operator|new
name|SubList
argument_list|(
name|list
argument_list|,
name|start
operator|+
name|fromIndex
argument_list|,
name|start
operator|+
name|toIndex
argument_list|)
return|;
block|}
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
name|SubListReadData
name|r
init|=
name|read
decl_stmt|;
return|return
name|CopyOnWriteArrayIdentityList
operator|.
name|toArray
argument_list|(
name|r
operator|.
name|data
argument_list|,
name|start
argument_list|,
name|r
operator|.
name|size
argument_list|)
return|;
block|}
specifier|public
name|Object
index|[]
name|toArray
parameter_list|(
name|Object
index|[]
name|a
parameter_list|)
block|{
name|SubListReadData
name|r
init|=
name|read
decl_stmt|;
return|return
name|CopyOnWriteArrayIdentityList
operator|.
name|toArray
argument_list|(
name|a
argument_list|,
name|r
operator|.
name|data
argument_list|,
name|start
argument_list|,
name|r
operator|.
name|size
argument_list|)
return|;
block|}
comment|/**          * @see java.util.List#addAll(int, java.util.Collection)          */
specifier|public
name|boolean
name|addAll
parameter_list|(
name|int
name|index
parameter_list|,
name|Collection
name|collection
parameter_list|)
block|{
name|list
operator|.
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkIndexInclusive
argument_list|(
name|index
argument_list|,
name|read
operator|.
name|size
argument_list|)
expr_stmt|;
name|checkModifications
argument_list|()
expr_stmt|;
name|int
name|d
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
name|boolean
name|rt
init|=
name|list
operator|.
name|addAll
argument_list|(
name|index
operator|+
name|start
argument_list|,
name|collection
argument_list|)
decl_stmt|;
name|read
operator|=
operator|new
name|SubListReadData
argument_list|(
name|read
operator|.
name|size
operator|+
name|list
operator|.
name|size
argument_list|()
operator|-
name|d
argument_list|,
name|list
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rt
return|;
block|}
finally|finally
block|{
name|list
operator|.
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**          * Implementation of<code>ListIterator</code> for the          *<code>SubList</code>          * gets a snapshot of the sublist,          * never throws ConcurrentModificationException          */
specifier|private
class|class
name|SubListIterator
extends|extends
name|ListIteratorImpl
block|{
specifier|private
specifier|final
name|SubListReadData
name|dataR
decl_stmt|;
comment|/**              * Constructs an iterator starting with the given index              *              * @param index index of the first element to iterate.              */
specifier|private
name|SubListIterator
parameter_list|(
name|int
name|index
parameter_list|,
name|SubListReadData
name|d
parameter_list|)
block|{
name|super
argument_list|(
name|d
operator|.
name|data
argument_list|,
name|index
operator|+
name|start
argument_list|)
expr_stmt|;
name|this
operator|.
name|dataR
operator|=
name|d
expr_stmt|;
block|}
comment|/**              * @see java.util.ListIterator#nextIndex()              */
specifier|public
name|int
name|nextIndex
parameter_list|()
block|{
return|return
name|super
operator|.
name|nextIndex
argument_list|()
operator|-
name|start
return|;
block|}
comment|/**              * @see java.util.ListIterator#previousIndex()              */
specifier|public
name|int
name|previousIndex
parameter_list|()
block|{
return|return
name|super
operator|.
name|previousIndex
argument_list|()
operator|-
name|start
return|;
block|}
comment|/**              * @see java.util.Iterator#hasNext()              */
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|nextIndex
argument_list|()
operator|<
name|dataR
operator|.
name|size
return|;
block|}
comment|/**              * @see java.util.ListIterator#hasPrevious()              */
specifier|public
name|boolean
name|hasPrevious
parameter_list|()
block|{
return|return
name|previousIndex
argument_list|()
operator|>
operator|-
literal|1
return|;
block|}
block|}
block|}
comment|//serialization support
comment|/**      * Writes the object state to the ObjectOutputStream.      *      * @param oos ObjectOutputStream to write object to.      * @throws IOException if an I/O error occur.      */
specifier|private
name|void
name|writeObject
parameter_list|(
name|ObjectOutputStream
name|oos
parameter_list|)
throws|throws
name|IOException
block|{
name|E
index|[]
name|back
init|=
name|getData
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|back
operator|.
name|length
decl_stmt|;
name|oos
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
name|oos
operator|.
name|writeInt
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|E
name|aBack
range|:
name|back
control|)
block|{
name|oos
operator|.
name|writeObject
argument_list|(
name|aBack
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Reads the object state from the ObjectOutputStream.      *      * @param ois ObjectInputStream to read object from.      * @throws IOException if an I/O error occur.      * @throws ClassNotFoundException If the object class is not found.      */
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|ois
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|ois
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
name|int
name|length
init|=
name|ois
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|setData
argument_list|(
name|newElementArray
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|E
index|[]
name|back
init|=
name|newElementArray
argument_list|(
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|back
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|back
index|[
name|i
index|]
operator|=
operator|(
name|E
operator|)
name|ois
operator|.
name|readObject
argument_list|()
expr_stmt|;
block|}
name|setData
argument_list|(
name|back
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

