begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing,  *  software distributed under the License is distributed on an  *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *  KIND, either express or implied.  See the License for the  *  specific language governing permissions and limitations  *  under the License.  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|util
operator|.
name|base64
package|;
end_package

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|InvalidParameterException
import|;
end_import

begin_comment
comment|/**  * Provides Base64 encoding and decoding as defined by RFC 2045.  *  *<p>This class implements section<cite>6.8. Base64 Content-Transfer-Encoding</cite>   * from RFC 2045<cite>Multipurpose Internet Mail Extensions (MIME) Part One:   * Format of Internet Message Bodies</cite> by Freed and Borenstein.</p>   *  * @see<a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>  *  *  This class was   * @author Apache Software Foundation commons codec (http://commons.apache.org/codec/)  * @author<a href="http://mina.apache.org">Apache MINA Project</a>  */
end_comment

begin_class
specifier|public
class|class
name|Base64
block|{
comment|/**      * Chunk size per RFC 2045 section 6.8.      *      *<p>The {@value} character limit does not count the trailing CRLF, but counts       * all other characters, including any equal signs.</p>      *      * @see<a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045 section 6.8</a>      */
specifier|static
specifier|final
name|int
name|CHUNK_SIZE
init|=
literal|76
decl_stmt|;
comment|/**      * Chunk separator per RFC 2045 section 2.1.      *      * @see<a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045 section 2.1</a>      */
specifier|static
specifier|final
name|byte
index|[]
name|CHUNK_SEPARATOR
init|=
literal|"\r\n"
operator|.
name|getBytes
argument_list|()
decl_stmt|;
comment|/**      * The base length.      */
specifier|static
specifier|final
name|int
name|BASELENGTH
init|=
literal|255
decl_stmt|;
comment|/**      * Lookup length.      */
specifier|static
specifier|final
name|int
name|LOOKUPLENGTH
init|=
literal|64
decl_stmt|;
comment|/**      * Used to calculate the number of bits in a byte.      */
specifier|static
specifier|final
name|int
name|EIGHTBIT
init|=
literal|8
decl_stmt|;
comment|/**      * Used when encoding something which has fewer than 24 bits.      */
specifier|static
specifier|final
name|int
name|SIXTEENBIT
init|=
literal|16
decl_stmt|;
comment|/**      * Used to determine how many bits data contains.      */
specifier|static
specifier|final
name|int
name|TWENTYFOURBITGROUP
init|=
literal|24
decl_stmt|;
comment|/**      * Used to get the number of Quadruples.      */
specifier|static
specifier|final
name|int
name|FOURBYTE
init|=
literal|4
decl_stmt|;
comment|/**      * Used to test the sign of a byte.      */
specifier|static
specifier|final
name|int
name|SIGN
init|=
operator|-
literal|128
decl_stmt|;
comment|/**      * Byte used to pad output.      */
specifier|static
specifier|final
name|byte
name|PAD
init|=
operator|(
name|byte
operator|)
literal|'='
decl_stmt|;
comment|// Create arrays to hold the base64 characters and a
comment|// lookup for base64 chars
specifier|private
specifier|static
name|byte
index|[]
name|base64Alphabet
init|=
operator|new
name|byte
index|[
name|BASELENGTH
index|]
decl_stmt|;
specifier|private
specifier|static
name|byte
index|[]
name|lookUpBase64Alphabet
init|=
operator|new
name|byte
index|[
name|LOOKUPLENGTH
index|]
decl_stmt|;
comment|// Populating the lookup and character arrays
static|static
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BASELENGTH
condition|;
name|i
operator|++
control|)
block|{
name|base64Alphabet
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|'Z'
init|;
name|i
operator|>=
literal|'A'
condition|;
name|i
operator|--
control|)
block|{
name|base64Alphabet
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|i
operator|-
literal|'A'
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|'z'
init|;
name|i
operator|>=
literal|'a'
condition|;
name|i
operator|--
control|)
block|{
name|base64Alphabet
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|i
operator|-
literal|'a'
operator|+
literal|26
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|'9'
init|;
name|i
operator|>=
literal|'0'
condition|;
name|i
operator|--
control|)
block|{
name|base64Alphabet
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|i
operator|-
literal|'0'
operator|+
literal|52
argument_list|)
expr_stmt|;
block|}
name|base64Alphabet
index|[
literal|'+'
index|]
operator|=
literal|62
expr_stmt|;
name|base64Alphabet
index|[
literal|'/'
index|]
operator|=
literal|63
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
literal|25
condition|;
name|i
operator|++
control|)
block|{
name|lookUpBase64Alphabet
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|'A'
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|26
init|,
name|j
init|=
literal|0
init|;
name|i
operator|<=
literal|51
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|lookUpBase64Alphabet
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|'a'
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|52
init|,
name|j
init|=
literal|0
init|;
name|i
operator|<=
literal|61
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|lookUpBase64Alphabet
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|'0'
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
name|lookUpBase64Alphabet
index|[
literal|62
index|]
operator|=
operator|(
name|byte
operator|)
literal|'+'
expr_stmt|;
name|lookUpBase64Alphabet
index|[
literal|63
index|]
operator|=
operator|(
name|byte
operator|)
literal|'/'
expr_stmt|;
block|}
specifier|private
specifier|static
name|boolean
name|isBase64
parameter_list|(
name|byte
name|octect
parameter_list|)
block|{
if|if
condition|(
name|octect
operator|==
name|PAD
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|base64Alphabet
index|[
name|octect
index|]
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**      * Tests a given byte array to see if it contains      * only valid characters within the Base64 alphabet.      *      * @param arrayOctect byte array to test      * @return true if all bytes are valid characters in the Base64      *         alphabet or if the byte array is empty; false, otherwise      */
specifier|public
specifier|static
name|boolean
name|isArrayByteBase64
parameter_list|(
name|byte
index|[]
name|arrayOctect
parameter_list|)
block|{
name|arrayOctect
operator|=
name|discardWhitespace
argument_list|(
name|arrayOctect
argument_list|)
expr_stmt|;
name|int
name|length
init|=
name|arrayOctect
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
comment|// shouldn't a 0 length array be valid base64 data?
return|return
literal|true
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isBase64
argument_list|(
name|arrayOctect
index|[
name|i
index|]
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Encodes binary data using the base64 algorithm but      * does not chunk the output.      *      * @param binaryData binary data to encode      * @return Base64 characters      */
specifier|public
specifier|static
name|byte
index|[]
name|encodeBase64
parameter_list|(
name|byte
index|[]
name|binaryData
parameter_list|)
block|{
return|return
name|encodeBase64
argument_list|(
name|binaryData
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Encodes binary data using the base64 algorithm and chunks      * the encoded output into 76 character blocks      *      * @param binaryData binary data to encode      * @return Base64 characters chunked in 76 character blocks      */
specifier|public
specifier|static
name|byte
index|[]
name|encodeBase64Chunked
parameter_list|(
name|byte
index|[]
name|binaryData
parameter_list|)
block|{
return|return
name|encodeBase64
argument_list|(
name|binaryData
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Decodes an Object using the base64 algorithm.  This method      * is provided in order to satisfy the requirements of the      * Decoder interface, and will throw a DecoderException if the      * supplied object is not of type byte[].      *      * @param pObject Object to decode      * @return An object (of type byte[]) containing the       *         binary data which corresponds to the byte[] supplied.      * @throws InvalidParameterException if the parameter supplied is not      *                          of type byte[]      */
specifier|public
name|Object
name|decode
parameter_list|(
name|Object
name|pObject
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|pObject
operator|instanceof
name|byte
index|[]
operator|)
condition|)
block|{
throw|throw
operator|new
name|InvalidParameterException
argument_list|(
literal|"Parameter supplied to Base64 decode is not a byte[]"
argument_list|)
throw|;
block|}
return|return
name|decode
argument_list|(
operator|(
name|byte
index|[]
operator|)
name|pObject
argument_list|)
return|;
block|}
comment|/**      * Decodes a byte[] containing containing      * characters in the Base64 alphabet.      *      * @param pArray A byte array containing Base64 character data      * @return a byte array containing binary data      */
specifier|public
name|byte
index|[]
name|decode
parameter_list|(
name|byte
index|[]
name|pArray
parameter_list|)
block|{
return|return
name|decodeBase64
argument_list|(
name|pArray
argument_list|)
return|;
block|}
comment|/**      * Encodes binary data using the base64 algorithm, optionally      * chunking the output into 76 character blocks.      *      * @param binaryData Array containing binary data to encode.      * @param isChunked if isChunked is true this encoder will chunk      *                  the base64 output into 76 character blocks      * @return Base64-encoded data.      */
specifier|public
specifier|static
name|byte
index|[]
name|encodeBase64
parameter_list|(
name|byte
index|[]
name|binaryData
parameter_list|,
name|boolean
name|isChunked
parameter_list|)
block|{
name|int
name|lengthDataBits
init|=
name|binaryData
operator|.
name|length
operator|*
name|EIGHTBIT
decl_stmt|;
name|int
name|fewerThan24bits
init|=
name|lengthDataBits
operator|%
name|TWENTYFOURBITGROUP
decl_stmt|;
name|int
name|numberTriplets
init|=
name|lengthDataBits
operator|/
name|TWENTYFOURBITGROUP
decl_stmt|;
name|byte
name|encodedData
index|[]
init|=
literal|null
decl_stmt|;
name|int
name|encodedDataLength
init|=
literal|0
decl_stmt|;
name|int
name|nbrChunks
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fewerThan24bits
operator|!=
literal|0
condition|)
block|{
comment|//data not divisible by 24 bit
name|encodedDataLength
operator|=
operator|(
name|numberTriplets
operator|+
literal|1
operator|)
operator|*
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|// 16 or 8 bit
name|encodedDataLength
operator|=
name|numberTriplets
operator|*
literal|4
expr_stmt|;
block|}
comment|// If the output is to be "chunked" into 76 character sections,
comment|// for compliance with RFC 2045 MIME, then it is important to
comment|// allow for extra length to account for the separator(s)
if|if
condition|(
name|isChunked
condition|)
block|{
name|nbrChunks
operator|=
operator|(
name|CHUNK_SEPARATOR
operator|.
name|length
operator|==
literal|0
condition|?
literal|0
else|:
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|float
operator|)
name|encodedDataLength
operator|/
name|CHUNK_SIZE
argument_list|)
operator|)
expr_stmt|;
name|encodedDataLength
operator|+=
name|nbrChunks
operator|*
name|CHUNK_SEPARATOR
operator|.
name|length
expr_stmt|;
block|}
name|encodedData
operator|=
operator|new
name|byte
index|[
name|encodedDataLength
index|]
expr_stmt|;
name|byte
name|k
init|=
literal|0
decl_stmt|,
name|l
init|=
literal|0
decl_stmt|,
name|b1
init|=
literal|0
decl_stmt|,
name|b2
init|=
literal|0
decl_stmt|,
name|b3
init|=
literal|0
decl_stmt|;
name|int
name|encodedIndex
init|=
literal|0
decl_stmt|;
name|int
name|dataIndex
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|nextSeparatorIndex
init|=
name|CHUNK_SIZE
decl_stmt|;
name|int
name|chunksSoFar
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numberTriplets
condition|;
name|i
operator|++
control|)
block|{
name|dataIndex
operator|=
name|i
operator|*
literal|3
expr_stmt|;
name|b1
operator|=
name|binaryData
index|[
name|dataIndex
index|]
expr_stmt|;
name|b2
operator|=
name|binaryData
index|[
name|dataIndex
operator|+
literal|1
index|]
expr_stmt|;
name|b3
operator|=
name|binaryData
index|[
name|dataIndex
operator|+
literal|2
index|]
expr_stmt|;
name|l
operator|=
call|(
name|byte
call|)
argument_list|(
name|b2
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|k
operator|=
call|(
name|byte
call|)
argument_list|(
name|b1
operator|&
literal|0x03
argument_list|)
expr_stmt|;
name|byte
name|val1
init|=
operator|(
operator|(
name|b1
operator|&
name|SIGN
operator|)
operator|==
literal|0
operator|)
condition|?
call|(
name|byte
call|)
argument_list|(
name|b1
operator|>>
literal|2
argument_list|)
else|:
call|(
name|byte
call|)
argument_list|(
operator|(
name|b1
operator|)
operator|>>
literal|2
operator|^
literal|0xc0
argument_list|)
decl_stmt|;
name|byte
name|val2
init|=
operator|(
operator|(
name|b2
operator|&
name|SIGN
operator|)
operator|==
literal|0
operator|)
condition|?
call|(
name|byte
call|)
argument_list|(
name|b2
operator|>>
literal|4
argument_list|)
else|:
call|(
name|byte
call|)
argument_list|(
operator|(
name|b2
operator|)
operator|>>
literal|4
operator|^
literal|0xf0
argument_list|)
decl_stmt|;
name|byte
name|val3
init|=
operator|(
operator|(
name|b3
operator|&
name|SIGN
operator|)
operator|==
literal|0
operator|)
condition|?
call|(
name|byte
call|)
argument_list|(
name|b3
operator|>>
literal|6
argument_list|)
else|:
call|(
name|byte
call|)
argument_list|(
operator|(
name|b3
operator|)
operator|>>
literal|6
operator|^
literal|0xfc
argument_list|)
decl_stmt|;
name|encodedData
index|[
name|encodedIndex
index|]
operator|=
name|lookUpBase64Alphabet
index|[
name|val1
index|]
expr_stmt|;
name|encodedData
index|[
name|encodedIndex
operator|+
literal|1
index|]
operator|=
name|lookUpBase64Alphabet
index|[
name|val2
operator||
operator|(
name|k
operator|<<
literal|4
operator|)
index|]
expr_stmt|;
name|encodedData
index|[
name|encodedIndex
operator|+
literal|2
index|]
operator|=
name|lookUpBase64Alphabet
index|[
operator|(
name|l
operator|<<
literal|2
operator|)
operator||
name|val3
index|]
expr_stmt|;
name|encodedData
index|[
name|encodedIndex
operator|+
literal|3
index|]
operator|=
name|lookUpBase64Alphabet
index|[
name|b3
operator|&
literal|0x3f
index|]
expr_stmt|;
name|encodedIndex
operator|+=
literal|4
expr_stmt|;
comment|// If we are chunking, let's put a chunk separator down.
if|if
condition|(
name|isChunked
condition|)
block|{
comment|// this assumes that CHUNK_SIZE % 4 == 0
if|if
condition|(
name|encodedIndex
operator|==
name|nextSeparatorIndex
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|CHUNK_SEPARATOR
argument_list|,
literal|0
argument_list|,
name|encodedData
argument_list|,
name|encodedIndex
argument_list|,
name|CHUNK_SEPARATOR
operator|.
name|length
argument_list|)
expr_stmt|;
name|chunksSoFar
operator|++
expr_stmt|;
name|nextSeparatorIndex
operator|=
operator|(
name|CHUNK_SIZE
operator|*
operator|(
name|chunksSoFar
operator|+
literal|1
operator|)
operator|)
operator|+
operator|(
name|chunksSoFar
operator|*
name|CHUNK_SEPARATOR
operator|.
name|length
operator|)
expr_stmt|;
name|encodedIndex
operator|+=
name|CHUNK_SEPARATOR
operator|.
name|length
expr_stmt|;
block|}
block|}
block|}
comment|// form integral number of 6-bit groups
name|dataIndex
operator|=
name|i
operator|*
literal|3
expr_stmt|;
if|if
condition|(
name|fewerThan24bits
operator|==
name|EIGHTBIT
condition|)
block|{
name|b1
operator|=
name|binaryData
index|[
name|dataIndex
index|]
expr_stmt|;
name|k
operator|=
call|(
name|byte
call|)
argument_list|(
name|b1
operator|&
literal|0x03
argument_list|)
expr_stmt|;
name|byte
name|val1
init|=
operator|(
operator|(
name|b1
operator|&
name|SIGN
operator|)
operator|==
literal|0
operator|)
condition|?
call|(
name|byte
call|)
argument_list|(
name|b1
operator|>>
literal|2
argument_list|)
else|:
call|(
name|byte
call|)
argument_list|(
operator|(
name|b1
operator|)
operator|>>
literal|2
operator|^
literal|0xc0
argument_list|)
decl_stmt|;
name|encodedData
index|[
name|encodedIndex
index|]
operator|=
name|lookUpBase64Alphabet
index|[
name|val1
index|]
expr_stmt|;
name|encodedData
index|[
name|encodedIndex
operator|+
literal|1
index|]
operator|=
name|lookUpBase64Alphabet
index|[
name|k
operator|<<
literal|4
index|]
expr_stmt|;
name|encodedData
index|[
name|encodedIndex
operator|+
literal|2
index|]
operator|=
name|PAD
expr_stmt|;
name|encodedData
index|[
name|encodedIndex
operator|+
literal|3
index|]
operator|=
name|PAD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fewerThan24bits
operator|==
name|SIXTEENBIT
condition|)
block|{
name|b1
operator|=
name|binaryData
index|[
name|dataIndex
index|]
expr_stmt|;
name|b2
operator|=
name|binaryData
index|[
name|dataIndex
operator|+
literal|1
index|]
expr_stmt|;
name|l
operator|=
call|(
name|byte
call|)
argument_list|(
name|b2
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|k
operator|=
call|(
name|byte
call|)
argument_list|(
name|b1
operator|&
literal|0x03
argument_list|)
expr_stmt|;
name|byte
name|val1
init|=
operator|(
operator|(
name|b1
operator|&
name|SIGN
operator|)
operator|==
literal|0
operator|)
condition|?
call|(
name|byte
call|)
argument_list|(
name|b1
operator|>>
literal|2
argument_list|)
else|:
call|(
name|byte
call|)
argument_list|(
operator|(
name|b1
operator|)
operator|>>
literal|2
operator|^
literal|0xc0
argument_list|)
decl_stmt|;
name|byte
name|val2
init|=
operator|(
operator|(
name|b2
operator|&
name|SIGN
operator|)
operator|==
literal|0
operator|)
condition|?
call|(
name|byte
call|)
argument_list|(
name|b2
operator|>>
literal|4
argument_list|)
else|:
call|(
name|byte
call|)
argument_list|(
operator|(
name|b2
operator|)
operator|>>
literal|4
operator|^
literal|0xf0
argument_list|)
decl_stmt|;
name|encodedData
index|[
name|encodedIndex
index|]
operator|=
name|lookUpBase64Alphabet
index|[
name|val1
index|]
expr_stmt|;
name|encodedData
index|[
name|encodedIndex
operator|+
literal|1
index|]
operator|=
name|lookUpBase64Alphabet
index|[
name|val2
operator||
operator|(
name|k
operator|<<
literal|4
operator|)
index|]
expr_stmt|;
name|encodedData
index|[
name|encodedIndex
operator|+
literal|2
index|]
operator|=
name|lookUpBase64Alphabet
index|[
name|l
operator|<<
literal|2
index|]
expr_stmt|;
name|encodedData
index|[
name|encodedIndex
operator|+
literal|3
index|]
operator|=
name|PAD
expr_stmt|;
block|}
if|if
condition|(
name|isChunked
condition|)
block|{
comment|// we also add a separator to the end of the final chunk.
if|if
condition|(
name|chunksSoFar
operator|<
name|nbrChunks
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|CHUNK_SEPARATOR
argument_list|,
literal|0
argument_list|,
name|encodedData
argument_list|,
name|encodedDataLength
operator|-
name|CHUNK_SEPARATOR
operator|.
name|length
argument_list|,
name|CHUNK_SEPARATOR
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|encodedData
return|;
block|}
comment|/**      * Decodes Base64 data into octects      *      * @param base64Data Byte array containing Base64 data      * @return Array containing decoded data.      */
specifier|public
specifier|static
name|byte
index|[]
name|decodeBase64
parameter_list|(
name|byte
index|[]
name|base64Data
parameter_list|)
block|{
comment|// RFC 2045 requires that we discard ALL non-Base64 characters
name|base64Data
operator|=
name|discardNonBase64
argument_list|(
name|base64Data
argument_list|)
expr_stmt|;
comment|// handle the edge case, so we don't have to worry about it later
if|if
condition|(
name|base64Data
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|byte
index|[
literal|0
index|]
return|;
block|}
name|int
name|numberQuadruple
init|=
name|base64Data
operator|.
name|length
operator|/
name|FOURBYTE
decl_stmt|;
name|byte
name|decodedData
index|[]
init|=
literal|null
decl_stmt|;
name|byte
name|b1
init|=
literal|0
decl_stmt|,
name|b2
init|=
literal|0
decl_stmt|,
name|b3
init|=
literal|0
decl_stmt|,
name|b4
init|=
literal|0
decl_stmt|,
name|marker0
init|=
literal|0
decl_stmt|,
name|marker1
init|=
literal|0
decl_stmt|;
comment|// Throw away anything not in base64Data
name|int
name|encodedIndex
init|=
literal|0
decl_stmt|;
name|int
name|dataIndex
init|=
literal|0
decl_stmt|;
block|{
comment|// this sizes the output array properly - rlw
name|int
name|lastData
init|=
name|base64Data
operator|.
name|length
decl_stmt|;
comment|// ignore the '=' padding
while|while
condition|(
name|base64Data
index|[
name|lastData
operator|-
literal|1
index|]
operator|==
name|PAD
condition|)
block|{
if|if
condition|(
operator|--
name|lastData
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|byte
index|[
literal|0
index|]
return|;
block|}
block|}
name|decodedData
operator|=
operator|new
name|byte
index|[
name|lastData
operator|-
name|numberQuadruple
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberQuadruple
condition|;
name|i
operator|++
control|)
block|{
name|dataIndex
operator|=
name|i
operator|*
literal|4
expr_stmt|;
name|marker0
operator|=
name|base64Data
index|[
name|dataIndex
operator|+
literal|2
index|]
expr_stmt|;
name|marker1
operator|=
name|base64Data
index|[
name|dataIndex
operator|+
literal|3
index|]
expr_stmt|;
name|b1
operator|=
name|base64Alphabet
index|[
name|base64Data
index|[
name|dataIndex
index|]
index|]
expr_stmt|;
name|b2
operator|=
name|base64Alphabet
index|[
name|base64Data
index|[
name|dataIndex
operator|+
literal|1
index|]
index|]
expr_stmt|;
if|if
condition|(
name|marker0
operator|!=
name|PAD
operator|&&
name|marker1
operator|!=
name|PAD
condition|)
block|{
comment|//No PAD e.g 3cQl
name|b3
operator|=
name|base64Alphabet
index|[
name|marker0
index|]
expr_stmt|;
name|b4
operator|=
name|base64Alphabet
index|[
name|marker1
index|]
expr_stmt|;
name|decodedData
index|[
name|encodedIndex
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|b1
operator|<<
literal|2
operator||
name|b2
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|decodedData
index|[
name|encodedIndex
operator|+
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
operator|(
name|b2
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|b3
operator|>>
literal|2
operator|)
operator|&
literal|0xf
operator|)
argument_list|)
expr_stmt|;
name|decodedData
index|[
name|encodedIndex
operator|+
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|b3
operator|<<
literal|6
operator||
name|b4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|marker0
operator|==
name|PAD
condition|)
block|{
comment|//Two PAD e.g. 3c[Pad][Pad]
name|decodedData
index|[
name|encodedIndex
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|b1
operator|<<
literal|2
operator||
name|b2
operator|>>
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|marker1
operator|==
name|PAD
condition|)
block|{
comment|//One PAD e.g. 3cQ[Pad]
name|b3
operator|=
name|base64Alphabet
index|[
name|marker0
index|]
expr_stmt|;
name|decodedData
index|[
name|encodedIndex
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|b1
operator|<<
literal|2
operator||
name|b2
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|decodedData
index|[
name|encodedIndex
operator|+
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
operator|(
name|b2
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|b3
operator|>>
literal|2
operator|)
operator|&
literal|0xf
operator|)
argument_list|)
expr_stmt|;
block|}
name|encodedIndex
operator|+=
literal|3
expr_stmt|;
block|}
return|return
name|decodedData
return|;
block|}
comment|/**      * Discards any whitespace from a base-64 encoded block.      *      * @param data The base-64 encoded data to discard the whitespace      * from.      * @return The data, less whitespace (see RFC 2045).      */
specifier|static
name|byte
index|[]
name|discardWhitespace
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
block|{
name|byte
name|groomedData
index|[]
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
index|]
decl_stmt|;
name|int
name|bytesCopied
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|data
index|[
name|i
index|]
condition|)
block|{
case|case
operator|(
name|byte
operator|)
literal|' '
case|:
case|case
operator|(
name|byte
operator|)
literal|'\n'
case|:
case|case
operator|(
name|byte
operator|)
literal|'\r'
case|:
case|case
operator|(
name|byte
operator|)
literal|'\t'
case|:
break|break;
default|default:
name|groomedData
index|[
name|bytesCopied
operator|++
index|]
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|byte
name|packedData
index|[]
init|=
operator|new
name|byte
index|[
name|bytesCopied
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|groomedData
argument_list|,
literal|0
argument_list|,
name|packedData
argument_list|,
literal|0
argument_list|,
name|bytesCopied
argument_list|)
expr_stmt|;
return|return
name|packedData
return|;
block|}
comment|/**      * Discards any characters outside of the base64 alphabet, per      * the requirements on page 25 of RFC 2045 - "Any characters      * outside of the base64 alphabet are to be ignored in base64      * encoded data."      *      * @param data The base-64 encoded data to groom      * @return The data, less non-base64 characters (see RFC 2045).      */
specifier|static
name|byte
index|[]
name|discardNonBase64
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
block|{
name|byte
name|groomedData
index|[]
init|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
index|]
decl_stmt|;
name|int
name|bytesCopied
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isBase64
argument_list|(
name|data
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|groomedData
index|[
name|bytesCopied
operator|++
index|]
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|byte
name|packedData
index|[]
init|=
operator|new
name|byte
index|[
name|bytesCopied
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|groomedData
argument_list|,
literal|0
argument_list|,
name|packedData
argument_list|,
literal|0
argument_list|,
name|bytesCopied
argument_list|)
expr_stmt|;
return|return
name|packedData
return|;
block|}
comment|// Implementation of the Encoder Interface
comment|/**      * Encodes an Object using the base64 algorithm.  This method      * is provided in order to satisfy the requirements of the      * Encoder interface, and will throw an EncoderException if the      * supplied object is not of type byte[].      *      * @param pObject Object to encode      * @return An object (of type byte[]) containing the       *         base64 encoded data which corresponds to the byte[] supplied.      * @throws InvalidParameterException if the parameter supplied is not      *                          of type byte[]      */
specifier|public
name|Object
name|encode
parameter_list|(
name|Object
name|pObject
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|pObject
operator|instanceof
name|byte
index|[]
operator|)
condition|)
block|{
throw|throw
operator|new
name|InvalidParameterException
argument_list|(
literal|"Parameter supplied to Base64 encode is not a byte[]"
argument_list|)
throw|;
block|}
return|return
name|encode
argument_list|(
operator|(
name|byte
index|[]
operator|)
name|pObject
argument_list|)
return|;
block|}
comment|/**      * Encodes a byte[] containing binary data, into a byte[] containing      * characters in the Base64 alphabet.      *      * @param pArray a byte array containing binary data      * @return A byte array containing only Base64 character data      */
specifier|public
name|byte
index|[]
name|encode
parameter_list|(
name|byte
index|[]
name|pArray
parameter_list|)
block|{
return|return
name|encodeBase64
argument_list|(
name|pArray
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
end_class

end_unit

