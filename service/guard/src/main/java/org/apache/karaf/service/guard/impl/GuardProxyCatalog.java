begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|service
operator|.
name|guard
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Dictionary
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|aries
operator|.
name|proxy
operator|.
name|InvocationListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|aries
operator|.
name|proxy
operator|.
name|ProxyManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|aries
operator|.
name|proxy
operator|.
name|UnableToProxyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|service
operator|.
name|guard
operator|.
name|tools
operator|.
name|ACLConfigurationParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|service
operator|.
name|guard
operator|.
name|tools
operator|.
name|ACLConfigurationParser
operator|.
name|Specificity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|util
operator|.
name|jaas
operator|.
name|JaasHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|Bundle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|BundleContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|InvalidSyntaxException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|ServiceEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|ServiceFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|ServiceListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|ServiceReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|ServiceRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|cm
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|cm
operator|.
name|ConfigurationAdmin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|util
operator|.
name|tracker
operator|.
name|ServiceTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|util
operator|.
name|tracker
operator|.
name|ServiceTrackerCustomizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
specifier|public
class|class
name|GuardProxyCatalog
implements|implements
name|ServiceListener
block|{
specifier|public
specifier|static
specifier|final
name|String
name|KARAF_SECURED_SERVICES_SYSPROP
init|=
literal|"karaf.secured.services"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|SERVICE_GUARD_ROLES_PROPERTY
init|=
literal|"org.apache.karaf.service.guard.roles"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|KARAF_SECURED_COMMAND_COMPULSORY_ROLES_PROPERTY
init|=
literal|"karaf.secured.command.compulsory.roles"
decl_stmt|;
specifier|static
specifier|final
name|String
name|PROXY_CREATOR_THREAD_NAME
init|=
literal|"Secure OSGi Service Proxy Creator"
decl_stmt|;
specifier|static
specifier|final
name|String
name|PROXY_SERVICE_KEY
init|=
literal|"."
operator|+
name|GuardProxyCatalog
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// The only currently used value is Boolean.TRUE
specifier|static
specifier|final
name|String
name|SERVICE_ACL_PREFIX
init|=
literal|"org.apache.karaf.service.acl."
decl_stmt|;
specifier|static
specifier|final
name|String
name|SERVICE_GUARD_KEY
init|=
literal|"service.guard"
decl_stmt|;
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|GuardProxyCatalog
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Pattern
name|JAVA_METHOD_NAME_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[a-zA-Z_$][a-zA-Z0-9_$]*"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|ROLE_WILDCARD
init|=
literal|"*"
decl_stmt|;
specifier|private
specifier|final
name|BundleContext
name|myBundleContext
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Filter
argument_list|>
name|filters
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|ServiceTracker
argument_list|<
name|ConfigurationAdmin
argument_list|,
name|ConfigurationAdmin
argument_list|>
name|configAdminTracker
decl_stmt|;
specifier|final
name|ServiceTracker
argument_list|<
name|ProxyManager
argument_list|,
name|ProxyManager
argument_list|>
name|proxyManagerTracker
decl_stmt|;
specifier|final
name|ConcurrentMap
argument_list|<
name|Long
argument_list|,
name|ServiceRegistrationHolder
argument_list|>
name|proxyMap
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|BlockingQueue
argument_list|<
name|CreateProxyRunnable
argument_list|>
name|createProxyQueue
init|=
operator|new
name|LinkedBlockingQueue
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|String
name|compulsoryRoles
decl_stmt|;
comment|// These two variables control the proxy creator thread, which is started as soon as a ProxyManager Service
comment|// becomes available.
specifier|volatile
name|boolean
name|runProxyCreator
init|=
literal|true
decl_stmt|;
specifier|volatile
name|Thread
name|proxyCreatorThread
init|=
literal|null
decl_stmt|;
name|GuardProxyCatalog
parameter_list|(
name|BundleContext
name|bc
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Starting GuardProxyCatalog"
argument_list|)
expr_stmt|;
name|myBundleContext
operator|=
name|bc
expr_stmt|;
name|compulsoryRoles
operator|=
name|System
operator|.
name|getProperty
argument_list|(
name|GuardProxyCatalog
operator|.
name|KARAF_SECURED_COMMAND_COMPULSORY_ROLES_PROPERTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|compulsoryRoles
operator|==
literal|null
condition|)
block|{
comment|//default behavior as before, no compulsory roles for a karaf command without the ACL
name|LOG
operator|.
name|info
argument_list|(
literal|"No compulsory roles for a karaf command without the ACL as its system property is not set: {}"
argument_list|,
name|GuardProxyCatalog
operator|.
name|KARAF_SECURED_COMMAND_COMPULSORY_ROLES_PROPERTY
argument_list|)
expr_stmt|;
block|}
comment|// The service listener is used to update/unregister proxies if the backing service changes/goes away
name|bc
operator|.
name|addServiceListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|Filter
name|caFilter
init|=
name|getNonProxyFilter
argument_list|(
name|bc
argument_list|,
name|ConfigurationAdmin
operator|.
name|class
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Creating Config Admin Tracker using filter {}"
argument_list|,
name|caFilter
argument_list|)
expr_stmt|;
name|configAdminTracker
operator|=
operator|new
name|ServiceTracker
argument_list|<>
argument_list|(
name|bc
argument_list|,
name|caFilter
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|configAdminTracker
operator|.
name|open
argument_list|()
expr_stmt|;
name|Filter
name|pmFilter
init|=
name|getNonProxyFilter
argument_list|(
name|bc
argument_list|,
name|ProxyManager
operator|.
name|class
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Creating Proxy Manager Tracker using filter {}"
argument_list|,
name|pmFilter
argument_list|)
expr_stmt|;
name|proxyManagerTracker
operator|=
operator|new
name|ServiceTracker
argument_list|<>
argument_list|(
name|bc
argument_list|,
name|pmFilter
argument_list|,
operator|new
name|ServiceProxyCreatorCustomizer
argument_list|()
argument_list|)
expr_stmt|;
name|proxyManagerTracker
operator|.
name|open
argument_list|()
expr_stmt|;
block|}
specifier|static
name|Filter
name|getNonProxyFilter
parameter_list|(
name|BundleContext
name|bc
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|)
throws|throws
name|InvalidSyntaxException
block|{
name|Filter
name|caFilter
init|=
name|bc
operator|.
name|createFilter
argument_list|(
literal|"(&("
operator|+
name|Constants
operator|.
name|OBJECTCLASS
operator|+
literal|"="
operator|+
name|clazz
operator|.
name|getName
argument_list|()
operator|+
literal|")(!("
operator|+
name|PROXY_SERVICE_KEY
operator|+
literal|"=*)))"
argument_list|)
decl_stmt|;
return|return
name|caFilter
return|;
block|}
name|void
name|close
parameter_list|()
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Stopping GuardProxyCatalog"
argument_list|)
expr_stmt|;
name|stopProxyCreator
argument_list|()
expr_stmt|;
name|proxyManagerTracker
operator|.
name|close
argument_list|()
expr_stmt|;
name|configAdminTracker
operator|.
name|close
argument_list|()
expr_stmt|;
name|myBundleContext
operator|.
name|removeServiceListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Remove all proxy registrations
for|for
control|(
name|ServiceRegistrationHolder
name|holder
range|:
name|proxyMap
operator|.
name|values
argument_list|()
control|)
block|{
name|ServiceRegistration
argument_list|<
name|?
argument_list|>
name|reg
init|=
name|holder
operator|.
name|registration
decl_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Unregistering proxy service of {} with properties {}"
argument_list|,
name|reg
operator|.
name|getReference
argument_list|()
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|OBJECTCLASS
argument_list|)
argument_list|,
name|copyProperties
argument_list|(
name|reg
operator|.
name|getReference
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|.
name|unregister
argument_list|()
expr_stmt|;
block|}
block|}
name|proxyMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|serviceChanged
parameter_list|(
name|ServiceEvent
name|event
parameter_list|)
block|{
comment|// This method is to ensure that proxied services follow the original service. I.e. if the original service
comment|// goes away the proxies should go away too. If the original service is modified, the proxies should be
comment|// modified accordingly
name|ServiceReference
argument_list|<
name|?
argument_list|>
name|sr
init|=
name|event
operator|.
name|getServiceReference
argument_list|()
decl_stmt|;
if|if
condition|(
name|event
operator|.
name|getType
argument_list|()
operator|==
name|ServiceEvent
operator|.
name|REGISTERED
condition|)
block|{
comment|// Nothing to do for new services
return|return;
block|}
if|if
condition|(
name|isProxy
argument_list|(
name|sr
argument_list|)
condition|)
block|{
comment|// Ignore proxies, we only react to real service changes
return|return;
block|}
name|Long
name|orgServiceID
init|=
operator|(
name|Long
operator|)
name|sr
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|SERVICE_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|event
operator|.
name|getType
argument_list|()
operator|==
name|ServiceEvent
operator|.
name|UNREGISTERING
condition|)
block|{
name|handleOriginalServiceUnregistering
argument_list|(
name|orgServiceID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|event
operator|.
name|getType
argument_list|()
operator|&
operator|(
name|ServiceEvent
operator|.
name|MODIFIED
operator||
name|ServiceEvent
operator|.
name|MODIFIED_ENDMATCH
operator|)
operator|)
operator|>
literal|0
condition|)
block|{
name|handleOriginalServiceModifed
argument_list|(
name|orgServiceID
argument_list|,
name|sr
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|handleOriginalServiceUnregistering
parameter_list|(
name|Long
name|orgServiceID
parameter_list|)
block|{
comment|// If the service queued up to be proxied, remove it.
for|for
control|(
name|Iterator
argument_list|<
name|CreateProxyRunnable
argument_list|>
name|i
init|=
name|createProxyQueue
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|CreateProxyRunnable
name|cpr
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|orgServiceID
operator|.
name|equals
argument_list|(
name|cpr
operator|.
name|getOriginalServiceID
argument_list|()
argument_list|)
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
name|ServiceRegistrationHolder
name|holder
init|=
name|proxyMap
operator|.
name|remove
argument_list|(
name|orgServiceID
argument_list|)
decl_stmt|;
if|if
condition|(
name|holder
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|holder
operator|.
name|registration
operator|!=
literal|null
condition|)
block|{
name|holder
operator|.
name|registration
operator|.
name|unregister
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|handleOriginalServiceModifed
parameter_list|(
name|Long
name|orgServiceID
parameter_list|,
name|ServiceReference
argument_list|<
name|?
argument_list|>
name|orgServiceRef
parameter_list|)
block|{
comment|// We don't need to do anything for services that are queued up to be proxied, as the
comment|// properties are only taken at the point of proxyfication...
name|ServiceRegistrationHolder
name|holder
init|=
name|proxyMap
operator|.
name|get
argument_list|(
name|orgServiceID
argument_list|)
decl_stmt|;
if|if
condition|(
name|holder
operator|!=
literal|null
condition|)
block|{
name|ServiceRegistration
argument_list|<
name|?
argument_list|>
name|reg
init|=
name|holder
operator|.
name|registration
decl_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|null
condition|)
block|{
comment|// Preserve the roles as they are expensive to compute
name|Object
name|roles
init|=
name|reg
operator|.
name|getReference
argument_list|()
operator|.
name|getProperty
argument_list|(
name|SERVICE_GUARD_ROLES_PROPERTY
argument_list|)
decl_stmt|;
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|newProxyProps
init|=
name|proxyProperties
argument_list|(
name|orgServiceRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|roles
operator|!=
literal|null
condition|)
block|{
name|newProxyProps
operator|.
name|put
argument_list|(
name|SERVICE_GUARD_ROLES_PROPERTY
argument_list|,
name|roles
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newProxyProps
operator|.
name|remove
argument_list|(
name|SERVICE_GUARD_ROLES_PROPERTY
argument_list|)
expr_stmt|;
block|}
name|reg
operator|.
name|setProperties
argument_list|(
name|newProxyProps
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|boolean
name|isProxy
parameter_list|(
name|ServiceReference
argument_list|<
name|?
argument_list|>
name|sr
parameter_list|)
block|{
return|return
name|sr
operator|.
name|getProperty
argument_list|(
name|PROXY_SERVICE_KEY
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|// Called by hooks to find out whether the service should be hidden.
comment|// Also handles the proxy creation of services if applicable.
comment|// Return true if the hook should hide the service for the bundle
name|boolean
name|handleProxificationForHook
parameter_list|(
name|ServiceReference
argument_list|<
name|?
argument_list|>
name|sr
parameter_list|)
block|{
comment|// Note that when running under an OSGi R6 framework the number of proxies created
comment|// can be limited by looking at the new 'service.scope' property. If the value is
comment|// 'singleton' then the same proxy can be shared across all clients.
comment|// Pre OSGi R6 it is not possible to find out whether a service is backed by a
comment|// Service Factory, so we assume that every service is.
if|if
condition|(
name|isProxy
argument_list|(
name|sr
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|proxyIfNotAlreadyProxied
argument_list|(
name|sr
argument_list|)
expr_stmt|;
comment|// Note does most of the work async
return|return
literal|true
return|;
block|}
name|void
name|proxyIfNotAlreadyProxied
parameter_list|(
specifier|final
name|ServiceReference
argument_list|<
name|?
argument_list|>
name|originalRef
parameter_list|)
block|{
specifier|final
name|long
name|orgServiceID
init|=
operator|(
name|Long
operator|)
name|originalRef
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|SERVICE_ID
argument_list|)
decl_stmt|;
comment|// make sure it's on the map before the proxy is registered, as that can trigger
comment|// another call into this method, and we need to make sure that it doesn't proxy
comment|// the service again.
specifier|final
name|ServiceRegistrationHolder
name|registrationHolder
init|=
operator|new
name|ServiceRegistrationHolder
argument_list|()
decl_stmt|;
name|ServiceRegistrationHolder
name|previousHolder
init|=
name|proxyMap
operator|.
name|putIfAbsent
argument_list|(
name|orgServiceID
argument_list|,
name|registrationHolder
argument_list|)
decl_stmt|;
if|if
condition|(
name|previousHolder
operator|!=
literal|null
condition|)
block|{
comment|// There is already a proxy for this service
return|return;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Will create proxy of service {}({})"
argument_list|,
name|originalRef
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|OBJECTCLASS
argument_list|)
argument_list|,
name|orgServiceID
argument_list|)
expr_stmt|;
comment|// Instead of immediately creating the proxy, we add the code that creates the proxy to the proxyQueue.
comment|// This means that we can better react to the fact that the ProxyManager service might arrive
comment|// later. As soon as the Proxy Manager is available, the queue is emptied and the proxies created.
name|CreateProxyRunnable
name|cpr
init|=
operator|new
name|CreateProxyRunnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|long
name|getOriginalServiceID
parameter_list|()
block|{
return|return
name|orgServiceID
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|(
specifier|final
name|ProxyManager
name|pm
parameter_list|)
throws|throws
name|Exception
block|{
name|String
index|[]
name|objectClassProperty
init|=
operator|(
name|String
index|[]
operator|)
name|originalRef
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|OBJECTCLASS
argument_list|)
decl_stmt|;
name|ServiceFactory
argument_list|<
name|Object
argument_list|>
name|sf
init|=
operator|new
name|ProxyServiceFactory
argument_list|(
name|pm
argument_list|,
name|originalRef
argument_list|)
decl_stmt|;
name|registrationHolder
operator|.
name|registration
operator|=
name|originalRef
operator|.
name|getBundle
argument_list|()
operator|.
name|getBundleContext
argument_list|()
operator|.
name|registerService
argument_list|(
name|objectClassProperty
argument_list|,
name|sf
argument_list|,
name|proxyPropertiesRoles
argument_list|()
argument_list|)
expr_stmt|;
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|actualProxyProps
init|=
name|copyProperties
argument_list|(
name|registrationHolder
operator|.
name|registration
operator|.
name|getReference
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created proxy of service {} under {} with properties {}"
argument_list|,
name|orgServiceID
argument_list|,
name|actualProxyProps
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|OBJECTCLASS
argument_list|)
argument_list|,
name|actualProxyProps
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|proxyPropertiesRoles
parameter_list|()
throws|throws
name|Exception
block|{
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|p
init|=
name|proxyProperties
argument_list|(
name|originalRef
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|roles
init|=
name|getServiceInvocationRoles
argument_list|(
name|originalRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|roles
operator|!=
literal|null
condition|)
block|{
name|roles
operator|.
name|remove
argument_list|(
name|ROLE_WILDCARD
argument_list|)
expr_stmt|;
comment|// we don't expose that on the service property
name|p
operator|.
name|put
argument_list|(
name|SERVICE_GUARD_ROLES_PROPERTY
argument_list|,
name|roles
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// In this case there are no roles defined for the service so anyone can invoke it
name|p
operator|.
name|remove
argument_list|(
name|SERVICE_GUARD_ROLES_PROPERTY
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
block|}
decl_stmt|;
try|try
block|{
name|createProxyQueue
operator|.
name|put
argument_list|(
name|cpr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Problem scheduling a proxy creator for service {}({})"
argument_list|,
name|originalRef
operator|.
name|getProperty
argument_list|(
name|Constants
operator|.
name|OBJECTCLASS
argument_list|)
argument_list|,
name|orgServiceID
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|proxyProperties
parameter_list|(
name|ServiceReference
argument_list|<
name|?
argument_list|>
name|sr
parameter_list|)
block|{
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|p
init|=
name|copyProperties
argument_list|(
name|sr
argument_list|)
decl_stmt|;
name|p
operator|.
name|put
argument_list|(
name|PROXY_SERVICE_KEY
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
specifier|private
specifier|static
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|copyProperties
parameter_list|(
name|ServiceReference
argument_list|<
name|?
argument_list|>
name|sr
parameter_list|)
block|{
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|p
init|=
operator|new
name|Hashtable
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|sr
operator|.
name|getPropertyKeys
argument_list|()
control|)
block|{
name|p
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|sr
operator|.
name|getProperty
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
comment|// Returns what roles can possibly ever invoke this service. Note that not every invocation may be successful
comment|// as there can be different roles for different methods and also roles based on arguments passed in.
name|Set
argument_list|<
name|String
argument_list|>
name|getServiceInvocationRoles
parameter_list|(
name|ServiceReference
argument_list|<
name|?
argument_list|>
name|serviceReference
parameter_list|)
throws|throws
name|Exception
block|{
name|boolean
name|definitionFound
init|=
literal|false
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|allRoles
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// This can probably be optimized. Maybe we can cache the config object relevant instead of
comment|// walking through all of the ones that have 'service.guard'.
for|for
control|(
name|Configuration
name|config
range|:
name|getServiceGuardConfigs
argument_list|()
control|)
block|{
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|properties
init|=
name|config
operator|.
name|getProperties
argument_list|()
decl_stmt|;
name|Object
name|guardFilter
init|=
name|properties
operator|.
name|get
argument_list|(
name|SERVICE_GUARD_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|guardFilter
operator|instanceof
name|String
condition|)
block|{
name|Filter
name|filter
init|=
name|getFilter
argument_list|(
operator|(
name|String
operator|)
name|guardFilter
argument_list|)
decl_stmt|;
if|if
condition|(
name|filter
operator|.
name|match
argument_list|(
name|serviceReference
argument_list|)
condition|)
block|{
name|definitionFound
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|Enumeration
argument_list|<
name|String
argument_list|>
name|e
init|=
name|properties
operator|.
name|keys
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|String
name|key
init|=
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|String
name|bareKey
init|=
name|key
decl_stmt|;
name|int
name|idx
init|=
name|bareKey
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
block|{
name|bareKey
operator|=
name|bareKey
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
name|int
name|idx1
init|=
name|bareKey
operator|.
name|indexOf
argument_list|(
literal|'['
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx1
operator|>=
literal|0
condition|)
block|{
name|bareKey
operator|=
name|bareKey
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|idx1
argument_list|)
expr_stmt|;
block|}
name|int
name|idx2
init|=
name|bareKey
operator|.
name|indexOf
argument_list|(
literal|'*'
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx2
operator|>=
literal|0
condition|)
block|{
name|bareKey
operator|=
name|bareKey
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|idx2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isValidMethodName
argument_list|(
name|bareKey
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|Object
name|value
init|=
name|properties
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
name|allRoles
operator|.
name|addAll
argument_list|(
name|ACLConfigurationParser
operator|.
name|parseRoles
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|definitionFound
condition|?
name|allRoles
else|:
literal|null
return|;
block|}
specifier|private
name|Filter
name|getFilter
parameter_list|(
name|String
name|string
parameter_list|)
throws|throws
name|InvalidSyntaxException
block|{
name|Filter
name|filter
init|=
name|filters
operator|.
name|get
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
block|{
name|filter
operator|=
name|myBundleContext
operator|.
name|createFilter
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|filters
operator|.
name|put
argument_list|(
name|string
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
return|return
name|filter
return|;
block|}
comment|// Ensures that it never returns null
specifier|private
name|Configuration
index|[]
name|getServiceGuardConfigs
parameter_list|()
throws|throws
name|IOException
throws|,
name|InvalidSyntaxException
block|{
name|ConfigurationAdmin
name|ca
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ca
operator|=
name|configAdminTracker
operator|.
name|waitForService
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{         }
if|if
condition|(
name|ca
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Role based access for services requires the OSGi Configuration Admin Service to be present"
argument_list|)
throw|;
block|}
name|Configuration
index|[]
name|configs
init|=
name|ca
operator|.
name|listConfigurations
argument_list|(
literal|"(&("
operator|+
name|Constants
operator|.
name|SERVICE_PID
operator|+
literal|"="
operator|+
name|SERVICE_ACL_PREFIX
operator|+
literal|"*)("
operator|+
name|SERVICE_GUARD_KEY
operator|+
literal|"=*))"
argument_list|)
decl_stmt|;
if|if
condition|(
name|configs
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|Configuration
index|[]
block|{}
return|;
block|}
return|return
name|configs
return|;
block|}
specifier|private
name|boolean
name|isValidMethodName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|JAVA_METHOD_NAME_PATTERN
operator|.
name|matcher
argument_list|(
name|name
argument_list|)
operator|.
name|matches
argument_list|()
return|;
block|}
name|void
name|stopProxyCreator
parameter_list|()
block|{
name|runProxyCreator
operator|=
literal|false
expr_stmt|;
comment|// Will end the proxy creation thread
if|if
condition|(
name|proxyCreatorThread
operator|!=
literal|null
condition|)
block|{
name|proxyCreatorThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
specifier|static
name|boolean
name|currentUserHasRole
parameter_list|(
name|String
name|reqRole
parameter_list|)
block|{
if|if
condition|(
name|ROLE_WILDCARD
operator|.
name|equals
argument_list|(
name|reqRole
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|JaasHelper
operator|.
name|currentUserHasRole
argument_list|(
name|reqRole
argument_list|)
return|;
block|}
specifier|static
class|class
name|ServiceRegistrationHolder
block|{
specifier|volatile
name|ServiceRegistration
argument_list|<
name|?
argument_list|>
name|registration
decl_stmt|;
block|}
class|class
name|ProxyServiceFactory
implements|implements
name|ServiceFactory
argument_list|<
name|Object
argument_list|>
block|{
specifier|private
specifier|final
name|ProxyManager
name|pm
decl_stmt|;
specifier|private
specifier|final
name|ServiceReference
argument_list|<
name|?
argument_list|>
name|originalRef
decl_stmt|;
name|ProxyServiceFactory
parameter_list|(
name|ProxyManager
name|pm
parameter_list|,
name|ServiceReference
argument_list|<
name|?
argument_list|>
name|originalRef
parameter_list|)
block|{
name|this
operator|.
name|pm
operator|=
name|pm
expr_stmt|;
name|this
operator|.
name|originalRef
operator|=
name|originalRef
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getService
parameter_list|(
name|Bundle
name|bundle
parameter_list|,
name|ServiceRegistration
argument_list|<
name|Object
argument_list|>
name|registration
parameter_list|)
block|{
name|Set
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|allClasses
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// This needs to be done on the Client BundleContext since the bundle might be backed by a Service Factory
comment|// in which case it needs to be given a chance to produce the right service for this client.
name|Object
name|svc
init|=
name|bundle
operator|.
name|getBundleContext
argument_list|()
operator|.
name|getService
argument_list|(
name|originalRef
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|curClass
init|=
name|svc
operator|.
name|getClass
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|Object
operator|.
name|class
operator|.
name|equals
argument_list|(
name|curClass
argument_list|)
condition|)
block|{
name|allClasses
operator|.
name|add
argument_list|(
name|curClass
argument_list|)
expr_stmt|;
name|allClasses
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|curClass
operator|.
name|getInterfaces
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|curClass
operator|=
name|curClass
operator|.
name|getSuperclass
argument_list|()
expr_stmt|;
comment|// Collect super types too
block|}
for|for
control|(
name|Iterator
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|i
init|=
name|allClasses
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|cls
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|cls
operator|.
name|getModifiers
argument_list|()
operator|&
operator|(
name|Modifier
operator|.
name|PUBLIC
operator||
name|Modifier
operator|.
name|PROTECTED
operator|)
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|cls
operator|.
name|getModifiers
argument_list|()
operator|&
name|Modifier
operator|.
name|FINAL
operator|)
operator|>
literal|0
operator|)
operator|||
name|cls
operator|.
name|isAnonymousClass
argument_list|()
operator|||
name|cls
operator|.
name|isLocalClass
argument_list|()
condition|)
block|{
comment|// Do not attempt to proxy private, package-default, final,  anonymous or local classes
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|Method
name|m
range|:
name|cls
operator|.
name|getDeclaredMethods
argument_list|()
control|)
block|{
if|if
condition|(
operator|(
name|m
operator|.
name|getModifiers
argument_list|()
operator|&
name|Modifier
operator|.
name|FINAL
operator|)
operator|>
literal|0
condition|)
block|{
comment|// If the class contains final methods, don't attempt to proxy it
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|InvocationListener
name|il
init|=
operator|new
name|ProxyInvocationListener
argument_list|(
name|originalRef
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|pm
operator|.
name|createInterceptingProxy
argument_list|(
name|originalRef
operator|.
name|getBundle
argument_list|()
argument_list|,
name|allClasses
argument_list|,
name|svc
argument_list|,
name|il
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnableToProxyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|ungetService
parameter_list|(
name|Bundle
name|bundle
parameter_list|,
name|ServiceRegistration
argument_list|<
name|Object
argument_list|>
name|registration
parameter_list|,
name|Object
name|service
parameter_list|)
block|{
name|bundle
operator|.
name|getBundleContext
argument_list|()
operator|.
name|ungetService
argument_list|(
name|originalRef
argument_list|)
expr_stmt|;
block|}
block|}
class|class
name|ProxyInvocationListener
implements|implements
name|InvocationListener
block|{
specifier|private
specifier|final
name|ServiceReference
argument_list|<
name|?
argument_list|>
name|serviceReference
decl_stmt|;
name|ProxyInvocationListener
parameter_list|(
name|ServiceReference
argument_list|<
name|?
argument_list|>
name|sr
parameter_list|)
block|{
name|this
operator|.
name|serviceReference
operator|=
name|sr
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|preInvoke
parameter_list|(
name|Object
name|proxy
parameter_list|,
name|Method
name|m
parameter_list|,
name|Object
index|[]
name|args
parameter_list|)
throws|throws
name|Throwable
block|{
name|String
index|[]
name|sig
init|=
operator|new
name|String
index|[
name|m
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sig
index|[
name|i
index|]
operator|=
name|m
operator|.
name|getParameterTypes
argument_list|()
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
comment|// The ordering of the keys is important because the first value when iterating has the highest specificity
name|TreeMap
argument_list|<
name|Specificity
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|roleMappings
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|foundMatchingConfig
init|=
literal|false
decl_stmt|;
comment|// This can probably be optimized. Maybe we can cache the config object relevant instead of
comment|// walking through all of the ones that have 'service.guard'.
name|Object
name|guardFilter
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Configuration
name|config
range|:
name|getServiceGuardConfigs
argument_list|()
control|)
block|{
name|guardFilter
operator|=
name|config
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
name|SERVICE_GUARD_KEY
argument_list|)
expr_stmt|;
if|if
condition|(
name|guardFilter
operator|instanceof
name|String
condition|)
block|{
name|Filter
name|filter
init|=
name|myBundleContext
operator|.
name|createFilter
argument_list|(
operator|(
name|String
operator|)
name|guardFilter
argument_list|)
decl_stmt|;
if|if
condition|(
name|filter
operator|.
name|match
argument_list|(
name|serviceReference
argument_list|)
condition|)
block|{
name|foundMatchingConfig
operator|=
literal|true
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|roles
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Specificity
name|s
init|=
name|ACLConfigurationParser
operator|.
name|getRolesForInvocation
argument_list|(
name|m
operator|.
name|getName
argument_list|()
argument_list|,
name|args
argument_list|,
name|sig
argument_list|,
name|config
operator|.
name|getProperties
argument_list|()
argument_list|,
name|roles
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|Specificity
operator|.
name|NO_MATCH
condition|)
block|{
name|roleMappings
operator|.
name|put
argument_list|(
name|s
argument_list|,
name|roles
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|Specificity
operator|.
name|ARGUMENT_MATCH
condition|)
block|{
comment|// No more specific mapping can be found
break|break;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|foundMatchingConfig
condition|)
block|{
if|if
condition|(
name|compulsoryRoles
operator|!=
literal|null
operator|&&
operator|(
name|guardFilter
operator|instanceof
name|String
operator|)
operator|&&
operator|(
operator|(
name|String
operator|)
name|guardFilter
operator|)
operator|.
name|indexOf
argument_list|(
literal|"osgi.command.scope"
argument_list|)
operator|>
literal|0
operator|&&
operator|(
operator|(
name|String
operator|)
name|guardFilter
operator|)
operator|.
name|indexOf
argument_list|(
literal|"osgi.command.functio"
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|//use compulsoryRoles roles for those karaf command without any ACL
name|roleMappings
operator|.
name|put
argument_list|(
name|Specificity
operator|.
name|NAME_MATCH
argument_list|,
name|ACLConfigurationParser
operator|.
name|parseRoles
argument_list|(
name|compulsoryRoles
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No mappings for this service, anyone can invoke
return|return
literal|null
return|;
block|}
block|}
if|if
condition|(
name|roleMappings
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Service {} has role mapping, but assigned no roles to method {}"
argument_list|,
name|serviceReference
argument_list|,
name|m
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SecurityException
argument_list|(
literal|"Insufficient credentials."
argument_list|)
throw|;
block|}
comment|// The first entry on the map has the highest significance because the keys are sorted in the order of
comment|// the Specificity enum.
name|List
argument_list|<
name|String
argument_list|>
name|allowedRoles
init|=
name|roleMappings
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|role
range|:
name|allowedRoles
control|)
block|{
if|if
condition|(
name|currentUserHasRole
argument_list|(
name|role
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Allow user with role {} to invoke service {} method {}"
argument_list|,
name|role
argument_list|,
name|serviceReference
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|// The current user does not have the required roles to invoke the service.
name|LOG
operator|.
name|info
argument_list|(
literal|"Current user does not have required roles ({}) for service {} method {} and/or arguments"
argument_list|,
name|allowedRoles
argument_list|,
name|serviceReference
argument_list|,
name|m
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SecurityException
argument_list|(
literal|"Insufficient credentials."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|postInvokeExceptionalReturn
parameter_list|(
name|Object
name|token
parameter_list|,
name|Object
name|proxy
parameter_list|,
name|Method
name|m
parameter_list|,
name|Throwable
name|exception
parameter_list|)
throws|throws
name|Throwable
block|{         }
annotation|@
name|Override
specifier|public
name|void
name|postInvoke
parameter_list|(
name|Object
name|token
parameter_list|,
name|Object
name|proxy
parameter_list|,
name|Method
name|m
parameter_list|,
name|Object
name|returnValue
parameter_list|)
throws|throws
name|Throwable
block|{         }
block|}
comment|// This customizer comes into action as the ProxyManager service arrives.
class|class
name|ServiceProxyCreatorCustomizer
implements|implements
name|ServiceTrackerCustomizer
argument_list|<
name|ProxyManager
argument_list|,
name|ProxyManager
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|ProxyManager
name|addingService
parameter_list|(
name|ServiceReference
argument_list|<
name|ProxyManager
argument_list|>
name|reference
parameter_list|)
block|{
name|runProxyCreator
operator|=
literal|true
expr_stmt|;
specifier|final
name|ProxyManager
name|svc
init|=
name|myBundleContext
operator|.
name|getService
argument_list|(
name|reference
argument_list|)
decl_stmt|;
if|if
condition|(
name|proxyCreatorThread
operator|==
literal|null
operator|&&
name|svc
operator|!=
literal|null
condition|)
block|{
name|proxyCreatorThread
operator|=
name|newProxyProducingThread
argument_list|(
name|svc
argument_list|)
expr_stmt|;
block|}
return|return
name|svc
return|;
block|}
specifier|private
name|Thread
name|newProxyProducingThread
parameter_list|(
specifier|final
name|ProxyManager
name|proxyManager
parameter_list|)
block|{
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|runProxyCreator
condition|)
block|{
name|CreateProxyRunnable
name|proxyCreator
init|=
literal|null
decl_stmt|;
try|try
block|{
name|proxyCreator
operator|=
name|createProxyQueue
operator|.
name|take
argument_list|()
expr_stmt|;
comment|// take waits until there is something on the queue
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// part of normal behaviour
block|}
if|if
condition|(
name|proxyCreator
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|proxyCreator
operator|.
name|run
argument_list|(
name|proxyManager
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Problem creating secured service proxy"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// finished running
name|proxyCreatorThread
operator|=
literal|null
expr_stmt|;
block|}
block|}
argument_list|)
decl_stmt|;
name|t
operator|.
name|setName
argument_list|(
name|PROXY_CREATOR_THREAD_NAME
argument_list|)
expr_stmt|;
name|t
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|modifiedService
parameter_list|(
name|ServiceReference
argument_list|<
name|ProxyManager
argument_list|>
name|reference
parameter_list|,
name|ProxyManager
name|service
parameter_list|)
block|{
comment|// no need to react
block|}
annotation|@
name|Override
specifier|public
name|void
name|removedService
parameter_list|(
name|ServiceReference
argument_list|<
name|ProxyManager
argument_list|>
name|reference
parameter_list|,
name|ProxyManager
name|service
parameter_list|)
block|{
name|stopProxyCreator
argument_list|()
expr_stmt|;
block|}
block|}
interface|interface
name|CreateProxyRunnable
block|{
name|long
name|getOriginalServiceID
parameter_list|()
function_decl|;
name|void
name|run
parameter_list|(
name|ProxyManager
name|pm
parameter_list|)
throws|throws
name|Exception
function_decl|;
block|}
block|}
end_class

end_unit

