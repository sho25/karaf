begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) OSGi Alliance (2005, 2010). All Rights Reserved.  *   * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|condpermadmin
package|;
end_package

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|cert
operator|.
name|X509Certificate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|Bundle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|FrameworkUtil
import|;
end_import

begin_comment
comment|/**  * Condition to test if the signer of a bundle matches or does not match a  * pattern. Since the bundle's signer can only change when the bundle is  * updated, this condition is immutable.  *<p>  * The condition expressed using a single String that specifies a Distinguished  * Name (DN) chain to match bundle signers against. DN's are encoded using IETF  * RFC 2253. Usually signers use certificates that are issued by certificate  * authorities, which also have a corresponding DN and certificate. The  * certificate authorities can form a chain of trust where the last DN and  * certificate is known by the framework. The signer of a bundle is expressed as  * signers DN followed by the DN of its issuer followed by the DN of the next  * issuer until the DN of the root certificate authority. Each DN is separated  * by a semicolon.  *<p>  * A bundle can satisfy this condition if one of its signers has a DN chain that  * matches the DN chain used to construct this condition. Wildcards (`*') can be  * used to allow greater flexibility in specifying the DN chains. Wildcards can  * be used in place of DNs, RDNs, or the value in an RDN. If a wildcard is used  * for a value of an RDN, the value must be exactly "*" and will match any value  * for the corresponding type in that RDN. If a wildcard is used for a RDN, it  * must be the first RDN and will match any number of RDNs (including zero  * RDNs).  *   * @ThreadSafe  * @version $Id: 6e10febd6a8cfc31973ece0af29c352ed972b105 $  */
end_comment

begin_class
specifier|public
class|class
name|BundleSignerCondition
block|{
specifier|private
specifier|static
specifier|final
name|String
name|CONDITION_TYPE
init|=
literal|"org.osgi.service.condpermadmin.BundleSignerCondition"
decl_stmt|;
comment|/** 	 * Constructs a Condition that tries to match the passed Bundle's location 	 * to the location pattern. 	 *  	 * @param bundle The Bundle being evaluated. 	 * @param info The ConditionInfo from which to construct the condition. The 	 *        ConditionInfo must specify one or two arguments. The first 	 *        argument of the ConditionInfo specifies the chain of distinguished 	 *        names pattern to match against the signer of the bundle. The 	 *        Condition is satisfied if the signer of the bundle matches the 	 *        pattern. The second argument of the ConditionInfo is optional. If 	 *        a second argument is present and equal to "!", then the 	 *        satisfaction of the Condition is negated. That is, the Condition 	 *        is satisfied if the signer of the bundle does NOT match the 	 *        pattern. If the second argument is present but does not equal "!", 	 *        then the second argument is ignored. 	 * @return A Condition which checks the signers of the specified bundle. 	 */
specifier|public
specifier|static
name|Condition
name|getCondition
parameter_list|(
specifier|final
name|Bundle
name|bundle
parameter_list|,
specifier|final
name|ConditionInfo
name|info
parameter_list|)
block|{
if|if
condition|(
operator|!
name|CONDITION_TYPE
operator|.
name|equals
argument_list|(
name|info
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ConditionInfo must be of type \""
operator|+
name|CONDITION_TYPE
operator|+
literal|"\""
argument_list|)
throw|;
name|String
index|[]
name|args
init|=
name|info
operator|.
name|getArgs
argument_list|()
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|length
operator|!=
literal|1
operator|&&
name|args
operator|.
name|length
operator|!=
literal|2
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal number of args: "
operator|+
name|args
operator|.
name|length
argument_list|)
throw|;
name|Map
argument_list|<
name|X509Certificate
argument_list|,
name|List
argument_list|<
name|X509Certificate
argument_list|>
argument_list|>
name|signers
init|=
name|bundle
operator|.
name|getSignerCertificates
argument_list|(
name|Bundle
operator|.
name|SIGNERS_TRUSTED
argument_list|)
decl_stmt|;
name|boolean
name|match
init|=
literal|false
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|X509Certificate
argument_list|>
name|signerCerts
range|:
name|signers
operator|.
name|values
argument_list|()
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|dnChain
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|signerCerts
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|X509Certificate
name|signer
range|:
name|signerCerts
control|)
block|{
name|dnChain
operator|.
name|add
argument_list|(
name|signer
operator|.
name|getSubjectDN
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FrameworkUtil
operator|.
name|matchDistinguishedNameChain
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|dnChain
argument_list|)
condition|)
block|{
name|match
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
name|boolean
name|negate
init|=
operator|(
name|args
operator|.
name|length
operator|==
literal|2
operator|)
condition|?
literal|"!"
operator|.
name|equals
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
else|:
literal|false
decl_stmt|;
return|return
name|negate
operator|^
name|match
condition|?
name|Condition
operator|.
name|TRUE
else|:
name|Condition
operator|.
name|FALSE
return|;
block|}
specifier|private
name|BundleSignerCondition
parameter_list|()
block|{
comment|// private constructor to prevent objects of this type
block|}
block|}
end_class

end_unit

