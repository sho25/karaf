begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) OSGi Alliance (2005, 2010). All Rights Reserved.  *   * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|osgi
operator|.
name|framework
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|AccessibleObject
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessController
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Dictionary
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|x500
operator|.
name|X500Principal
import|;
end_import

begin_comment
comment|/**  * Framework Utility class.  *   *<p>  * This class contains utility methods which access Framework functions that may  * be useful to bundles.  *   * @since 1.3  * @ThreadSafe  * @version $Id: a902bc156ea997ed244831c7fab0f290a08ac0c1 $  */
end_comment

begin_class
specifier|public
class|class
name|FrameworkUtil
block|{
comment|/** 	 * FrameworkUtil objects may not be constructed. 	 */
specifier|private
name|FrameworkUtil
parameter_list|()
block|{
comment|// private empty constructor to prevent construction
block|}
comment|/** 	 * Creates a {@code Filter} object. This {@code Filter} object may 	 * be used to match a {@code ServiceReference} object or a 	 * {@code Dictionary} object. 	 *  	 *<p> 	 * If the filter cannot be parsed, an {@link InvalidSyntaxException} will be 	 * thrown with a human readable message where the filter became unparsable. 	 *  	 *<p> 	 * This method returns a Filter implementation which may not perform as well 	 * as the framework implementation-specific Filter implementation returned 	 * by {@link BundleContext#createFilter(String)}. 	 *  	 * @param filter The filter string. 	 * @return A {@code Filter} object encapsulating the filter string. 	 * @throws InvalidSyntaxException If {@code filter} contains an invalid 	 *         filter string that cannot be parsed. 	 * @throws NullPointerException If {@code filter} is null. 	 *  	 * @see Filter 	 */
specifier|public
specifier|static
name|Filter
name|createFilter
parameter_list|(
name|String
name|filter
parameter_list|)
throws|throws
name|InvalidSyntaxException
block|{
return|return
name|FilterImpl
operator|.
name|newInstance
argument_list|(
name|filter
argument_list|)
return|;
block|}
comment|/** 	 * Match a Distinguished Name (DN) chain against a pattern. DNs can be 	 * matched using wildcards. A wildcard ('*'&#92;u002A) replaces all 	 * possible values. Due to the structure of the DN, the comparison is more 	 * complicated than string-based wildcard matching. 	 *<p> 	 * A wildcard can stand for zero or more DNs in a chain, a number of 	 * relative distinguished names (RDNs) within a DN, or the value of a single 	 * RDN. The DNs in the chain and the matching pattern are canonicalized 	 * before processing. This means, among other things, that spaces must be 	 * ignored, except in values. 	 *<p> 	 * The format of a wildcard match pattern is: 	 *  	 *<pre> 	 * matchPattern	::= dn-match ( ';' dn-match ) * 	 * dn-match 	::= ( '*' | rdn-match ) ( ',' rdn-match ) * | '-' 	 * rdn-match 	::= name '=' value-match 	 * value-match 	::= '*' | value-star 	 * value-star 	::=&lt; value, requires escaped '*' and '-'&gt; 	 *</pre> 	 *<p> 	 * The most simple case is a single wildcard; it must match any DN. A 	 * wildcard can also replace the first list of RDNs of a DN. The first RDNs 	 * are the least significant. Such lists of matched RDNs can be empty. 	 *<p> 	 * For example, a match pattern with a wildcard that matches all DNs that 	 * end with RDNs of o=ACME and c=US would look like this: 	 *  	 *<pre> 	 * *, o=ACME, c=US 	 *</pre> 	 *  	 * This match pattern would match the following DNs: 	 *  	 *<pre> 	 * cn = Bugs Bunny, o = ACME, c = US 	 * ou = Carrots, cn=Daffy Duck, o=ACME, c=US 	 * street = 9C\, Avenue St. Drézéry, o=ACME, c=US 	 * dc=www, dc=acme, dc=com, o=ACME, c=US 	 * o=ACME, c=US 	 *</pre> 	 *  	 * The following DNs would not match: 	 *  	 *<pre> 	 * street = 9C\, Avenue St. Drézéry, o=ACME, c=FR 	 * dc=www, dc=acme, dc=com, c=US 	 *</pre> 	 *  	 * If a wildcard is used for a value of an RDN, the value must be exactly *. 	 * The wildcard must match any value, and no substring matching must be 	 * done. For example: 	 *  	 *<pre> 	 * cn=*,o=ACME,c=* 	 *</pre> 	 *  	 * This match pattern with wildcard must match the following DNs: 	 *  	 *<pre> 	 * cn=Bugs Bunny,o=ACME,c=US 	 * cn = Daffy Duck , o = ACME , c = US 	 * cn=Road Runner, o=ACME, c=NL 	 *</pre> 	 *  	 * But not: 	 *  	 *<pre> 	 * o=ACME, c=NL 	 * dc=acme.com, cn=Bugs Bunny, o=ACME, c=US 	 *</pre> 	 *  	 *<p> 	 * A match pattern may contain a chain of DN match patterns. The 	 * semicolon(';'&#92;u003B) must be used to separate DN match patterns in a 	 * chain. Wildcards can also be used to match against a complete DN within a 	 * chain. 	 *<p> 	 * The following example matches a certificate signed by Tweety Inc. in the 	 * US. 	 *</p> 	 *  	 *<pre> 	 * * ; ou=S&amp; V, o=Tweety Inc., c=US 	 *</pre> 	 *<p> 	 * The wildcard ('*') matches zero or one DN in the chain, however, 	 * sometimes it is necessary to match a longer chain. The minus sign ('-' 	 *&#92;u002D) represents zero or more DNs, whereas the asterisk only 	 * represents a single DN. For example, to match a DN where the Tweety Inc. 	 * is in the DN chain, use the following expression: 	 *</p> 	 *  	 *<pre> 	 * - ; *, o=Tweety Inc., c=US 	 *</pre> 	 *  	 * @param matchPattern The pattern against which to match the DN chain. 	 * @param dnChain The DN chain to match against the specified pattern. Each 	 *        element of the chain must be of type {@code String} and use the 	 *        format defined in<a 	 *        href="http://www.ietf.org/rfc/rfc2253.txt">RFC 2253</a>. 	 * @return {@code true} If the pattern matches the DN chain; otherwise 	 *         {@code false} is returned. 	 * @throws IllegalArgumentException If the specified match pattern or DN 	 *         chain is invalid. 	 * @since 1.5 	 */
specifier|public
specifier|static
name|boolean
name|matchDistinguishedNameChain
parameter_list|(
name|String
name|matchPattern
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|dnChain
parameter_list|)
block|{
return|return
name|DNChainMatching
operator|.
name|match
argument_list|(
name|matchPattern
argument_list|,
name|dnChain
argument_list|)
return|;
block|}
comment|/** 	 * Return a {@code Bundle} for the specified bundle class. The returned 	 * {@code Bundle} is the bundle associated with the bundle class loader 	 * which defined the specified class. 	 *  	 * @param classFromBundle A class defined by a bundle class loader. 	 * @return A {@code Bundle} for the specified bundle class or 	 *         {@code null} if the specified class was not defined by a 	 *         bundle class loader. 	 * @since 1.5 	 */
specifier|public
specifier|static
name|Bundle
name|getBundle
parameter_list|(
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|classFromBundle
parameter_list|)
block|{
comment|// We use doPriv since the caller may not have permission
comment|// to call getClassLoader.
name|Object
name|cl
init|=
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|run
parameter_list|()
block|{
return|return
name|classFromBundle
operator|.
name|getClassLoader
argument_list|()
return|;
block|}
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
name|cl
operator|instanceof
name|BundleReference
condition|)
block|{
return|return
operator|(
operator|(
name|BundleReference
operator|)
name|cl
operator|)
operator|.
name|getBundle
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 * RFC 1960-based Filter. Filter objects can be created by calling the 	 * constructor with the desired filter string. A Filter object can be called 	 * numerous times to determine if the match argument matches the filter 	 * string that was used to create the Filter object. 	 *  	 *<p> 	 * The syntax of a filter string is the string representation of LDAP search 	 * filters as defined in RFC 1960:<i>A String Representation of LDAP Search 	 * Filters</i> (available at http://www.ietf.org/rfc/rfc1960.txt). It should 	 * be noted that RFC 2254:<i>A String Representation of LDAP Search 	 * Filters</i> (available at http://www.ietf.org/rfc/rfc2254.txt) supersedes 	 * RFC 1960 but only adds extensible matching and is not applicable for this 	 * API. 	 *  	 *<p> 	 * The string representation of an LDAP search filter is defined by the 	 * following grammar. It uses a prefix format. 	 *  	 *<pre> 	 *&lt;filter&gt; ::= '('&lt;filtercomp&gt; ')' 	 *&lt;filtercomp&gt; ::=&lt;and&gt; |&lt;or&gt; |&lt;not&gt; |&lt;item&gt; 	 *&lt;and&gt; ::= '&amp;'&lt;filterlist&gt; 	 *&lt;or&gt; ::= '|'&lt;filterlist&gt; 	 *&lt;not&gt; ::= '!'&lt;filter&gt; 	 *&lt;filterlist&gt; ::=&lt;filter&gt; |&lt;filter&gt;&lt;filterlist&gt; 	 *&lt;item&gt; ::=&lt;simple&gt; |&lt;present&gt; |&lt;substring&gt; 	 *&lt;simple&gt; ::=&lt;attr&gt;&lt;filtertype&gt;&lt;value&gt; 	 *&lt;filtertype&gt; ::=&lt;equal&gt; |&lt;approx&gt; |&lt;greater&gt; |&lt;less&gt; 	 *&lt;equal&gt; ::= '=' 	 *&lt;approx&gt; ::= '&tilde;=' 	 *&lt;greater&gt; ::= '&gt;=' 	 *&lt;less&gt; ::= '&lt;=' 	 *&lt;present&gt; ::=&lt;attr&gt; '=*' 	 *&lt;substring&gt; ::=&lt;attr&gt; '='&lt;initial&gt;&lt;any&gt;&lt;final&gt; 	 *&lt;initial&gt; ::= NULL |&lt;value&gt; 	 *&lt;any&gt; ::= '*'&lt;starval&gt; 	 *&lt;starval&gt; ::= NULL |&lt;value&gt; '*'&lt;starval&gt; 	 *&lt;final&gt; ::= NULL |&lt;value&gt; 	 *</pre> 	 *  	 * {@code&lt;attr&gt;} is a string representing an attribute, or key, 	 * in the properties objects of the registered services. Attribute names are 	 * not case sensitive; that is cn and CN both refer to the same attribute. 	 * {@code&lt;value&gt;} is a string representing the value, or part of 	 * one, of a key in the properties objects of the registered services. If a 	 * {@code&lt;value&gt;} must contain one of the characters ' 	 * {@code *}' or '{@code (}' or '{@code )}', these characters 	 * should be escaped by preceding them with the backslash '{@code \}' 	 * character. Note that although both the {@code&lt;substring&gt;} and 	 * {@code&lt;present&gt;} productions can produce the {@code 'attr=*'} 	 * construct, this construct is used only to denote a presence filter. 	 *  	 *<p> 	 * Examples of LDAP filters are: 	 *  	 *<pre> 	 *&quot;(cn=Babs Jensen)&quot; 	 *&quot;(!(cn=Tim Howes))&quot; 	 *&quot;(&amp;(&quot; + Constants.OBJECTCLASS +&quot;=Person)(|(sn=Jensen)(cn=Babs J*)))&quot; 	 *&quot;(o=univ*of*mich*)&quot; 	 *</pre> 	 *  	 *<p> 	 * The approximate match ({@code ~=}) is implementation specific but 	 * should at least ignore case and white space differences. Optional are 	 * codes like soundex or other smart "closeness" comparisons. 	 *  	 *<p> 	 * Comparison of values is not straightforward. Strings are compared 	 * differently than numbers and it is possible for a key to have multiple 	 * values. Note that that keys in the match argument must always be strings. 	 * The comparison is defined by the object type of the key's value. The 	 * following rules apply for comparison: 	 *  	 *<blockquote> 	 *<TABLE BORDER=0> 	 *<TR> 	 *<TD><b>Property Value Type</b></TD> 	 *<TD><b>Comparison Type</b></TD> 	 *</TR> 	 *<TR> 	 *<TD>String</TD> 	 *<TD>String comparison</TD> 	 *</TR> 	 *<TR valign=top> 	 *<TD>Integer, Long, Float, Double, Byte, Short, BigInteger, BigDecimal</TD> 	 *<TD>numerical comparison</TD> 	 *</TR> 	 *<TR> 	 *<TD>Character</TD> 	 *<TD>character comparison</TD> 	 *</TR> 	 *<TR> 	 *<TD>Boolean</TD> 	 *<TD>equality comparisons only</TD> 	 *</TR> 	 *<TR> 	 *<TD>[] (array)</TD> 	 *<TD>recursively applied to values</TD> 	 *</TR> 	 *<TR> 	 *<TD>Collection</TD> 	 *<TD>recursively applied to values</TD> 	 *</TR> 	 *</TABLE> 	 * Note: arrays of primitives are also supported.</blockquote> 	 *  	 * A filter matches a key that has multiple values if it matches at least 	 * one of those values. For example, 	 *  	 *<pre> 	 * Dictionary d = new Hashtable(); 	 * d.put(&quot;cn&quot;, new String[] {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}); 	 *</pre> 	 *  	 * d will match {@code (cn=a)} and also {@code (cn=b)} 	 *  	 *<p> 	 * A filter component that references a key having an unrecognizable data 	 * type will evaluate to {@code false} . 	 */
specifier|static
specifier|private
specifier|final
class|class
name|FilterImpl
implements|implements
name|Filter
block|{
comment|/* filter operators */
specifier|private
specifier|static
specifier|final
name|int
name|EQUAL
init|=
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|APPROX
init|=
literal|2
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|GREATER
init|=
literal|3
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|LESS
init|=
literal|4
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|PRESENT
init|=
literal|5
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|SUBSTRING
init|=
literal|6
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|AND
init|=
literal|7
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|OR
init|=
literal|8
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|NOT
init|=
literal|9
decl_stmt|;
comment|/** filter operation */
specifier|private
specifier|final
name|int
name|op
decl_stmt|;
comment|/** filter attribute or null if operation AND, OR or NOT */
specifier|private
specifier|final
name|String
name|attr
decl_stmt|;
comment|/** filter operands */
specifier|private
specifier|final
name|Object
name|value
decl_stmt|;
comment|/* normalized filter string for Filter object */
specifier|private
specifier|transient
name|String
name|filterString
decl_stmt|;
comment|/** 		 * Constructs a {@link FilterImpl} object. This filter object may be 		 * used to match a {@link ServiceReference} or a Dictionary. 		 *  		 *<p> 		 * If the filter cannot be parsed, an {@link InvalidSyntaxException} 		 * will be thrown with a human readable message where the filter became 		 * unparsable. 		 *  		 * @param filterString the filter string. 		 * @throws InvalidSyntaxException If the filter parameter contains an 		 *            invalid filter string that cannot be parsed. 		 */
specifier|static
name|FilterImpl
name|newInstance
parameter_list|(
name|String
name|filterString
parameter_list|)
throws|throws
name|InvalidSyntaxException
block|{
return|return
operator|new
name|Parser
argument_list|(
name|filterString
argument_list|)
operator|.
name|parse
argument_list|()
return|;
block|}
name|FilterImpl
parameter_list|(
name|int
name|operation
parameter_list|,
name|String
name|attr
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|this
operator|.
name|op
operator|=
name|operation
expr_stmt|;
name|this
operator|.
name|attr
operator|=
name|attr
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|filterString
operator|=
literal|null
expr_stmt|;
block|}
comment|/** 		 * Filter using a service's properties. 		 *<p> 		 * This {@code Filter} is executed using the keys and values of the 		 * referenced service's properties. The keys are looked up in a case 		 * insensitive manner. 		 *  		 * @param reference The reference to the service whose properties are 		 *        used in the match. 		 * @return {@code true} if the service's properties match this 		 *         {@code Filter}; {@code false} otherwise. 		 */
specifier|public
name|boolean
name|match
parameter_list|(
name|ServiceReference
argument_list|<
name|?
argument_list|>
name|reference
parameter_list|)
block|{
return|return
name|matches
argument_list|(
operator|new
name|ServiceReferenceMap
argument_list|(
name|reference
argument_list|)
argument_list|)
return|;
block|}
comment|/** 		 * Filter using a {@code Dictionary} with case insensitive key lookup. 		 * This {@code Filter} is executed using the specified 		 * {@code Dictionary}'s keys and values. The keys are looked up in a 		 * case insensitive manner. 		 *  		 * @param dictionary The {@code Dictionary} whose key/value pairs are 		 *        used in the match. 		 * @return {@code true} if the {@code Dictionary}'s values match this 		 *         filter; {@code false} otherwise. 		 * @throws IllegalArgumentException If {@code dictionary} contains case 		 *         variants of the same key name. 		 */
specifier|public
name|boolean
name|match
parameter_list|(
name|Dictionary
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|dictionary
parameter_list|)
block|{
return|return
name|matches
argument_list|(
operator|new
name|CaseInsensitiveMap
argument_list|(
name|dictionary
argument_list|)
argument_list|)
return|;
block|}
comment|/** 		 * Filter using a {@code Dictionary}. This {@code Filter} is executed 		 * using the specified {@code Dictionary}'s keys and values. The keys 		 * are looked up in a normal manner respecting case. 		 *  		 * @param dictionary The {@code Dictionary} whose key/value pairs are 		 *        used in the match. 		 * @return {@code true} if the {@code Dictionary}'s values match this 		 *         filter; {@code false} otherwise. 		 * @since 1.3 		 */
specifier|public
name|boolean
name|matchCase
parameter_list|(
name|Dictionary
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|dictionary
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|AND
case|:
block|{
name|FilterImpl
index|[]
name|filters
init|=
operator|(
name|FilterImpl
index|[]
operator|)
name|value
decl_stmt|;
for|for
control|(
name|FilterImpl
name|f
range|:
name|filters
control|)
block|{
if|if
condition|(
operator|!
name|f
operator|.
name|matchCase
argument_list|(
name|dictionary
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
case|case
name|OR
case|:
block|{
name|FilterImpl
index|[]
name|filters
init|=
operator|(
name|FilterImpl
index|[]
operator|)
name|value
decl_stmt|;
for|for
control|(
name|FilterImpl
name|f
range|:
name|filters
control|)
block|{
if|if
condition|(
name|f
operator|.
name|matchCase
argument_list|(
name|dictionary
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
case|case
name|NOT
case|:
block|{
name|FilterImpl
name|filter
init|=
operator|(
name|FilterImpl
operator|)
name|value
decl_stmt|;
return|return
operator|!
name|filter
operator|.
name|matchCase
argument_list|(
name|dictionary
argument_list|)
return|;
block|}
case|case
name|SUBSTRING
case|:
case|case
name|EQUAL
case|:
case|case
name|GREATER
case|:
case|case
name|LESS
case|:
case|case
name|APPROX
case|:
block|{
name|Object
name|prop
init|=
operator|(
name|dictionary
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|dictionary
operator|.
name|get
argument_list|(
name|attr
argument_list|)
decl_stmt|;
return|return
name|compare
argument_list|(
name|op
argument_list|,
name|prop
argument_list|,
name|value
argument_list|)
return|;
block|}
case|case
name|PRESENT
case|:
block|{
name|Object
name|prop
init|=
operator|(
name|dictionary
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|dictionary
operator|.
name|get
argument_list|(
name|attr
argument_list|)
decl_stmt|;
return|return
name|prop
operator|!=
literal|null
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** 		 * Filter using a {@code Map}. This {@code Filter} is executed using the 		 * specified {@code Map}'s keys and values. The keys are looked up in a 		 * normal manner respecting case. 		 *  		 * @param map The {@code Map} whose key/value pairs are used in the 		 *        match. Maps with {@code null} key or values are not supported. 		 *        A {@code null} value is considered not present to the filter. 		 * @return {@code true} if the {@code Map}'s values match this filter; 		 *         {@code false} otherwise. 		 * @since 1.6 		 */
specifier|public
name|boolean
name|matches
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|map
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|AND
case|:
block|{
name|FilterImpl
index|[]
name|filters
init|=
operator|(
name|FilterImpl
index|[]
operator|)
name|value
decl_stmt|;
for|for
control|(
name|FilterImpl
name|f
range|:
name|filters
control|)
block|{
if|if
condition|(
operator|!
name|f
operator|.
name|matches
argument_list|(
name|map
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
case|case
name|OR
case|:
block|{
name|FilterImpl
index|[]
name|filters
init|=
operator|(
name|FilterImpl
index|[]
operator|)
name|value
decl_stmt|;
for|for
control|(
name|FilterImpl
name|f
range|:
name|filters
control|)
block|{
if|if
condition|(
name|f
operator|.
name|matches
argument_list|(
name|map
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
case|case
name|NOT
case|:
block|{
name|FilterImpl
name|filter
init|=
operator|(
name|FilterImpl
operator|)
name|value
decl_stmt|;
return|return
operator|!
name|filter
operator|.
name|matches
argument_list|(
name|map
argument_list|)
return|;
block|}
case|case
name|SUBSTRING
case|:
case|case
name|EQUAL
case|:
case|case
name|GREATER
case|:
case|case
name|LESS
case|:
case|case
name|APPROX
case|:
block|{
name|Object
name|prop
init|=
operator|(
name|map
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|map
operator|.
name|get
argument_list|(
name|attr
argument_list|)
decl_stmt|;
return|return
name|compare
argument_list|(
name|op
argument_list|,
name|prop
argument_list|,
name|value
argument_list|)
return|;
block|}
case|case
name|PRESENT
case|:
block|{
name|Object
name|prop
init|=
operator|(
name|map
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|map
operator|.
name|get
argument_list|(
name|attr
argument_list|)
decl_stmt|;
return|return
name|prop
operator|!=
literal|null
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** 		 * Returns this {@code Filter}'s filter string. 		 *<p> 		 * The filter string is normalized by removing whitespace which does not 		 * affect the meaning of the filter. 		 *  		 * @return This {@code Filter}'s filter string. 		 */
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|result
init|=
name|filterString
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|filterString
operator|=
name|result
operator|=
name|normalize
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/** 		 * Returns this {@code Filter}'s normalized filter string. 		 *<p> 		 * The filter string is normalized by removing whitespace which does not 		 * affect the meaning of the filter. 		 *  		 * @return This {@code Filter}'s filter string. 		 */
specifier|private
name|StringBuffer
name|normalize
parameter_list|()
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|AND
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
name|FilterImpl
index|[]
name|filters
init|=
operator|(
name|FilterImpl
index|[]
operator|)
name|value
decl_stmt|;
for|for
control|(
name|FilterImpl
name|f
range|:
name|filters
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|f
operator|.
name|normalize
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|OR
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
name|FilterImpl
index|[]
name|filters
init|=
operator|(
name|FilterImpl
index|[]
operator|)
name|value
decl_stmt|;
for|for
control|(
name|FilterImpl
name|f
range|:
name|filters
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|f
operator|.
name|normalize
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|NOT
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
name|FilterImpl
name|filter
init|=
operator|(
name|FilterImpl
operator|)
name|value
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|filter
operator|.
name|normalize
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SUBSTRING
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|String
index|[]
name|substrings
init|=
operator|(
name|String
index|[]
operator|)
name|value
decl_stmt|;
for|for
control|(
name|String
name|substr
range|:
name|substrings
control|)
block|{
if|if
condition|(
name|substr
operator|==
literal|null
condition|)
comment|/* * */
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* xxx */
block|{
name|sb
operator|.
name|append
argument_list|(
name|encodeValue
argument_list|(
name|substr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|EQUAL
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|encodeValue
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|GREATER
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|">="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|encodeValue
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LESS
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"<="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|encodeValue
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|APPROX
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"~="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|encodeValue
argument_list|(
name|approxString
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PRESENT
case|:
block|{
name|sb
operator|.
name|append
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"=*"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return
name|sb
return|;
block|}
comment|/** 		 * Compares this {@code Filter} to another {@code Filter}. 		 *  		 *<p> 		 * This implementation returns the result of calling 		 * {@code this.toString().equals(obj.toString()}. 		 *  		 * @param obj The object to compare against this {@code Filter}. 		 * @return If the other object is a {@code Filter} object, then 		 *         returns the result of calling 		 *         {@code this.toString().equals(obj.toString()}; 		 *         {@code false} otherwise. 		 */
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|Filter
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|this
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|obj
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/** 		 * Returns the hashCode for this {@code Filter}. 		 *  		 *<p> 		 * This implementation returns the result of calling 		 * {@code this.toString().hashCode()}. 		 *  		 * @return The hashCode of this {@code Filter}. 		 */
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|toString
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/** 		 * Encode the value string such that '(', '*', ')' and '\' are escaped. 		 *  		 * @param value unencoded value string. 		 * @return encoded value string. 		 */
specifier|private
specifier|static
name|String
name|encodeValue
parameter_list|(
name|String
name|value
parameter_list|)
block|{
name|boolean
name|encoded
init|=
literal|false
decl_stmt|;
name|int
name|inlen
init|=
name|value
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|outlen
init|=
name|inlen
operator|<<
literal|1
decl_stmt|;
comment|/* inlen 2 */
name|char
index|[]
name|output
init|=
operator|new
name|char
index|[
name|outlen
index|]
decl_stmt|;
name|value
operator|.
name|getChars
argument_list|(
literal|0
argument_list|,
name|inlen
argument_list|,
name|output
argument_list|,
name|inlen
argument_list|)
expr_stmt|;
name|int
name|cursor
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|inlen
init|;
name|i
operator|<
name|outlen
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|output
index|[
name|i
index|]
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
case|case
literal|'*'
case|:
case|case
literal|')'
case|:
case|case
literal|'\\'
case|:
block|{
name|output
index|[
name|cursor
index|]
operator|=
literal|'\\'
expr_stmt|;
name|cursor
operator|++
expr_stmt|;
name|encoded
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
name|output
index|[
name|cursor
index|]
operator|=
name|c
expr_stmt|;
name|cursor
operator|++
expr_stmt|;
block|}
return|return
name|encoded
condition|?
operator|new
name|String
argument_list|(
name|output
argument_list|,
literal|0
argument_list|,
name|cursor
argument_list|)
else|:
name|value
return|;
block|}
specifier|private
name|boolean
name|compare
parameter_list|(
name|int
name|operation
parameter_list|,
name|Object
name|value1
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
if|if
condition|(
name|value1
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|value1
operator|instanceof
name|String
condition|)
block|{
return|return
name|compare_String
argument_list|(
name|operation
argument_list|,
operator|(
name|String
operator|)
name|value1
argument_list|,
name|value2
argument_list|)
return|;
block|}
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|value1
operator|.
name|getClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|clazz
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|type
init|=
name|clazz
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isPrimitive
argument_list|()
condition|)
block|{
return|return
name|compare_PrimitiveArray
argument_list|(
name|operation
argument_list|,
name|type
argument_list|,
name|value1
argument_list|,
name|value2
argument_list|)
return|;
block|}
return|return
name|compare_ObjectArray
argument_list|(
name|operation
argument_list|,
operator|(
name|Object
index|[]
operator|)
name|value1
argument_list|,
name|value2
argument_list|)
return|;
block|}
if|if
condition|(
name|value1
operator|instanceof
name|Collection
argument_list|<
name|?
argument_list|>
condition|)
block|{
return|return
name|compare_Collection
argument_list|(
name|operation
argument_list|,
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|value1
argument_list|,
name|value2
argument_list|)
return|;
block|}
if|if
condition|(
name|value1
operator|instanceof
name|Integer
condition|)
block|{
return|return
name|compare_Integer
argument_list|(
name|operation
argument_list|,
operator|(
operator|(
name|Integer
operator|)
name|value1
operator|)
operator|.
name|intValue
argument_list|()
argument_list|,
name|value2
argument_list|)
return|;
block|}
if|if
condition|(
name|value1
operator|instanceof
name|Long
condition|)
block|{
return|return
name|compare_Long
argument_list|(
name|operation
argument_list|,
operator|(
operator|(
name|Long
operator|)
name|value1
operator|)
operator|.
name|longValue
argument_list|()
argument_list|,
name|value2
argument_list|)
return|;
block|}
if|if
condition|(
name|value1
operator|instanceof
name|Byte
condition|)
block|{
return|return
name|compare_Byte
argument_list|(
name|operation
argument_list|,
operator|(
operator|(
name|Byte
operator|)
name|value1
operator|)
operator|.
name|byteValue
argument_list|()
argument_list|,
name|value2
argument_list|)
return|;
block|}
if|if
condition|(
name|value1
operator|instanceof
name|Short
condition|)
block|{
return|return
name|compare_Short
argument_list|(
name|operation
argument_list|,
operator|(
operator|(
name|Short
operator|)
name|value1
operator|)
operator|.
name|shortValue
argument_list|()
argument_list|,
name|value2
argument_list|)
return|;
block|}
if|if
condition|(
name|value1
operator|instanceof
name|Character
condition|)
block|{
return|return
name|compare_Character
argument_list|(
name|operation
argument_list|,
operator|(
operator|(
name|Character
operator|)
name|value1
operator|)
operator|.
name|charValue
argument_list|()
argument_list|,
name|value2
argument_list|)
return|;
block|}
if|if
condition|(
name|value1
operator|instanceof
name|Float
condition|)
block|{
return|return
name|compare_Float
argument_list|(
name|operation
argument_list|,
operator|(
operator|(
name|Float
operator|)
name|value1
operator|)
operator|.
name|floatValue
argument_list|()
argument_list|,
name|value2
argument_list|)
return|;
block|}
if|if
condition|(
name|value1
operator|instanceof
name|Double
condition|)
block|{
return|return
name|compare_Double
argument_list|(
name|operation
argument_list|,
operator|(
operator|(
name|Double
operator|)
name|value1
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|,
name|value2
argument_list|)
return|;
block|}
if|if
condition|(
name|value1
operator|instanceof
name|Boolean
condition|)
block|{
return|return
name|compare_Boolean
argument_list|(
name|operation
argument_list|,
operator|(
operator|(
name|Boolean
operator|)
name|value1
operator|)
operator|.
name|booleanValue
argument_list|()
argument_list|,
name|value2
argument_list|)
return|;
block|}
if|if
condition|(
name|value1
operator|instanceof
name|Comparable
argument_list|<
name|?
argument_list|>
condition|)
block|{
name|Comparable
argument_list|<
name|Object
argument_list|>
name|comparable
init|=
operator|(
name|Comparable
argument_list|<
name|Object
argument_list|>
operator|)
name|value1
decl_stmt|;
return|return
name|compare_Comparable
argument_list|(
name|operation
argument_list|,
name|comparable
argument_list|,
name|value2
argument_list|)
return|;
block|}
return|return
name|compare_Unknown
argument_list|(
name|operation
argument_list|,
name|value1
argument_list|,
name|value2
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|compare_Collection
parameter_list|(
name|int
name|operation
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
for|for
control|(
name|Object
name|value1
range|:
name|collection
control|)
block|{
if|if
condition|(
name|compare
argument_list|(
name|operation
argument_list|,
name|value1
argument_list|,
name|value2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|compare_ObjectArray
parameter_list|(
name|int
name|operation
parameter_list|,
name|Object
index|[]
name|array
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
for|for
control|(
name|Object
name|value1
range|:
name|array
control|)
block|{
if|if
condition|(
name|compare
argument_list|(
name|operation
argument_list|,
name|value1
argument_list|,
name|value2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|compare_PrimitiveArray
parameter_list|(
name|int
name|operation
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|type
parameter_list|,
name|Object
name|primarray
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
if|if
condition|(
name|Integer
operator|.
name|TYPE
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
index|[]
name|array
init|=
operator|(
name|int
index|[]
operator|)
name|primarray
decl_stmt|;
for|for
control|(
name|int
name|value1
range|:
name|array
control|)
block|{
if|if
condition|(
name|compare_Integer
argument_list|(
name|operation
argument_list|,
name|value1
argument_list|,
name|value2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|Long
operator|.
name|TYPE
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|long
index|[]
name|array
init|=
operator|(
name|long
index|[]
operator|)
name|primarray
decl_stmt|;
for|for
control|(
name|long
name|value1
range|:
name|array
control|)
block|{
if|if
condition|(
name|compare_Long
argument_list|(
name|operation
argument_list|,
name|value1
argument_list|,
name|value2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|Byte
operator|.
name|TYPE
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|byte
index|[]
name|array
init|=
operator|(
name|byte
index|[]
operator|)
name|primarray
decl_stmt|;
for|for
control|(
name|byte
name|value1
range|:
name|array
control|)
block|{
if|if
condition|(
name|compare_Byte
argument_list|(
name|operation
argument_list|,
name|value1
argument_list|,
name|value2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|Short
operator|.
name|TYPE
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|short
index|[]
name|array
init|=
operator|(
name|short
index|[]
operator|)
name|primarray
decl_stmt|;
for|for
control|(
name|short
name|value1
range|:
name|array
control|)
block|{
if|if
condition|(
name|compare_Short
argument_list|(
name|operation
argument_list|,
name|value1
argument_list|,
name|value2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|Character
operator|.
name|TYPE
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|char
index|[]
name|array
init|=
operator|(
name|char
index|[]
operator|)
name|primarray
decl_stmt|;
for|for
control|(
name|char
name|value1
range|:
name|array
control|)
block|{
if|if
condition|(
name|compare_Character
argument_list|(
name|operation
argument_list|,
name|value1
argument_list|,
name|value2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|Float
operator|.
name|TYPE
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|float
index|[]
name|array
init|=
operator|(
name|float
index|[]
operator|)
name|primarray
decl_stmt|;
for|for
control|(
name|float
name|value1
range|:
name|array
control|)
block|{
if|if
condition|(
name|compare_Float
argument_list|(
name|operation
argument_list|,
name|value1
argument_list|,
name|value2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|Double
operator|.
name|TYPE
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|double
index|[]
name|array
init|=
operator|(
name|double
index|[]
operator|)
name|primarray
decl_stmt|;
for|for
control|(
name|double
name|value1
range|:
name|array
control|)
block|{
if|if
condition|(
name|compare_Double
argument_list|(
name|operation
argument_list|,
name|value1
argument_list|,
name|value2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|Boolean
operator|.
name|TYPE
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|boolean
index|[]
name|array
init|=
operator|(
name|boolean
index|[]
operator|)
name|primarray
decl_stmt|;
for|for
control|(
name|boolean
name|value1
range|:
name|array
control|)
block|{
if|if
condition|(
name|compare_Boolean
argument_list|(
name|operation
argument_list|,
name|value1
argument_list|,
name|value2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|compare_String
parameter_list|(
name|int
name|operation
parameter_list|,
name|String
name|string
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|SUBSTRING
case|:
block|{
name|String
index|[]
name|substrings
init|=
operator|(
name|String
index|[]
operator|)
name|value2
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|size
init|=
name|substrings
operator|.
name|length
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|String
name|substr
init|=
name|substrings
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|size
condition|)
comment|/* if this is not that last substr */
block|{
if|if
condition|(
name|substr
operator|==
literal|null
condition|)
comment|/* * */
block|{
name|String
name|substr2
init|=
name|substrings
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|substr2
operator|==
literal|null
condition|)
comment|/* ** */
continue|continue;
comment|/* ignore first star */
comment|/* xxx */
name|int
name|index
init|=
name|string
operator|.
name|indexOf
argument_list|(
name|substr2
argument_list|,
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
name|pos
operator|=
name|index
operator|+
name|substr2
operator|.
name|length
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|2
operator|<
name|size
condition|)
comment|// if there are more
comment|// substrings, increment
comment|// over the string we just
comment|// matched; otherwise need
comment|// to do the last substr
comment|// check
name|i
operator|++
expr_stmt|;
block|}
else|else
comment|/* xxx */
block|{
name|int
name|len
init|=
name|substr
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|string
operator|.
name|regionMatches
argument_list|(
name|pos
argument_list|,
name|substr
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|pos
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
comment|/* last substr */
block|{
if|if
condition|(
name|substr
operator|==
literal|null
condition|)
comment|/* * */
block|{
return|return
literal|true
return|;
block|}
comment|/* xxx */
return|return
name|string
operator|.
name|endsWith
argument_list|(
name|substr
argument_list|)
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
case|case
name|EQUAL
case|:
block|{
return|return
name|string
operator|.
name|equals
argument_list|(
name|value2
argument_list|)
return|;
block|}
case|case
name|APPROX
case|:
block|{
name|string
operator|=
name|approxString
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|String
name|string2
init|=
name|approxString
argument_list|(
operator|(
name|String
operator|)
name|value2
argument_list|)
decl_stmt|;
return|return
name|string
operator|.
name|equalsIgnoreCase
argument_list|(
name|string2
argument_list|)
return|;
block|}
case|case
name|GREATER
case|:
block|{
return|return
name|string
operator|.
name|compareTo
argument_list|(
operator|(
name|String
operator|)
name|value2
argument_list|)
operator|>=
literal|0
return|;
block|}
case|case
name|LESS
case|:
block|{
return|return
name|string
operator|.
name|compareTo
argument_list|(
operator|(
name|String
operator|)
name|value2
argument_list|)
operator|<=
literal|0
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|compare_Integer
parameter_list|(
name|int
name|operation
parameter_list|,
name|int
name|intval
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
if|if
condition|(
name|operation
operator|==
name|SUBSTRING
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|intval2
decl_stmt|;
try|try
block|{
name|intval2
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
operator|(
operator|(
name|String
operator|)
name|value2
operator|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|APPROX
case|:
case|case
name|EQUAL
case|:
block|{
return|return
name|intval
operator|==
name|intval2
return|;
block|}
case|case
name|GREATER
case|:
block|{
return|return
name|intval
operator|>=
name|intval2
return|;
block|}
case|case
name|LESS
case|:
block|{
return|return
name|intval
operator|<=
name|intval2
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|compare_Long
parameter_list|(
name|int
name|operation
parameter_list|,
name|long
name|longval
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
if|if
condition|(
name|operation
operator|==
name|SUBSTRING
condition|)
block|{
return|return
literal|false
return|;
block|}
name|long
name|longval2
decl_stmt|;
try|try
block|{
name|longval2
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
operator|(
operator|(
name|String
operator|)
name|value2
operator|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|APPROX
case|:
case|case
name|EQUAL
case|:
block|{
return|return
name|longval
operator|==
name|longval2
return|;
block|}
case|case
name|GREATER
case|:
block|{
return|return
name|longval
operator|>=
name|longval2
return|;
block|}
case|case
name|LESS
case|:
block|{
return|return
name|longval
operator|<=
name|longval2
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|compare_Byte
parameter_list|(
name|int
name|operation
parameter_list|,
name|byte
name|byteval
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
if|if
condition|(
name|operation
operator|==
name|SUBSTRING
condition|)
block|{
return|return
literal|false
return|;
block|}
name|byte
name|byteval2
decl_stmt|;
try|try
block|{
name|byteval2
operator|=
name|Byte
operator|.
name|parseByte
argument_list|(
operator|(
operator|(
name|String
operator|)
name|value2
operator|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|APPROX
case|:
case|case
name|EQUAL
case|:
block|{
return|return
name|byteval
operator|==
name|byteval2
return|;
block|}
case|case
name|GREATER
case|:
block|{
return|return
name|byteval
operator|>=
name|byteval2
return|;
block|}
case|case
name|LESS
case|:
block|{
return|return
name|byteval
operator|<=
name|byteval2
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|compare_Short
parameter_list|(
name|int
name|operation
parameter_list|,
name|short
name|shortval
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
if|if
condition|(
name|operation
operator|==
name|SUBSTRING
condition|)
block|{
return|return
literal|false
return|;
block|}
name|short
name|shortval2
decl_stmt|;
try|try
block|{
name|shortval2
operator|=
name|Short
operator|.
name|parseShort
argument_list|(
operator|(
operator|(
name|String
operator|)
name|value2
operator|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|APPROX
case|:
case|case
name|EQUAL
case|:
block|{
return|return
name|shortval
operator|==
name|shortval2
return|;
block|}
case|case
name|GREATER
case|:
block|{
return|return
name|shortval
operator|>=
name|shortval2
return|;
block|}
case|case
name|LESS
case|:
block|{
return|return
name|shortval
operator|<=
name|shortval2
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|compare_Character
parameter_list|(
name|int
name|operation
parameter_list|,
name|char
name|charval
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
if|if
condition|(
name|operation
operator|==
name|SUBSTRING
condition|)
block|{
return|return
literal|false
return|;
block|}
name|char
name|charval2
decl_stmt|;
try|try
block|{
name|charval2
operator|=
operator|(
operator|(
name|String
operator|)
name|value2
operator|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|EQUAL
case|:
block|{
return|return
name|charval
operator|==
name|charval2
return|;
block|}
case|case
name|APPROX
case|:
block|{
return|return
operator|(
name|charval
operator|==
name|charval2
operator|)
operator|||
operator|(
name|Character
operator|.
name|toUpperCase
argument_list|(
name|charval
argument_list|)
operator|==
name|Character
operator|.
name|toUpperCase
argument_list|(
name|charval2
argument_list|)
operator|)
operator|||
operator|(
name|Character
operator|.
name|toLowerCase
argument_list|(
name|charval
argument_list|)
operator|==
name|Character
operator|.
name|toLowerCase
argument_list|(
name|charval2
argument_list|)
operator|)
return|;
block|}
case|case
name|GREATER
case|:
block|{
return|return
name|charval
operator|>=
name|charval2
return|;
block|}
case|case
name|LESS
case|:
block|{
return|return
name|charval
operator|<=
name|charval2
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|compare_Boolean
parameter_list|(
name|int
name|operation
parameter_list|,
name|boolean
name|boolval
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
if|if
condition|(
name|operation
operator|==
name|SUBSTRING
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|boolval2
init|=
name|Boolean
operator|.
name|valueOf
argument_list|(
operator|(
operator|(
name|String
operator|)
name|value2
operator|)
operator|.
name|trim
argument_list|()
argument_list|)
operator|.
name|booleanValue
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|APPROX
case|:
case|case
name|EQUAL
case|:
case|case
name|GREATER
case|:
case|case
name|LESS
case|:
block|{
return|return
name|boolval
operator|==
name|boolval2
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|compare_Float
parameter_list|(
name|int
name|operation
parameter_list|,
name|float
name|floatval
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
if|if
condition|(
name|operation
operator|==
name|SUBSTRING
condition|)
block|{
return|return
literal|false
return|;
block|}
name|float
name|floatval2
decl_stmt|;
try|try
block|{
name|floatval2
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
operator|(
operator|(
name|String
operator|)
name|value2
operator|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|APPROX
case|:
case|case
name|EQUAL
case|:
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|floatval
argument_list|,
name|floatval2
argument_list|)
operator|==
literal|0
return|;
block|}
case|case
name|GREATER
case|:
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|floatval
argument_list|,
name|floatval2
argument_list|)
operator|>=
literal|0
return|;
block|}
case|case
name|LESS
case|:
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|floatval
argument_list|,
name|floatval2
argument_list|)
operator|<=
literal|0
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|compare_Double
parameter_list|(
name|int
name|operation
parameter_list|,
name|double
name|doubleval
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
if|if
condition|(
name|operation
operator|==
name|SUBSTRING
condition|)
block|{
return|return
literal|false
return|;
block|}
name|double
name|doubleval2
decl_stmt|;
try|try
block|{
name|doubleval2
operator|=
name|Double
operator|.
name|parseDouble
argument_list|(
operator|(
operator|(
name|String
operator|)
name|value2
operator|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|APPROX
case|:
case|case
name|EQUAL
case|:
block|{
return|return
name|Double
operator|.
name|compare
argument_list|(
name|doubleval
argument_list|,
name|doubleval2
argument_list|)
operator|==
literal|0
return|;
block|}
case|case
name|GREATER
case|:
block|{
return|return
name|Double
operator|.
name|compare
argument_list|(
name|doubleval
argument_list|,
name|doubleval2
argument_list|)
operator|>=
literal|0
return|;
block|}
case|case
name|LESS
case|:
block|{
return|return
name|Double
operator|.
name|compare
argument_list|(
name|doubleval
argument_list|,
name|doubleval2
argument_list|)
operator|<=
literal|0
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
specifier|static
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|constructorType
init|=
operator|new
name|Class
index|[]
block|{
name|String
operator|.
name|class
block|}
decl_stmt|;
specifier|private
name|boolean
name|compare_Comparable
parameter_list|(
name|int
name|operation
parameter_list|,
name|Comparable
argument_list|<
name|Object
argument_list|>
name|value1
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
if|if
condition|(
name|operation
operator|==
name|SUBSTRING
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Constructor
argument_list|<
name|?
argument_list|>
name|constructor
decl_stmt|;
try|try
block|{
name|constructor
operator|=
name|value1
operator|.
name|getClass
argument_list|()
operator|.
name|getConstructor
argument_list|(
name|constructorType
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
if|if
condition|(
operator|!
name|constructor
operator|.
name|isAccessible
argument_list|()
condition|)
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|SetAccessibleAction
argument_list|(
name|constructor
argument_list|)
argument_list|)
expr_stmt|;
name|value2
operator|=
name|constructor
operator|.
name|newInstance
argument_list|(
operator|new
name|Object
index|[]
block|{
operator|(
operator|(
name|String
operator|)
name|value2
operator|)
operator|.
name|trim
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|APPROX
case|:
case|case
name|EQUAL
case|:
block|{
return|return
name|value1
operator|.
name|compareTo
argument_list|(
name|value2
argument_list|)
operator|==
literal|0
return|;
block|}
case|case
name|GREATER
case|:
block|{
return|return
name|value1
operator|.
name|compareTo
argument_list|(
name|value2
argument_list|)
operator|>=
literal|0
return|;
block|}
case|case
name|LESS
case|:
block|{
return|return
name|value1
operator|.
name|compareTo
argument_list|(
name|value2
argument_list|)
operator|<=
literal|0
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// if the compareTo method throws an exception; return false
return|return
literal|false
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|compare_Unknown
parameter_list|(
name|int
name|operation
parameter_list|,
name|Object
name|value1
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
if|if
condition|(
name|operation
operator|==
name|SUBSTRING
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Constructor
argument_list|<
name|?
argument_list|>
name|constructor
decl_stmt|;
try|try
block|{
name|constructor
operator|=
name|value1
operator|.
name|getClass
argument_list|()
operator|.
name|getConstructor
argument_list|(
name|constructorType
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
if|if
condition|(
operator|!
name|constructor
operator|.
name|isAccessible
argument_list|()
condition|)
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|SetAccessibleAction
argument_list|(
name|constructor
argument_list|)
argument_list|)
expr_stmt|;
name|value2
operator|=
name|constructor
operator|.
name|newInstance
argument_list|(
operator|new
name|Object
index|[]
block|{
operator|(
operator|(
name|String
operator|)
name|value2
operator|)
operator|.
name|trim
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|APPROX
case|:
case|case
name|EQUAL
case|:
case|case
name|GREATER
case|:
case|case
name|LESS
case|:
block|{
return|return
name|value1
operator|.
name|equals
argument_list|(
name|value2
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// if the equals method throws an exception; return false
return|return
literal|false
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** 		 * Map a string for an APPROX (~=) comparison. 		 *  		 * This implementation removes white spaces. This is the minimum 		 * implementation allowed by the OSGi spec. 		 *  		 * @param input Input string. 		 * @return String ready for APPROX comparison. 		 */
specifier|private
specifier|static
name|String
name|approxString
parameter_list|(
name|String
name|input
parameter_list|)
block|{
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
name|char
index|[]
name|output
init|=
name|input
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|cursor
init|=
literal|0
decl_stmt|;
for|for
control|(
name|char
name|c
range|:
name|output
control|)
block|{
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
name|output
index|[
name|cursor
index|]
operator|=
name|c
expr_stmt|;
name|cursor
operator|++
expr_stmt|;
block|}
return|return
name|changed
condition|?
operator|new
name|String
argument_list|(
name|output
argument_list|,
literal|0
argument_list|,
name|cursor
argument_list|)
else|:
name|input
return|;
block|}
comment|/** 		 * Parser class for OSGi filter strings. This class parses the complete 		 * filter string and builds a tree of Filter objects rooted at the 		 * parent. 		 */
specifier|static
specifier|private
specifier|final
class|class
name|Parser
block|{
specifier|private
specifier|final
name|String
name|filterstring
decl_stmt|;
specifier|private
specifier|final
name|char
index|[]
name|filterChars
decl_stmt|;
specifier|private
name|int
name|pos
decl_stmt|;
name|Parser
parameter_list|(
name|String
name|filterstring
parameter_list|)
block|{
name|this
operator|.
name|filterstring
operator|=
name|filterstring
expr_stmt|;
name|filterChars
operator|=
name|filterstring
operator|.
name|toCharArray
argument_list|()
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
name|FilterImpl
name|parse
parameter_list|()
throws|throws
name|InvalidSyntaxException
block|{
name|FilterImpl
name|filter
decl_stmt|;
try|try
block|{
name|filter
operator|=
name|parse_filter
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InvalidSyntaxException
argument_list|(
literal|"Filter ended abruptly"
argument_list|,
name|filterstring
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|pos
operator|!=
name|filterChars
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|InvalidSyntaxException
argument_list|(
literal|"Extraneous trailing characters: "
operator|+
name|filterstring
operator|.
name|substring
argument_list|(
name|pos
argument_list|)
argument_list|,
name|filterstring
argument_list|)
throw|;
block|}
return|return
name|filter
return|;
block|}
specifier|private
name|FilterImpl
name|parse_filter
parameter_list|()
throws|throws
name|InvalidSyntaxException
block|{
name|FilterImpl
name|filter
decl_stmt|;
name|skipWhiteSpace
argument_list|()
expr_stmt|;
if|if
condition|(
name|filterChars
index|[
name|pos
index|]
operator|!=
literal|'('
condition|)
block|{
throw|throw
operator|new
name|InvalidSyntaxException
argument_list|(
literal|"Missing '(': "
operator|+
name|filterstring
operator|.
name|substring
argument_list|(
name|pos
argument_list|)
argument_list|,
name|filterstring
argument_list|)
throw|;
block|}
name|pos
operator|++
expr_stmt|;
name|filter
operator|=
name|parse_filtercomp
argument_list|()
expr_stmt|;
name|skipWhiteSpace
argument_list|()
expr_stmt|;
if|if
condition|(
name|filterChars
index|[
name|pos
index|]
operator|!=
literal|')'
condition|)
block|{
throw|throw
operator|new
name|InvalidSyntaxException
argument_list|(
literal|"Missing ')': "
operator|+
name|filterstring
operator|.
name|substring
argument_list|(
name|pos
argument_list|)
argument_list|,
name|filterstring
argument_list|)
throw|;
block|}
name|pos
operator|++
expr_stmt|;
name|skipWhiteSpace
argument_list|()
expr_stmt|;
return|return
name|filter
return|;
block|}
specifier|private
name|FilterImpl
name|parse_filtercomp
parameter_list|()
throws|throws
name|InvalidSyntaxException
block|{
name|skipWhiteSpace
argument_list|()
expr_stmt|;
name|char
name|c
init|=
name|filterChars
index|[
name|pos
index|]
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'&'
case|:
block|{
name|pos
operator|++
expr_stmt|;
return|return
name|parse_and
argument_list|()
return|;
block|}
case|case
literal|'|'
case|:
block|{
name|pos
operator|++
expr_stmt|;
return|return
name|parse_or
argument_list|()
return|;
block|}
case|case
literal|'!'
case|:
block|{
name|pos
operator|++
expr_stmt|;
return|return
name|parse_not
argument_list|()
return|;
block|}
block|}
return|return
name|parse_item
argument_list|()
return|;
block|}
specifier|private
name|FilterImpl
name|parse_and
parameter_list|()
throws|throws
name|InvalidSyntaxException
block|{
name|int
name|lookahead
init|=
name|pos
decl_stmt|;
name|skipWhiteSpace
argument_list|()
expr_stmt|;
if|if
condition|(
name|filterChars
index|[
name|pos
index|]
operator|!=
literal|'('
condition|)
block|{
name|pos
operator|=
name|lookahead
operator|-
literal|1
expr_stmt|;
return|return
name|parse_item
argument_list|()
return|;
block|}
name|List
argument_list|<
name|FilterImpl
argument_list|>
name|operands
init|=
operator|new
name|ArrayList
argument_list|<
name|FilterImpl
argument_list|>
argument_list|(
literal|10
argument_list|)
decl_stmt|;
while|while
condition|(
name|filterChars
index|[
name|pos
index|]
operator|==
literal|'('
condition|)
block|{
name|FilterImpl
name|child
init|=
name|parse_filter
argument_list|()
decl_stmt|;
name|operands
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|FilterImpl
argument_list|(
name|FilterImpl
operator|.
name|AND
argument_list|,
literal|null
argument_list|,
name|operands
operator|.
name|toArray
argument_list|(
operator|new
name|FilterImpl
index|[
name|operands
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|FilterImpl
name|parse_or
parameter_list|()
throws|throws
name|InvalidSyntaxException
block|{
name|int
name|lookahead
init|=
name|pos
decl_stmt|;
name|skipWhiteSpace
argument_list|()
expr_stmt|;
if|if
condition|(
name|filterChars
index|[
name|pos
index|]
operator|!=
literal|'('
condition|)
block|{
name|pos
operator|=
name|lookahead
operator|-
literal|1
expr_stmt|;
return|return
name|parse_item
argument_list|()
return|;
block|}
name|List
argument_list|<
name|FilterImpl
argument_list|>
name|operands
init|=
operator|new
name|ArrayList
argument_list|<
name|FilterImpl
argument_list|>
argument_list|(
literal|10
argument_list|)
decl_stmt|;
while|while
condition|(
name|filterChars
index|[
name|pos
index|]
operator|==
literal|'('
condition|)
block|{
name|FilterImpl
name|child
init|=
name|parse_filter
argument_list|()
decl_stmt|;
name|operands
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|FilterImpl
argument_list|(
name|FilterImpl
operator|.
name|OR
argument_list|,
literal|null
argument_list|,
name|operands
operator|.
name|toArray
argument_list|(
operator|new
name|FilterImpl
index|[
name|operands
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|FilterImpl
name|parse_not
parameter_list|()
throws|throws
name|InvalidSyntaxException
block|{
name|int
name|lookahead
init|=
name|pos
decl_stmt|;
name|skipWhiteSpace
argument_list|()
expr_stmt|;
if|if
condition|(
name|filterChars
index|[
name|pos
index|]
operator|!=
literal|'('
condition|)
block|{
name|pos
operator|=
name|lookahead
operator|-
literal|1
expr_stmt|;
return|return
name|parse_item
argument_list|()
return|;
block|}
name|FilterImpl
name|child
init|=
name|parse_filter
argument_list|()
decl_stmt|;
return|return
operator|new
name|FilterImpl
argument_list|(
name|FilterImpl
operator|.
name|NOT
argument_list|,
literal|null
argument_list|,
name|child
argument_list|)
return|;
block|}
specifier|private
name|FilterImpl
name|parse_item
parameter_list|()
throws|throws
name|InvalidSyntaxException
block|{
name|String
name|attr
init|=
name|parse_attr
argument_list|()
decl_stmt|;
name|skipWhiteSpace
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|filterChars
index|[
name|pos
index|]
condition|)
block|{
case|case
literal|'~'
case|:
block|{
if|if
condition|(
name|filterChars
index|[
name|pos
operator|+
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|pos
operator|+=
literal|2
expr_stmt|;
return|return
operator|new
name|FilterImpl
argument_list|(
name|FilterImpl
operator|.
name|APPROX
argument_list|,
name|attr
argument_list|,
name|parse_value
argument_list|()
argument_list|)
return|;
block|}
break|break;
block|}
case|case
literal|'>'
case|:
block|{
if|if
condition|(
name|filterChars
index|[
name|pos
operator|+
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|pos
operator|+=
literal|2
expr_stmt|;
return|return
operator|new
name|FilterImpl
argument_list|(
name|FilterImpl
operator|.
name|GREATER
argument_list|,
name|attr
argument_list|,
name|parse_value
argument_list|()
argument_list|)
return|;
block|}
break|break;
block|}
case|case
literal|'<'
case|:
block|{
if|if
condition|(
name|filterChars
index|[
name|pos
operator|+
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|pos
operator|+=
literal|2
expr_stmt|;
return|return
operator|new
name|FilterImpl
argument_list|(
name|FilterImpl
operator|.
name|LESS
argument_list|,
name|attr
argument_list|,
name|parse_value
argument_list|()
argument_list|)
return|;
block|}
break|break;
block|}
case|case
literal|'='
case|:
block|{
if|if
condition|(
name|filterChars
index|[
name|pos
operator|+
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|int
name|oldpos
init|=
name|pos
decl_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
name|skipWhiteSpace
argument_list|()
expr_stmt|;
if|if
condition|(
name|filterChars
index|[
name|pos
index|]
operator|==
literal|')'
condition|)
block|{
return|return
operator|new
name|FilterImpl
argument_list|(
name|FilterImpl
operator|.
name|PRESENT
argument_list|,
name|attr
argument_list|,
literal|null
argument_list|)
return|;
block|}
name|pos
operator|=
name|oldpos
expr_stmt|;
block|}
name|pos
operator|++
expr_stmt|;
name|Object
name|string
init|=
name|parse_substring
argument_list|()
decl_stmt|;
if|if
condition|(
name|string
operator|instanceof
name|String
condition|)
block|{
return|return
operator|new
name|FilterImpl
argument_list|(
name|FilterImpl
operator|.
name|EQUAL
argument_list|,
name|attr
argument_list|,
name|string
argument_list|)
return|;
block|}
return|return
operator|new
name|FilterImpl
argument_list|(
name|FilterImpl
operator|.
name|SUBSTRING
argument_list|,
name|attr
argument_list|,
name|string
argument_list|)
return|;
block|}
block|}
throw|throw
operator|new
name|InvalidSyntaxException
argument_list|(
literal|"Invalid operator: "
operator|+
name|filterstring
operator|.
name|substring
argument_list|(
name|pos
argument_list|)
argument_list|,
name|filterstring
argument_list|)
throw|;
block|}
specifier|private
name|String
name|parse_attr
parameter_list|()
throws|throws
name|InvalidSyntaxException
block|{
name|skipWhiteSpace
argument_list|()
expr_stmt|;
name|int
name|begin
init|=
name|pos
decl_stmt|;
name|int
name|end
init|=
name|pos
decl_stmt|;
name|char
name|c
init|=
name|filterChars
index|[
name|pos
index|]
decl_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'~'
operator|&&
name|c
operator|!=
literal|'<'
operator|&&
name|c
operator|!=
literal|'>'
operator|&&
name|c
operator|!=
literal|'='
operator|&&
name|c
operator|!=
literal|'('
operator|&&
name|c
operator|!=
literal|')'
condition|)
block|{
name|pos
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|end
operator|=
name|pos
expr_stmt|;
block|}
name|c
operator|=
name|filterChars
index|[
name|pos
index|]
expr_stmt|;
block|}
name|int
name|length
init|=
name|end
operator|-
name|begin
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|InvalidSyntaxException
argument_list|(
literal|"Missing attr: "
operator|+
name|filterstring
operator|.
name|substring
argument_list|(
name|pos
argument_list|)
argument_list|,
name|filterstring
argument_list|)
throw|;
block|}
return|return
operator|new
name|String
argument_list|(
name|filterChars
argument_list|,
name|begin
argument_list|,
name|length
argument_list|)
return|;
block|}
specifier|private
name|String
name|parse_value
parameter_list|()
throws|throws
name|InvalidSyntaxException
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|(
name|filterChars
operator|.
name|length
operator|-
name|pos
argument_list|)
decl_stmt|;
name|parseloop
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|char
name|c
init|=
name|filterChars
index|[
name|pos
index|]
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|')'
case|:
block|{
break|break
name|parseloop
break|;
block|}
case|case
literal|'('
case|:
block|{
throw|throw
operator|new
name|InvalidSyntaxException
argument_list|(
literal|"Invalid value: "
operator|+
name|filterstring
operator|.
name|substring
argument_list|(
name|pos
argument_list|)
argument_list|,
name|filterstring
argument_list|)
throw|;
block|}
case|case
literal|'\\'
case|:
block|{
name|pos
operator|++
expr_stmt|;
name|c
operator|=
name|filterChars
index|[
name|pos
index|]
expr_stmt|;
comment|/* fall through into default */
block|}
default|default :
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|pos
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|InvalidSyntaxException
argument_list|(
literal|"Missing value: "
operator|+
name|filterstring
operator|.
name|substring
argument_list|(
name|pos
argument_list|)
argument_list|,
name|filterstring
argument_list|)
throw|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|Object
name|parse_substring
parameter_list|()
throws|throws
name|InvalidSyntaxException
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|(
name|filterChars
operator|.
name|length
operator|-
name|pos
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|operands
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|parseloop
label|:
while|while
condition|(
literal|true
condition|)
block|{
name|char
name|c
init|=
name|filterChars
index|[
name|pos
index|]
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|')'
case|:
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|operands
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break
name|parseloop
break|;
block|}
case|case
literal|'('
case|:
block|{
throw|throw
operator|new
name|InvalidSyntaxException
argument_list|(
literal|"Invalid value: "
operator|+
name|filterstring
operator|.
name|substring
argument_list|(
name|pos
argument_list|)
argument_list|,
name|filterstring
argument_list|)
throw|;
block|}
case|case
literal|'*'
case|:
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|operands
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|operands
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|pos
operator|++
expr_stmt|;
break|break;
block|}
case|case
literal|'\\'
case|:
block|{
name|pos
operator|++
expr_stmt|;
name|c
operator|=
name|filterChars
index|[
name|pos
index|]
expr_stmt|;
comment|/* fall through into default */
block|}
default|default :
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|pos
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
name|int
name|size
init|=
name|operands
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|Object
name|single
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|single
operator|!=
literal|null
condition|)
block|{
return|return
name|single
return|;
block|}
block|}
return|return
name|operands
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|size
index|]
argument_list|)
return|;
block|}
specifier|private
name|void
name|skipWhiteSpace
parameter_list|()
block|{
for|for
control|(
name|int
name|length
init|=
name|filterChars
operator|.
name|length
init|;
operator|(
name|pos
operator|<
name|length
operator|)
operator|&&
name|Character
operator|.
name|isWhitespace
argument_list|(
name|filterChars
index|[
name|pos
index|]
argument_list|)
condition|;
control|)
block|{
name|pos
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** 	 * This Map is used for case-insensitive key lookup during filter 	 * evaluation. This Map implementation only supports the get operation using 	 * a String key as no other operations are used by the Filter 	 * implementation. 	 */
specifier|static
specifier|private
specifier|final
class|class
name|CaseInsensitiveMap
extends|extends
name|AbstractMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
implements|implements
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
block|{
specifier|private
specifier|final
name|Dictionary
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|dictionary
decl_stmt|;
specifier|private
specifier|final
name|String
index|[]
name|keys
decl_stmt|;
comment|/** 		 * Create a case insensitive map from the specified dictionary. 		 *  		 * @param dictionary 		 * @throws IllegalArgumentException If {@code dictionary} contains case 		 *         variants of the same key name. 		 */
name|CaseInsensitiveMap
parameter_list|(
name|Dictionary
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|dictionary
parameter_list|)
block|{
if|if
condition|(
name|dictionary
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|dictionary
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|keys
operator|=
operator|new
name|String
index|[
literal|0
index|]
expr_stmt|;
return|return;
block|}
name|this
operator|.
name|dictionary
operator|=
name|dictionary
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|keyList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|dictionary
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Enumeration
argument_list|<
name|?
argument_list|>
name|e
init|=
name|dictionary
operator|.
name|keys
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Object
name|k
init|=
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|k
operator|instanceof
name|String
condition|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|k
decl_stmt|;
for|for
control|(
name|String
name|i
range|:
name|keyList
control|)
block|{
if|if
condition|(
name|key
operator|.
name|equalsIgnoreCase
argument_list|(
name|i
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
block|}
name|keyList
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|keys
operator|=
name|keyList
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|keyList
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Object
name|get
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|String
name|k
init|=
operator|(
name|String
operator|)
name|o
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|keys
control|)
block|{
if|if
condition|(
name|key
operator|.
name|equalsIgnoreCase
argument_list|(
name|k
argument_list|)
condition|)
block|{
return|return
name|dictionary
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|Set
argument_list|<
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
comment|/** 	 * This Map is used for key lookup from a ServiceReference during filter 	 * evaluation. This Map implementation only supports the get operation using 	 * a String key as no other operations are used by the Filter 	 * implementation. 	 */
specifier|static
specifier|private
specifier|final
class|class
name|ServiceReferenceMap
extends|extends
name|AbstractMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
implements|implements
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
block|{
specifier|private
specifier|final
name|ServiceReference
argument_list|<
name|?
argument_list|>
name|reference
decl_stmt|;
name|ServiceReferenceMap
parameter_list|(
name|ServiceReference
argument_list|<
name|?
argument_list|>
name|reference
parameter_list|)
block|{
name|this
operator|.
name|reference
operator|=
name|reference
expr_stmt|;
block|}
specifier|public
name|Object
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|reference
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|reference
operator|.
name|getProperty
argument_list|(
operator|(
name|String
operator|)
name|key
argument_list|)
return|;
block|}
specifier|public
name|Set
argument_list|<
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
specifier|static
specifier|private
specifier|final
class|class
name|SetAccessibleAction
implements|implements
name|PrivilegedAction
argument_list|<
name|Object
argument_list|>
block|{
specifier|private
specifier|final
name|AccessibleObject
name|accessible
decl_stmt|;
name|SetAccessibleAction
parameter_list|(
name|AccessibleObject
name|accessible
parameter_list|)
block|{
name|this
operator|.
name|accessible
operator|=
name|accessible
expr_stmt|;
block|}
specifier|public
name|Object
name|run
parameter_list|()
block|{
name|accessible
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/** 	 * This class contains a method to match a distinguished name (DN) chain 	 * against and DN chain pattern. 	 *<p> 	 * The format of DNs are given in RFC 2253. We represent a signature chain 	 * for an X.509 certificate as a semicolon separated list of DNs. This is 	 * what we refer to as the DN chain. Each DN is made up of relative 	 * distinguished names (RDN) which in turn are made up of key value pairs. 	 * For example: 	 *  	 *<pre> 	 *   cn=ben+ou=research,o=ACME,c=us;ou=Super CA,c=CA 	 *</pre> 	 *  	 * is made up of two DNs: "{@code cn=ben+ou=research,o=ACME,c=us} 	 * " and " {@code ou=Super CA,c=CA} 	 * ". The first DN is made of of three RDNs: " 	 * {@code cn=ben+ou=research}" and "{@code o=ACME}" and " 	 * {@code c=us}". The first RDN has two name value pairs: " 	 * {@code cn=ben}" and "{@code ou=research}". 	 *<p> 	 * A chain pattern makes use of wildcards ('*' or '-') to match against DNs, 	 * and wildcards ('*') to match againts DN prefixes, and value. If a DN in a 	 * match pattern chain is made up of a wildcard ("*"), that wildcard will 	 * match zero or one DNs in the chain. If a DN in a match pattern chain is 	 * made up of a wildcard ("-"), that wildcard will match zero or more DNs in 	 * the chain. If the first RDN of a DN is the wildcard ("*"), that DN will 	 * match any other DN with the same suffix (the DN with the wildcard RDN 	 * removed). If a value of a name/value pair is a wildcard ("*"), the value 	 * will match any value for that name. 	 */
specifier|static
specifier|private
specifier|final
class|class
name|DNChainMatching
block|{
specifier|private
specifier|static
specifier|final
name|String
name|MINUS_WILDCARD
init|=
literal|"-"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|STAR_WILDCARD
init|=
literal|"*"
decl_stmt|;
comment|/** 		 * Check the name/value pairs of the rdn against the pattern. 		 *  		 * @param rdn List of name value pairs for a given RDN. 		 * @param rdnPattern List of name value pattern pairs. 		 * @return true if the list of name value pairs match the pattern. 		 */
specifier|private
specifier|static
name|boolean
name|rdnmatch
parameter_list|(
name|List
argument_list|<
name|?
argument_list|>
name|rdn
parameter_list|,
name|List
argument_list|<
name|?
argument_list|>
name|rdnPattern
parameter_list|)
block|{
if|if
condition|(
name|rdn
operator|.
name|size
argument_list|()
operator|!=
name|rdnPattern
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rdn
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|rdnNameValue
init|=
operator|(
name|String
operator|)
name|rdn
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|patNameValue
init|=
operator|(
name|String
operator|)
name|rdnPattern
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|rdnNameEnd
init|=
name|rdnNameValue
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|)
decl_stmt|;
name|int
name|patNameEnd
init|=
name|patNameValue
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|)
decl_stmt|;
if|if
condition|(
name|rdnNameEnd
operator|!=
name|patNameEnd
operator|||
operator|!
name|rdnNameValue
operator|.
name|regionMatches
argument_list|(
literal|0
argument_list|,
name|patNameValue
argument_list|,
literal|0
argument_list|,
name|rdnNameEnd
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|String
name|patValue
init|=
name|patNameValue
operator|.
name|substring
argument_list|(
name|patNameEnd
argument_list|)
decl_stmt|;
name|String
name|rdnValue
init|=
name|rdnNameValue
operator|.
name|substring
argument_list|(
name|rdnNameEnd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rdnValue
operator|.
name|equals
argument_list|(
name|patValue
argument_list|)
operator|&&
operator|!
name|patValue
operator|.
name|equals
argument_list|(
literal|"=*"
argument_list|)
operator|&&
operator|!
name|patValue
operator|.
name|equals
argument_list|(
literal|"=#16012a"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
name|boolean
name|dnmatch
parameter_list|(
name|List
argument_list|<
name|?
argument_list|>
name|dn
parameter_list|,
name|List
argument_list|<
name|?
argument_list|>
name|dnPattern
parameter_list|)
block|{
name|int
name|dnStart
init|=
literal|0
decl_stmt|;
name|int
name|patStart
init|=
literal|0
decl_stmt|;
name|int
name|patLen
init|=
name|dnPattern
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|patLen
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|dnPattern
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|equals
argument_list|(
name|STAR_WILDCARD
argument_list|)
condition|)
block|{
name|patStart
operator|=
literal|1
expr_stmt|;
name|patLen
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|dn
operator|.
name|size
argument_list|()
operator|<
name|patLen
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
if|if
condition|(
name|dn
operator|.
name|size
argument_list|()
operator|>
name|patLen
condition|)
block|{
if|if
condition|(
operator|!
name|dnPattern
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|equals
argument_list|(
name|STAR_WILDCARD
argument_list|)
condition|)
block|{
comment|// If the number of rdns do not match we must have a
comment|// prefix map
return|return
literal|false
return|;
block|}
comment|// The rdnPattern and rdn must have the same number of
comment|// elements
name|dnStart
operator|=
name|dn
operator|.
name|size
argument_list|()
operator|-
name|patLen
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|patLen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|rdnmatch
argument_list|(
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|dn
operator|.
name|get
argument_list|(
name|i
operator|+
name|dnStart
argument_list|)
argument_list|,
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|dnPattern
operator|.
name|get
argument_list|(
name|i
operator|+
name|patStart
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/** 		 * Parses a distinguished name chain pattern and returns a List where 		 * each element represents a distinguished name (DN) in the chain of 		 * DNs. Each element will be either a String, if the element represents 		 * a wildcard ("*" or "-"), or a List representing an RDN. Each element 		 * in the RDN List will be a String, if the element represents a 		 * wildcard ("*"), or a List of Strings, each String representing a 		 * name/value pair in the RDN. 		 *  		 * @param dnChain 		 * @return a list of DNs. 		 * @throws IllegalArgumentException 		 */
specifier|private
specifier|static
name|List
argument_list|<
name|Object
argument_list|>
name|parseDNchainPattern
parameter_list|(
name|String
name|dnChain
parameter_list|)
block|{
if|if
condition|(
name|dnChain
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The DN chain must not be null."
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|Object
argument_list|>
name|parsed
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|startIndex
init|=
literal|0
decl_stmt|;
name|startIndex
operator|=
name|skipSpaces
argument_list|(
name|dnChain
argument_list|,
name|startIndex
argument_list|)
expr_stmt|;
while|while
condition|(
name|startIndex
operator|<
name|dnChain
operator|.
name|length
argument_list|()
condition|)
block|{
name|int
name|endIndex
init|=
name|startIndex
decl_stmt|;
name|boolean
name|inQuote
init|=
literal|false
decl_stmt|;
name|out
label|:
while|while
condition|(
name|endIndex
operator|<
name|dnChain
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|dnChain
operator|.
name|charAt
argument_list|(
name|endIndex
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'"'
case|:
name|inQuote
operator|=
operator|!
name|inQuote
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|endIndex
operator|++
expr_stmt|;
comment|// skip the escaped char
break|break;
case|case
literal|';'
case|:
if|if
condition|(
operator|!
name|inQuote
condition|)
break|break
name|out
break|;
block|}
name|endIndex
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|endIndex
operator|>
name|dnChain
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"unterminated escape"
argument_list|)
throw|;
block|}
name|parsed
operator|.
name|add
argument_list|(
name|dnChain
operator|.
name|substring
argument_list|(
name|startIndex
argument_list|,
name|endIndex
argument_list|)
argument_list|)
expr_stmt|;
name|startIndex
operator|=
name|endIndex
operator|+
literal|1
expr_stmt|;
name|startIndex
operator|=
name|skipSpaces
argument_list|(
name|dnChain
argument_list|,
name|startIndex
argument_list|)
expr_stmt|;
block|}
comment|// Now we parse is a list of strings, lets make List of rdn out
comment|// of them
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parsed
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|dn
init|=
operator|(
name|String
operator|)
name|parsed
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|dn
operator|.
name|equals
argument_list|(
name|STAR_WILDCARD
argument_list|)
operator|||
name|dn
operator|.
name|equals
argument_list|(
name|MINUS_WILDCARD
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|List
argument_list|<
name|Object
argument_list|>
name|rdns
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|dn
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|dn
operator|.
name|charAt
argument_list|(
literal|1
argument_list|)
operator|!=
literal|','
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"invalid wildcard prefix"
argument_list|)
throw|;
block|}
name|rdns
operator|.
name|add
argument_list|(
name|STAR_WILDCARD
argument_list|)
expr_stmt|;
name|dn
operator|=
operator|new
name|X500Principal
argument_list|(
name|dn
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|.
name|getName
argument_list|(
name|X500Principal
operator|.
name|CANONICAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dn
operator|=
operator|new
name|X500Principal
argument_list|(
name|dn
argument_list|)
operator|.
name|getName
argument_list|(
name|X500Principal
operator|.
name|CANONICAL
argument_list|)
expr_stmt|;
block|}
comment|// Now dn is a nice CANONICAL DN
name|parseDN
argument_list|(
name|dn
argument_list|,
name|rdns
argument_list|)
expr_stmt|;
name|parsed
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|rdns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parsed
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"empty DN chain"
argument_list|)
throw|;
block|}
return|return
name|parsed
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Object
argument_list|>
name|parseDNchain
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|chain
parameter_list|)
block|{
if|if
condition|(
name|chain
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"DN chain must not be null."
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|Object
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
name|chain
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// Now we parse is a list of strings, lets make List of rdn out
comment|// of them
for|for
control|(
name|String
name|dn
range|:
name|chain
control|)
block|{
name|dn
operator|=
operator|new
name|X500Principal
argument_list|(
name|dn
argument_list|)
operator|.
name|getName
argument_list|(
name|X500Principal
operator|.
name|CANONICAL
argument_list|)
expr_stmt|;
comment|// Now dn is a nice CANONICAL DN
name|List
argument_list|<
name|Object
argument_list|>
name|rdns
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|parseDN
argument_list|(
name|dn
argument_list|,
name|rdns
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|rdns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"empty DN chain"
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
comment|/** 		 * Increment startIndex until the end of dnChain is hit or until it is 		 * the index of a non-space character. 		 */
specifier|private
specifier|static
name|int
name|skipSpaces
parameter_list|(
name|String
name|dnChain
parameter_list|,
name|int
name|startIndex
parameter_list|)
block|{
while|while
condition|(
name|startIndex
operator|<
name|dnChain
operator|.
name|length
argument_list|()
operator|&&
name|dnChain
operator|.
name|charAt
argument_list|(
name|startIndex
argument_list|)
operator|==
literal|' '
condition|)
block|{
name|startIndex
operator|++
expr_stmt|;
block|}
return|return
name|startIndex
return|;
block|}
comment|/** 		 * Takes a distinguished name in canonical form and fills in the 		 * rdnArray with the extracted RDNs. 		 *  		 * @param dn the distinguished name in canonical form. 		 * @param rdn the list to fill in with RDNs extracted from the dn 		 * @throws IllegalArgumentException if a formatting error is found. 		 */
specifier|private
specifier|static
name|void
name|parseDN
parameter_list|(
name|String
name|dn
parameter_list|,
name|List
argument_list|<
name|Object
argument_list|>
name|rdn
parameter_list|)
block|{
name|int
name|startIndex
init|=
literal|0
decl_stmt|;
name|char
name|c
init|=
literal|'\0'
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|nameValues
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|startIndex
operator|<
name|dn
operator|.
name|length
argument_list|()
condition|)
block|{
name|int
name|endIndex
decl_stmt|;
for|for
control|(
name|endIndex
operator|=
name|startIndex
init|;
name|endIndex
operator|<
name|dn
operator|.
name|length
argument_list|()
condition|;
name|endIndex
operator|++
control|)
block|{
name|c
operator|=
name|dn
operator|.
name|charAt
argument_list|(
name|endIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|'+'
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|endIndex
operator|++
expr_stmt|;
comment|// skip the escaped char
block|}
block|}
if|if
condition|(
name|endIndex
operator|>
name|dn
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"unterminated escape "
operator|+
name|dn
argument_list|)
throw|;
block|}
name|nameValues
operator|.
name|add
argument_list|(
name|dn
operator|.
name|substring
argument_list|(
name|startIndex
argument_list|,
name|endIndex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'+'
condition|)
block|{
name|rdn
operator|.
name|add
argument_list|(
name|nameValues
argument_list|)
expr_stmt|;
if|if
condition|(
name|endIndex
operator|!=
name|dn
operator|.
name|length
argument_list|()
condition|)
block|{
name|nameValues
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|nameValues
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|startIndex
operator|=
name|endIndex
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nameValues
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"improperly terminated DN "
operator|+
name|dn
argument_list|)
throw|;
block|}
block|}
comment|/** 		 * This method will return an 'index' which points to a non-wildcard DN 		 * or the end-of-list. 		 */
specifier|private
specifier|static
name|int
name|skipWildCards
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|dnChainPattern
parameter_list|,
name|int
name|dnChainPatternIndex
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|dnChainPatternIndex
init|;
name|i
operator|<
name|dnChainPattern
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|dnPattern
init|=
name|dnChainPattern
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|dnPattern
operator|instanceof
name|String
condition|)
block|{
if|if
condition|(
operator|!
name|dnPattern
operator|.
name|equals
argument_list|(
name|STAR_WILDCARD
argument_list|)
operator|&&
operator|!
name|dnPattern
operator|.
name|equals
argument_list|(
name|MINUS_WILDCARD
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"expected wildcard in DN pattern"
argument_list|)
throw|;
block|}
comment|// otherwise continue skipping over wild cards
block|}
else|else
block|{
if|if
condition|(
name|dnPattern
operator|instanceof
name|List
argument_list|<
name|?
argument_list|>
condition|)
block|{
comment|// if its a list then we have our 'non-wildcard' DN
break|break;
block|}
else|else
block|{
comment|// unknown member of the DNChainPattern
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"expected String or List in DN Pattern"
argument_list|)
throw|;
block|}
block|}
block|}
comment|// i either points to end-of-list, or to the first
comment|// non-wildcard pattern after dnChainPatternIndex
return|return
name|i
return|;
block|}
comment|/** 		 * recursively attempt to match the DNChain, and the DNChainPattern 		 * where DNChain is of the format: "DN;DN;DN;" and DNChainPattern is of 		 * the format: "DNPattern;*;DNPattern" (or combinations of this) 		 */
specifier|private
specifier|static
name|boolean
name|dnChainMatch
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|dnChain
parameter_list|,
name|int
name|dnChainIndex
parameter_list|,
name|List
argument_list|<
name|Object
argument_list|>
name|dnChainPattern
parameter_list|,
name|int
name|dnChainPatternIndex
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|dnChainIndex
operator|>=
name|dnChain
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|dnChainPatternIndex
operator|>=
name|dnChainPattern
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// check to see what the pattern starts with
name|Object
name|dnPattern
init|=
name|dnChainPattern
operator|.
name|get
argument_list|(
name|dnChainPatternIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|dnPattern
operator|instanceof
name|String
condition|)
block|{
if|if
condition|(
operator|!
name|dnPattern
operator|.
name|equals
argument_list|(
name|STAR_WILDCARD
argument_list|)
operator|&&
operator|!
name|dnPattern
operator|.
name|equals
argument_list|(
name|MINUS_WILDCARD
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"expected wildcard in DN pattern"
argument_list|)
throw|;
block|}
comment|// here we are processing a wild card as the first DN
comment|// skip all wildcard DN's
if|if
condition|(
name|dnPattern
operator|.
name|equals
argument_list|(
name|MINUS_WILDCARD
argument_list|)
condition|)
block|{
name|dnChainPatternIndex
operator|=
name|skipWildCards
argument_list|(
name|dnChainPattern
argument_list|,
name|dnChainPatternIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dnChainPatternIndex
operator|++
expr_stmt|;
comment|// only skip the '*' wildcard
block|}
if|if
condition|(
name|dnChainPatternIndex
operator|>=
name|dnChainPattern
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// return true iff the wild card is '-' or if we are at the
comment|// end of the chain
return|return
name|dnPattern
operator|.
name|equals
argument_list|(
name|MINUS_WILDCARD
argument_list|)
condition|?
literal|true
else|:
name|dnChain
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|==
name|dnChainIndex
return|;
block|}
comment|//
comment|// we will now recursively call to see if the rest of the
comment|// DNChainPattern matches increasingly smaller portions of the
comment|// rest of the DNChain
comment|//
if|if
condition|(
name|dnPattern
operator|.
name|equals
argument_list|(
name|STAR_WILDCARD
argument_list|)
condition|)
block|{
comment|// '*' option: only wildcard on 0 or 1
return|return
name|dnChainMatch
argument_list|(
name|dnChain
argument_list|,
name|dnChainIndex
argument_list|,
name|dnChainPattern
argument_list|,
name|dnChainPatternIndex
argument_list|)
operator|||
name|dnChainMatch
argument_list|(
name|dnChain
argument_list|,
name|dnChainIndex
operator|+
literal|1
argument_list|,
name|dnChainPattern
argument_list|,
name|dnChainPatternIndex
argument_list|)
return|;
block|}
for|for
control|(
name|int
name|i
init|=
name|dnChainIndex
init|;
name|i
operator|<
name|dnChain
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// '-' option: wildcard 0 or more
if|if
condition|(
name|dnChainMatch
argument_list|(
name|dnChain
argument_list|,
name|i
argument_list|,
name|dnChainPattern
argument_list|,
name|dnChainPatternIndex
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|// if we are here, then we didn't find a match.. fall through to
comment|// failure
block|}
else|else
block|{
if|if
condition|(
name|dnPattern
operator|instanceof
name|List
argument_list|<
name|?
argument_list|>
condition|)
block|{
comment|// here we have to do a deeper check for each DN in the
comment|// pattern until we hit a wild card
do|do
block|{
if|if
condition|(
operator|!
name|dnmatch
argument_list|(
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|dnChain
operator|.
name|get
argument_list|(
name|dnChainIndex
argument_list|)
argument_list|,
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|dnPattern
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// go to the next set of DN's in both chains
name|dnChainIndex
operator|++
expr_stmt|;
name|dnChainPatternIndex
operator|++
expr_stmt|;
comment|// if we finished the pattern then it all matched
if|if
condition|(
operator|(
name|dnChainIndex
operator|>=
name|dnChain
operator|.
name|size
argument_list|()
operator|)
operator|&&
operator|(
name|dnChainPatternIndex
operator|>=
name|dnChainPattern
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// if the DN Chain is finished, but the pattern isn't
comment|// finished then if the rest of the pattern is not
comment|// wildcard then we are done
if|if
condition|(
name|dnChainIndex
operator|>=
name|dnChain
operator|.
name|size
argument_list|()
condition|)
block|{
name|dnChainPatternIndex
operator|=
name|skipWildCards
argument_list|(
name|dnChainPattern
argument_list|,
name|dnChainPatternIndex
argument_list|)
expr_stmt|;
comment|// return TRUE iff the pattern index moved past the
comment|// list-size (implying that the rest of the pattern
comment|// is all wildcards)
return|return
name|dnChainPatternIndex
operator|>=
name|dnChainPattern
operator|.
name|size
argument_list|()
return|;
block|}
comment|// if the pattern finished, but the chain continues then
comment|// we have a mis-match
if|if
condition|(
name|dnChainPatternIndex
operator|>=
name|dnChainPattern
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// get the next DN Pattern
name|dnPattern
operator|=
name|dnChainPattern
operator|.
name|get
argument_list|(
name|dnChainPatternIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnPattern
operator|instanceof
name|String
condition|)
block|{
if|if
condition|(
operator|!
name|dnPattern
operator|.
name|equals
argument_list|(
name|STAR_WILDCARD
argument_list|)
operator|&&
operator|!
name|dnPattern
operator|.
name|equals
argument_list|(
name|MINUS_WILDCARD
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"expected wildcard in DN pattern"
argument_list|)
throw|;
block|}
comment|// if the next DN is a 'wildcard', then we will
comment|// recurse
return|return
name|dnChainMatch
argument_list|(
name|dnChain
argument_list|,
name|dnChainIndex
argument_list|,
name|dnChainPattern
argument_list|,
name|dnChainPatternIndex
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|dnPattern
operator|instanceof
name|List
argument_list|<
name|?
argument_list|>
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"expected String or List in DN Pattern"
argument_list|)
throw|;
block|}
block|}
comment|// if we are here, then we will just continue to the
comment|// match the next set of DN's from the DNChain, and the
comment|// DNChainPattern since both are lists
block|}
while|while
condition|(
literal|true
condition|)
empty_stmt|;
comment|// should never reach here?
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"expected String or List in DN Pattern"
argument_list|)
throw|;
block|}
block|}
comment|// if we get here, the the default return is 'mis-match'
return|return
literal|false
return|;
block|}
comment|/** 		 * Matches a distinguished name chain against a pattern of a 		 * distinguished name chain. 		 *  		 * @param dnChain 		 * @param pattern the pattern of distinguished name (DN) chains to match 		 *        against the dnChain. Wildcards ("*" or "-") can be used in 		 *        three cases: 		 *<ol> 		 *<li>As a DN. In this case, the DN will consist of just the "*" 		 *        or "-". When "*" is used it will match zero or one DNs. When 		 *        "-" is used it will match zero or more DNs. For example, 		 *        "cn=me,c=US;*;cn=you" will match 		 *        "cn=me,c=US";cn=you" and "cn=me,c=US;cn=her;cn=you". The 		 *        pattern "cn=me,c=US;-;cn=you" will match "cn=me,c=US";cn=you" 		 *        and "cn=me,c=US;cn=her;cn=him;cn=you". 		 *<li>As a DN prefix. In this case, the DN must start with "*,". 		 *        The wild card will match zero or more RDNs at the start of a 		 *        DN. For example, "*,cn=me,c=US;cn=you" will match 		 *        "cn=me,c=US";cn=you" and 		 *        "ou=my org unit,o=my org,cn=me,c=US;cn=you"</li> 		 *<li>As a value. In this case the value of a name value pair in 		 *        an RDN will be a "*". The wildcard will match any value for 		 *        the given name. For example, "cn=*,c=US;cn=you" will match 		 *        "cn=me,c=US";cn=you" and "cn=her,c=US;cn=you", but it will not 		 *        match "ou=my org unit,c=US;cn=you". If the wildcard does not 		 *        occur by itself in the value, it will not be used as a 		 *        wildcard. In other words, "cn=m*,c=US;cn=you" represents the 		 *        common name of "m*" not any common name starting with "m".</li> 		 *</ol> 		 * @return true if dnChain matches the pattern. 		 * @throws IllegalArgumentException 		 */
specifier|static
name|boolean
name|match
parameter_list|(
name|String
name|pattern
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|dnChain
parameter_list|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|parsedDNChain
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|parsedDNPattern
decl_stmt|;
try|try
block|{
name|parsedDNChain
operator|=
name|parseDNchain
argument_list|(
name|dnChain
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|IllegalArgumentException
name|iae
init|=
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid DN chain: "
operator|+
name|toString
argument_list|(
name|dnChain
argument_list|)
argument_list|)
decl_stmt|;
name|iae
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|iae
throw|;
block|}
try|try
block|{
name|parsedDNPattern
operator|=
name|parseDNchainPattern
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|IllegalArgumentException
name|iae
init|=
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid match pattern: "
operator|+
name|pattern
argument_list|)
decl_stmt|;
name|iae
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|iae
throw|;
block|}
return|return
name|dnChainMatch
argument_list|(
name|parsedDNChain
argument_list|,
literal|0
argument_list|,
name|parsedDNPattern
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|String
name|toString
parameter_list|(
name|List
argument_list|<
name|?
argument_list|>
name|dnChain
parameter_list|)
block|{
if|if
condition|(
name|dnChain
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iChain
init|=
name|dnChain
operator|.
name|iterator
argument_list|()
init|;
name|iChain
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|iChain
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|iChain
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

unit|}
end_unit

