begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *   http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|main
operator|.
name|lock
package|;
end_package

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|PreparedStatement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|utils
operator|.
name|properties
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|main
operator|.
name|ConfigProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|main
operator|.
name|util
operator|.
name|BootstrapLogManager
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|sql
operator|.
name|DataSource
import|;
end_import

begin_comment
comment|/**  *<p>This class is the base class used to provide a master/slave configuration for  * a given set of active karaf instances using JDBC.</p>  *  *<p>This implementation uses two different tables.  A KARAF_NODE_ID, and KARAF_LOCK tables.  The  * KARAF_NODE_ID table is used to generate a unique id for each instance in the cluster.  While  * the KARAF_LOCK table is used to determine who is the master of these instances.</p>  *  *<p>The tables configurations for the different tables are.</p>  *  *<pre>  *   CREATE TABLE KARAF_NODE_ID ( ID INTEGER DEFAULT 0 )  *   CREATE TABLE KARAF_LOCK ( ID INTEGER DEFAULT 0, STATE INTEGER DEFAULT 0, LOCK_DELAY INTEGER DEFAULT 0 )  *</pre>  *  *<p>The two tables will include a single row each that is created by a single instance in the cluster.</p>  *  *<p>The KARAF_NODE_ID table will be updated once for each active karaf instance with there unique id compared  * to the other instances within the cluster.  The single row will contain the next available unique id and  * will not include each clustered instance unique id since these instances can come and go throughout the  * system lifetime.</p>  *  *<p>The KARAF_LOCK table will be used to determine which of the instances will become the master. The master  * will set the STATE to an initial value and the LOCK_DELAY to a time in milliseconds of when the  * table will be updated.  It is the responsibility of the master instance to update the STATE field by the  * allocated lock delay by incrementing the state value.  If the STATE value has not been updated by the   * LOCK_DELAY time then a slave has permission to attempt to become the master.</p>  *  *<p>While the overview does not describe exactly how this is implemented.  Here is a description of how this  * is done and what is provides as a fail safe solution.</p>  *  *<p>Each instance of this class provides an initialization step, a lock, isAlive and release interface.</p>  *  *<p>INITIALIZE:</p>  *  *<p>During the initialization step it will determine if the given tables exist within the database.  We only  * check for a single table since we assume that if one is available then the other must exist. We then  * add a row to each of the tables.  The added row to the KARAF_NODE_ID table will set the ID to zero since   * this is consider a non-existent karaf instance.  The added row to the KARAF_LOCK will set the ID to zero  * which allows a karaf instances to acquire the lock and become the master instance.</p>  *  *  *<p>LOCK:</p>  *  *<p>The current instance will try to acquire the master lock by using the following sql statement.</p>  *  *<pre>  *   UPDATE KARAF_LOCK SET ID = unique_id, STATE = state, LOCK_DELAY = lock_delay   *       WHERE ID = 0 OR ID = curId  *</pre>  *  *<p>Now you must be asking why are we using this update statement? The reason is that the statement will  * guarantee that only one instance will be able to update this row.  The curId is set to this instance  * unique id or to the prior master unique id if the row was not updated within that master lock_delay.</p>  *  *<p>The current update command will set the curId to this instance unique id.  If this fails then it will  * determine if the current master has not updated the row within its lock_delay.  If it hasn't updated  * the row within the allocated time then this instance can try to become the master.</p>  *  *<p>The current slave instance will then try to steal the lock from the master instance.  Why are we trying  * to steal the lock from the master?  The reason is that it is possible that the master instance had a   * hard failure and there is no mechanisms to determine if that is the case. We then assume that it has   * crashed without releasing the lock gracefully.  The slave instance then used the following update statement.</p>  *  *<pre>  *   UPDATE KARAF_LOCK SET ID = unique_id, STATE = state, LOCK_DELAY = lock_delay   *       WHERE ( ID = 0 OR ID = curId ) AND STATE = curState  *</pre>  *  *<p>Now why are we using the state value as part of the where clause?  The reason that even though the row was  * not updated by the allocated delay time.  It is possible that the update statement was performed just after   * the current slave check.  This update will insure that the row will be updated if and only if the state was  * also not updated.  It is possible that the master instance updated the row after the current slave check   * and we do not want the slave to update the row and make itself the master.  This will insure that that will  * not be the case.</p>  *  *<p>ISALIVE:</p>  *  *<p>This just checks if the connection is active and then just updates the row's STATE by using the lock  * update call mentioned above.</p>  *  *<p>RELEASE:</p>  *  *<p>The release process just updates the KARAF_LOCK ID to zero so that other instances will have a chance  * to become the master.</p>  *  *<p>There are two main scenarios that we need to worry about.  Soft and Hard failures.  The soft failure  * basically allows the master instance to release the master lock and allow other instances to become  * the master.  As for a hard failure, the current karaf instance crashes and does not release the lock  * then the other karaf instances will notice that the KARAF_LOCK has not been updated for the current  * master id and then they can compete for the master lock.</p>  */
end_comment

begin_class
specifier|public
class|class
name|GenericJDBCLock
implements|implements
name|Lock
block|{
specifier|final
name|Logger
name|LOG
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_LOCK_URL
init|=
literal|"karaf.lock.jdbc.url"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_LOCK_JDBC_DRIVER
init|=
literal|"karaf.lock.jdbc.driver"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_LOCK_JDBC_USER
init|=
literal|"karaf.lock.jdbc.user"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_LOCK_JDBC_PASSWORD
init|=
literal|"karaf.lock.jdbc.password"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_LOCK_JDBC_TABLE
init|=
literal|"karaf.lock.jdbc.table"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_LOCK_JDBC_TABLE_ID
init|=
literal|"karaf.lock.jdbc.table_id"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_LOCK_JDBC_CLUSTERNAME
init|=
literal|"karaf.lock.jdbc.clustername"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_LOCK_JDBC_CACHE
init|=
literal|"karaf.lock.jdbc.cache"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_LOCK_JDBC_VALID_TIMEOUT
init|=
literal|"karaf.lock.jdbc.valid_timeout"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_PASSWORD
init|=
literal|""
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_USER
init|=
literal|""
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_TABLE
init|=
literal|"KARAF_LOCK"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_TABLE_ID
init|=
literal|"KARAF_NODE_ID"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_CLUSTERNAME
init|=
literal|"karaf"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_CACHE
init|=
literal|"true"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_VALID_TIMEOUT
init|=
literal|"0"
decl_stmt|;
specifier|final
name|GenericStatements
name|statements
decl_stmt|;
name|DataSource
name|dataSource
decl_stmt|;
name|String
name|url
decl_stmt|;
name|String
name|driver
decl_stmt|;
name|String
name|user
decl_stmt|;
name|String
name|password
decl_stmt|;
name|String
name|table
decl_stmt|;
name|String
name|clusterName
decl_stmt|;
name|String
name|table_id
decl_stmt|;
name|int
name|lock_delay
decl_stmt|;
comment|// My lock settings
specifier|private
name|int
name|uniqueId
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|state
init|=
literal|0
decl_stmt|;
comment|// Current master instance lock settings
specifier|private
name|int
name|currentId
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|currentState
init|=
literal|0
decl_stmt|;
comment|// The last clock time that the master instance state was updated as noticed by this instance.
specifier|private
name|long
name|currentStateTime
decl_stmt|;
comment|// The master lock delay time in milliseconds that the master is expected to update the karaf_lock
comment|// table state
specifier|private
name|int
name|currentLockDelay
decl_stmt|;
specifier|public
name|GenericJDBCLock
parameter_list|(
name|Properties
name|props
parameter_list|)
block|{
name|BootstrapLogManager
operator|.
name|configureLogger
argument_list|(
name|LOG
argument_list|)
expr_stmt|;
name|this
operator|.
name|url
operator|=
name|props
operator|.
name|getProperty
argument_list|(
name|PROPERTY_LOCK_URL
argument_list|)
expr_stmt|;
name|this
operator|.
name|driver
operator|=
name|props
operator|.
name|getProperty
argument_list|(
name|PROPERTY_LOCK_JDBC_DRIVER
argument_list|)
expr_stmt|;
name|this
operator|.
name|user
operator|=
name|props
operator|.
name|getProperty
argument_list|(
name|PROPERTY_LOCK_JDBC_USER
argument_list|,
name|DEFAULT_USER
argument_list|)
expr_stmt|;
name|this
operator|.
name|password
operator|=
name|props
operator|.
name|getProperty
argument_list|(
name|PROPERTY_LOCK_JDBC_PASSWORD
argument_list|,
name|DEFAULT_PASSWORD
argument_list|)
expr_stmt|;
name|this
operator|.
name|table
operator|=
name|props
operator|.
name|getProperty
argument_list|(
name|PROPERTY_LOCK_JDBC_TABLE
argument_list|,
name|DEFAULT_TABLE
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterName
operator|=
name|props
operator|.
name|getProperty
argument_list|(
name|PROPERTY_LOCK_JDBC_CLUSTERNAME
argument_list|,
name|DEFAULT_CLUSTERNAME
argument_list|)
expr_stmt|;
name|this
operator|.
name|table_id
operator|=
name|props
operator|.
name|getProperty
argument_list|(
name|PROPERTY_LOCK_JDBC_TABLE_ID
argument_list|,
name|DEFAULT_TABLE_ID
argument_list|)
expr_stmt|;
name|this
operator|.
name|lock_delay
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|props
operator|.
name|getProperty
argument_list|(
name|ConfigProperties
operator|.
name|PROPERTY_LOCK_DELAY
argument_list|,
name|ConfigProperties
operator|.
name|DEFAULT_LOCK_DELAY
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|statements
operator|=
name|createStatements
argument_list|()
expr_stmt|;
name|String
name|url
init|=
name|this
operator|.
name|url
decl_stmt|;
if|if
condition|(
name|url
operator|.
name|toLowerCase
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"jdbc:derby"
argument_list|)
condition|)
block|{
name|url
operator|=
operator|(
name|url
operator|.
name|toLowerCase
argument_list|()
operator|.
name|contains
argument_list|(
literal|"create=true"
argument_list|)
operator|)
condition|?
name|url
else|:
name|url
operator|+
literal|";create=true"
expr_stmt|;
block|}
name|boolean
name|cacheEnabled
init|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|props
operator|.
name|getProperty
argument_list|(
name|PROPERTY_LOCK_JDBC_CACHE
argument_list|,
name|DEFAULT_CACHE
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|validTimeout
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|props
operator|.
name|getProperty
argument_list|(
name|PROPERTY_LOCK_JDBC_VALID_TIMEOUT
argument_list|,
name|DEFAULT_VALID_TIMEOUT
argument_list|)
argument_list|)
decl_stmt|;
name|this
operator|.
name|dataSource
operator|=
operator|new
name|GenericDataSource
argument_list|(
name|driver
argument_list|,
name|url
argument_list|,
name|user
argument_list|,
name|password
argument_list|,
name|cacheEnabled
argument_list|,
name|validTimeout
argument_list|)
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
block|}
comment|/**      * This method is called to create an instance of the JDBCStatements instance.      *      * @return An instance of a JDBCStatement object.      */
name|GenericStatements
name|createStatements
parameter_list|()
block|{
return|return
operator|new
name|GenericStatements
argument_list|(
name|table
argument_list|,
name|table_id
argument_list|,
name|clusterName
argument_list|)
return|;
block|}
name|void
name|init
parameter_list|()
block|{
try|try
block|{
name|createDatabase
argument_list|()
expr_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|getConnection
argument_list|()
init|)
block|{
name|createSchema
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|generateUniqueId
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"Error occured while attempting to obtain connection"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|createDatabase
parameter_list|()
block|{
comment|// do nothing in the default implementation
block|}
comment|/**      * This method is called to check and create the required schemas that are used by this instance.      */
name|void
name|createSchema
parameter_list|(
name|Connection
name|connection
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|schemaExists
argument_list|(
name|connection
argument_list|)
condition|)
block|{
return|return;
block|}
try|try
init|(
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
init|)
block|{
name|connection
operator|.
name|setAutoCommit
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|String
index|[]
name|createStatements
init|=
name|this
operator|.
name|statements
operator|.
name|getLockCreateSchemaStatements
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|stmt
range|:
name|createStatements
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Executing statement: "
operator|+
name|stmt
argument_list|)
expr_stmt|;
name|statement
operator|.
name|execute
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
name|connection
operator|.
name|setAutoCommit
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|connection
operator|.
name|rollback
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"Could not create schema"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This method is called to determine if the required database schemas have already been created or not.      *      * @return True, if the schemas are available else false.      */
name|boolean
name|schemaExists
parameter_list|(
name|Connection
name|connection
parameter_list|)
block|{
return|return
name|schemaExist
argument_list|(
name|connection
argument_list|,
name|this
operator|.
name|statements
operator|.
name|getLockTableName
argument_list|()
argument_list|)
operator|&&
name|schemaExist
argument_list|(
name|connection
argument_list|,
name|this
operator|.
name|statements
operator|.
name|getLockIdTableName
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This method is called to determine if the required table is available or not.      *      * @param tableName The name of the table to determine if it exists.      * @return True, if the table exists else false.      */
specifier|private
name|boolean
name|schemaExist
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|tableName
parameter_list|)
block|{
name|boolean
name|schemaExists
init|=
literal|false
decl_stmt|;
try|try
init|(
name|ResultSet
name|rs
init|=
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getTables
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|tableName
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"TABLE"
block|}
argument_list|)
init|)
block|{
name|schemaExists
operator|=
name|rs
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignore
parameter_list|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"Error testing for db table"
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
block|}
return|return
name|schemaExists
return|;
block|}
comment|/**      * This method will generate a unique id for this instance that is part of an active set of instances.      * This method uses a simple algorithm to insure that the id will be unique for all cases.      */
name|void
name|generateUniqueId
parameter_list|(
name|Connection
name|connection
parameter_list|)
block|{
name|String
name|selectString
init|=
name|this
operator|.
name|statements
operator|.
name|getLockIdSelectStatement
argument_list|()
decl_stmt|;
try|try
init|(
name|PreparedStatement
name|selectStatement
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
name|selectString
argument_list|)
init|)
block|{
name|boolean
name|uniqueIdSet
init|=
literal|false
decl_stmt|;
comment|// This loop can only be performed for so long and the chances that this will be
comment|// looping for more than a few times is unlikely since there will always be at
comment|// least one instance that is successful.
while|while
condition|(
operator|!
name|uniqueIdSet
condition|)
block|{
comment|// Get the current ID from the karaf ids table
try|try
init|(
name|ResultSet
name|rs
init|=
name|selectStatement
operator|.
name|executeQuery
argument_list|()
init|)
block|{
comment|// Check if we were able to retrieve the result...
if|if
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
comment|// Update the row with the next available id
name|int
name|currentId
init|=
name|this
operator|.
name|statements
operator|.
name|getIdFromLockIdSelectStatement
argument_list|(
name|rs
argument_list|)
decl_stmt|;
name|String
name|updateString
init|=
name|this
operator|.
name|statements
operator|.
name|getLockIdUpdateIdStatement
argument_list|(
name|currentId
operator|+
literal|1
argument_list|,
name|currentId
argument_list|)
decl_stmt|;
try|try
init|(
name|PreparedStatement
name|updateStatement
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
name|updateString
argument_list|)
init|)
block|{
name|int
name|count
init|=
name|updateStatement
operator|.
name|executeUpdate
argument_list|()
decl_stmt|;
comment|// Set the uniqueId if and only if is it greater that zero
name|uniqueId
operator|=
operator|(
name|uniqueIdSet
operator|=
name|count
operator|>
literal|0
operator|)
condition|?
name|currentId
operator|+
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|LOG
operator|.
name|severe
argument_list|(
literal|"OOPS there are more than one row within the table ids..."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|severe
argument_list|(
literal|"No rows were found...."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"Received an SQL exception while processing result set"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"Received an SQL exception while generating a prepate statement"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"INSTANCE unique id: "
operator|+
name|uniqueId
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method will return an active connection for this given jdbc driver.      *      * @return The JDBC connection instance      * @throws Exception If the JDBC connection can't be retrieved.      */
specifier|protected
name|Connection
name|getConnection
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|dataSource
operator|.
name|getConnection
argument_list|()
return|;
block|}
comment|/**      * This method is called whenever we want to acquire/steal or update the lock.      * The different option depend if we are the competing for the master or the lock delay time      * has been exceeded or that we are the master and are update the state.      *      * @return True, if we are the master instance else false.      *      * @see org.apache.karaf.main.lock.Lock#lock()      */
specifier|public
name|boolean
name|lock
parameter_list|()
throws|throws
name|Exception
block|{
try|try
init|(
name|Connection
name|connection
init|=
name|getConnection
argument_list|()
init|)
block|{
comment|// Try to acquire/update the lock state
name|boolean
name|lockAcquired
init|=
name|acquireLock
argument_list|(
name|connection
argument_list|,
name|statements
operator|.
name|getLockUpdateIdStatement
argument_list|(
name|uniqueId
argument_list|,
operator|++
name|state
argument_list|,
name|lock_delay
argument_list|,
name|uniqueId
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lockAcquired
condition|)
block|{
name|String
name|lockSelectStatement
init|=
name|statements
operator|.
name|getLockSelectStatement
argument_list|()
decl_stmt|;
try|try
init|(
name|PreparedStatement
name|statement
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
name|lockSelectStatement
argument_list|)
init|)
block|{
comment|// Get the current master id and compare with information that we have locally....
try|try
init|(
name|ResultSet
name|rs
init|=
name|statement
operator|.
name|executeQuery
argument_list|()
init|)
block|{
if|if
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|int
name|currentId
init|=
name|statements
operator|.
name|getIdFromLockSelectStatement
argument_list|(
name|rs
argument_list|)
decl_stmt|;
comment|// The current master unique id or 0
name|int
name|currentState
init|=
name|statements
operator|.
name|getStateFromLockSelectStatement
argument_list|(
name|rs
argument_list|)
decl_stmt|;
comment|// The current master state or whatever
if|if
condition|(
name|this
operator|.
name|currentId
operator|==
name|currentId
condition|)
block|{
comment|// It is the same instance that locked the table
if|if
condition|(
name|this
operator|.
name|currentState
operator|==
name|currentState
condition|)
block|{
comment|// Its state has not been updated....
if|if
condition|(
operator|(
name|this
operator|.
name|currentStateTime
operator|+
name|this
operator|.
name|currentLockDelay
operator|+
name|this
operator|.
name|currentLockDelay
operator|)
operator|<
name|System
operator|.
name|currentTimeMillis
argument_list|()
condition|)
block|{
comment|// The state was not been updated for more than twice the lock_delay value of the current master...
comment|// Try to steal the lock....
name|lockAcquired
operator|=
name|acquireLock
argument_list|(
name|connection
argument_list|,
name|statements
operator|.
name|getLockUpdateIdStatementToStealLock
argument_list|(
name|uniqueId
argument_list|,
name|state
argument_list|,
name|lock_delay
argument_list|,
name|currentId
argument_list|,
name|currentState
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Set the current time to be used to determine if we can
comment|// try to steal the lock later...
name|this
operator|.
name|currentStateTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|this
operator|.
name|currentState
operator|=
name|currentState
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// This is a different currentId that is being used...
comment|// at this time, it does not matter if the new master id is zero we can try to acquire it
comment|// during the next lock call...
name|this
operator|.
name|currentId
operator|=
name|currentId
expr_stmt|;
name|this
operator|.
name|currentState
operator|=
name|currentState
expr_stmt|;
comment|// Update the current state time since this is a new lock service...
name|this
operator|.
name|currentStateTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
comment|// Get the lock delay value which is specific to the current master...
name|this
operator|.
name|currentLockDelay
operator|=
name|statements
operator|.
name|getLockDelayFromLockSelectStatement
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"Unable to determine if the lock was obtain"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|lockAcquired
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"Error while trying to obtain the lock"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**      * This method is called to try and acquire the lock and/or update the state for when this instance      * is already the master instance.  It will try to update the row given the passed data and will      * succeed if and only if the generated where clause was valid else it would not update the row.      *      * @param lockUpdateIdStatement The sql statement used to execute the update.      * @return True, if the row was updated else false.      */
specifier|private
name|boolean
name|acquireLock
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|lockUpdateIdStatement
parameter_list|)
block|{
try|try
init|(
name|PreparedStatement
name|preparedStatement
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
name|lockUpdateIdStatement
argument_list|)
init|)
block|{
comment|// This will only update the row that contains the ID of 0 or curId
return|return
name|preparedStatement
operator|.
name|executeUpdate
argument_list|()
operator|>
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Do we want to display this message everytime???
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"Failed to acquire database lock"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**      * This method will release the lock that the current master has by setting the karaf_lock table      * id to 0.  This tells the others that the master has relinquished the lock and someone else can      * try to acquire that lock and become a master.      *      * @see org.apache.karaf.main.lock.Lock#release()      */
specifier|public
name|void
name|release
parameter_list|()
throws|throws
name|Exception
block|{
try|try
init|(
name|Connection
name|connection
init|=
name|getConnection
argument_list|()
init|)
block|{
name|String
name|lockResetIdStatement
init|=
name|statements
operator|.
name|getLockResetIdStatement
argument_list|(
name|uniqueId
argument_list|)
decl_stmt|;
try|try
init|(
name|PreparedStatement
name|preparedStatement
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
name|lockResetIdStatement
argument_list|)
init|)
block|{
comment|// This statement will set the ID to 0 and allow others to steal the lock...
name|preparedStatement
operator|.
name|executeUpdate
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"Exception while releasing lock"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This method will check if the jdbc connection is still active and if we were able to       * acquire or update the karaf_table information.      *      * @return True, if the connection is still active and we still have the lock.      *      * @see org.apache.karaf.main.lock.Lock#isAlive()      *      */
specifier|public
name|boolean
name|isAlive
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|lock
argument_list|()
return|;
block|}
block|}
end_class

end_unit

