begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *  http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|region
operator|.
name|persist
operator|.
name|internal
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|Constants
import|;
end_import

begin_class
specifier|public
class|class
name|ManifestHeaderProcessor
block|{
specifier|public
specifier|static
specifier|final
name|String
name|NESTED_FILTER_ATTRIBUTE
init|=
literal|"org.apache.aries.application.filter.attribute"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Pattern
name|FILTER_ATTR
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"(\\(!)?\\((.*?)([<>]?=)(.*?)\\)\\)?"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|LESS_EQ_OP
init|=
literal|"<="
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|GREATER_EQ_OP
init|=
literal|">="
decl_stmt|;
comment|/**    * A simple class to associate two types.    *    */
specifier|public
specifier|static
class|class
name|NameValuePair
block|{
specifier|private
name|String
name|name
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|attributes
decl_stmt|;
specifier|public
name|NameValuePair
parameter_list|(
name|String
name|name
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|value
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|attributes
operator|=
name|value
expr_stmt|;
block|}
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
specifier|public
name|void
name|setName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getAttributes
parameter_list|()
block|{
return|return
name|attributes
return|;
block|}
specifier|public
name|void
name|setAttributes
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|value
parameter_list|)
block|{
name|this
operator|.
name|attributes
operator|=
name|value
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"{"
operator|+
name|name
operator|.
name|toString
argument_list|()
operator|+
literal|"::"
operator|+
name|attributes
operator|.
name|toString
argument_list|()
operator|+
literal|"}"
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
specifier|final
name|int
name|prime
init|=
literal|31
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
operator|(
operator|(
name|name
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|name
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
operator|(
operator|(
name|attributes
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|attributes
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|getClass
argument_list|()
operator|!=
name|obj
operator|.
name|getClass
argument_list|()
condition|)
return|return
literal|false
return|;
specifier|final
name|NameValuePair
name|other
init|=
operator|(
name|NameValuePair
operator|)
name|obj
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|name
operator|!=
literal|null
condition|)
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|name
operator|.
name|equals
argument_list|(
name|other
operator|.
name|name
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|attributes
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|attributes
operator|!=
literal|null
condition|)
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|attributes
operator|.
name|equals
argument_list|(
name|other
operator|.
name|attributes
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Intended to provide a standard way to add Name/Value's to    * aggregations of Name/Value's.    *    */
specifier|public
specifier|static
interface|interface
name|NameValueCollection
block|{
comment|/**      * Add this Name& Value to the collection.      * @param n      * @param v      */
specifier|public
name|void
name|addToCollection
parameter_list|(
name|String
name|n
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|v
parameter_list|)
function_decl|;
block|}
comment|/**    * Map of Name -> Value.    *    */
specifier|public
specifier|static
class|class
name|NameValueMap
extends|extends
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
implements|implements
name|NameValueCollection
implements|,
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|6446338858542599141L
decl_stmt|;
specifier|public
name|void
name|addToCollection
parameter_list|(
name|String
name|n
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|v
parameter_list|)
block|{
name|this
operator|.
name|put
argument_list|(
name|n
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|this
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|"->"
operator|+
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * List of Name/Value    *    */
specifier|public
specifier|static
class|class
name|NameValueList
extends|extends
name|ArrayList
argument_list|<
name|NameValuePair
argument_list|>
implements|implements
name|NameValueCollection
implements|,
name|List
argument_list|<
name|NameValuePair
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1808636823825029983L
decl_stmt|;
specifier|public
name|void
name|addToCollection
parameter_list|(
name|String
name|n
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|v
parameter_list|)
block|{
name|this
operator|.
name|add
argument_list|(
operator|new
name|NameValuePair
argument_list|(
name|n
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|NameValuePair
name|nvp
range|:
name|this
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|nvp
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    *    * Splits a delimiter separated string, tolerating presence of non separator commas    * within double quoted segments.    *    * Eg.    * com.ibm.ws.eba.helloWorldService;version="[1.0.0, 1.0.0]"&    * com.ibm.ws.eba.helloWorldService;version="1.0.0"    * com.ibm.ws.eba.helloWorld;version="2";bundle-version="[2,30)"    * com.acme.foo;weirdAttr="one;two;three";weirdDir:="1;2;3"    *  @param value          the value to be split    *  @param delimiter      the delimiter string such as ',' etc.    *  @return List<String>  the components of the split String in a list    */
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|split
parameter_list|(
name|String
name|value
parameter_list|,
name|String
name|delimiter
parameter_list|)
block|{
return|return
name|ManifestHeaderUtils
operator|.
name|split
argument_list|(
name|value
argument_list|,
name|delimiter
argument_list|)
return|;
block|}
comment|/**    * Internal method to parse headers with the format<p>    *   [Name](;[Name])*(;[attribute-name]=[attribute-value])*<br>    * Eg.<br>    *   rumplestiltskin;thing=value;other=something<br>    *   littleredridinghood    *   bundle1;bundle2;other=things    *   bundle1;bundle2    *    * @param s data to parse    * @return a list of NameValuePair, with the Name being the name component,    *         and the Value being a NameValueMap of key->value mappings.    */
specifier|private
specifier|static
name|List
argument_list|<
name|NameValuePair
argument_list|>
name|genericNameWithNameValuePairProcess
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|String
name|name
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|params
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|NameValuePair
argument_list|>
name|nameValues
init|=
operator|new
name|ArrayList
argument_list|<
name|NameValuePair
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|pkgs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|index
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|";"
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|name
operator|=
name|s
expr_stmt|;
name|params
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|pkgs
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
name|String
name|tail
init|=
name|s
operator|.
name|substring
argument_list|(
name|index
operator|+
literal|1
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|pkgs
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|// add the first package
name|StringBuilder
name|parameters
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// take into consideration of multiple packages separated by ';'
comment|// while they share the same attributes or directives
name|List
argument_list|<
name|String
argument_list|>
name|tailParts
init|=
name|split
argument_list|(
name|tail
argument_list|,
literal|";"
argument_list|)
decl_stmt|;
name|boolean
name|firstParameter
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|part
range|:
name|tailParts
control|)
block|{
comment|// if it is not a parameter and no parameter appears in front of it, it must a package
if|if
condition|(
operator|!
operator|!
operator|!
operator|(
name|part
operator|.
name|contains
argument_list|(
literal|"="
argument_list|)
operator|)
condition|)
block|{
comment|// Need to make sure no parameter appears before the package, otherwise ignore this string
comment|// as this syntax is invalid
if|if
condition|(
operator|!
operator|!
operator|!
operator|(
name|firstParameter
operator|)
condition|)
name|pkgs
operator|.
name|add
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|!
operator|!
operator|(
name|firstParameter
operator|)
condition|)
name|firstParameter
operator|=
literal|true
expr_stmt|;
name|parameters
operator|.
name|append
argument_list|(
name|part
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|parameters
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|//remove the final ';' if there is one
if|if
condition|(
name|parameters
operator|.
name|toString
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|";"
argument_list|)
condition|)
block|{
name|parameters
operator|=
name|parameters
operator|.
name|deleteCharAt
argument_list|(
name|parameters
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|params
operator|=
name|genericNameValueProcess
argument_list|(
name|parameters
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|String
name|pkg
range|:
name|pkgs
control|)
block|{
name|nameValues
operator|.
name|add
argument_list|(
operator|new
name|NameValuePair
argument_list|(
name|pkg
argument_list|,
name|params
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|nameValues
return|;
block|}
comment|/**    * Internal method to parse headers with the format<p>    *   [attribute-name]=[attribute-value](;[attribute-name]=[attribute-value])*<br>    * Eg.<br>    *   thing=value;other=something<br>    *<p>    * Note. Directives (name:=value) are represented in the map with name suffixed by ':'    *    * @param s data to parse    * @return a NameValueMap, with attribute-name -> attribute-value.    */
specifier|private
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|genericNameValueProcess
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|params
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|parameters
init|=
name|split
argument_list|(
name|s
argument_list|,
literal|";"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|parameter
range|:
name|parameters
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|parts
init|=
name|split
argument_list|(
name|parameter
argument_list|,
literal|"="
argument_list|)
decl_stmt|;
comment|// do a check, otherwise we might get NPE
if|if
condition|(
name|parts
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|String
name|second
init|=
name|parts
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|second
operator|.
name|startsWith
argument_list|(
literal|"\""
argument_list|)
operator|&&
name|second
operator|.
name|endsWith
argument_list|(
literal|"\""
argument_list|)
condition|)
name|second
operator|=
name|second
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|second
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|String
name|first
init|=
name|parts
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
comment|// make sure for directives we clear out any space as in "directive  :=value"
if|if
condition|(
name|first
operator|.
name|endsWith
argument_list|(
literal|":"
argument_list|)
condition|)
block|{
name|first
operator|=
name|first
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|first
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|trim
argument_list|()
operator|+
literal|":"
expr_stmt|;
block|}
name|params
operator|.
name|put
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|params
return|;
block|}
comment|/**    * Processes an import/export style header..<p>    *  pkg1;attrib=value;attrib=value,pkg2;attrib=value,pkg3;attrib=value    *    * @param out The collection to add each package name + attrib map to.    * @param s The data to parse    */
specifier|private
specifier|static
name|void
name|genericImportExportProcess
parameter_list|(
name|NameValueCollection
name|out
parameter_list|,
name|String
name|s
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|packages
init|=
name|split
argument_list|(
name|s
argument_list|,
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|pkg
range|:
name|packages
control|)
block|{
name|List
argument_list|<
name|NameValuePair
argument_list|>
name|ps
init|=
name|genericNameWithNameValuePairProcess
argument_list|(
name|pkg
argument_list|)
decl_stmt|;
for|for
control|(
name|NameValuePair
name|p
range|:
name|ps
control|)
block|{
name|out
operator|.
name|addToCollection
argument_list|(
name|p
operator|.
name|getName
argument_list|()
argument_list|,
name|p
operator|.
name|getAttributes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Parse an export style header.<p>    *   pkg1;attrib=value;attrib=value,pkg2;attrib=value,pkg3;attrib=value2    *<p>    * Result is returned as a list, as export does allow duplicate package exports.    *    * @param s The data to parse.    * @return List of NameValuePairs, where each Name in the list is an exported package,    *         with its associated Value being a NameValueMap of any attributes declared.    */
specifier|public
specifier|static
name|List
argument_list|<
name|NameValuePair
argument_list|>
name|parseExportString
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|NameValueList
name|retval
init|=
operator|new
name|NameValueList
argument_list|()
decl_stmt|;
name|genericImportExportProcess
argument_list|(
name|retval
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
comment|/**    * Parse an export style header in a list.<p>    *   pkg1;attrib=value;attrib=value    *   pkg2;attrib=value    *   pkg3;attrib=value2    *<p>    * Result is returned as a list, as export does allow duplicate package exports.    *    * @param list The data to parse.    * @return List of NameValuePairs, where each Name in the list is an exported package,    *         with its associated Value being a NameValueMap of any attributes declared.    */
specifier|public
specifier|static
name|List
argument_list|<
name|NameValuePair
argument_list|>
name|parseExportList
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|list
parameter_list|)
block|{
name|NameValueList
name|retval
init|=
operator|new
name|NameValueList
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|pkg
range|:
name|list
control|)
block|{
name|List
argument_list|<
name|NameValuePair
argument_list|>
name|ps
init|=
name|genericNameWithNameValuePairProcess
argument_list|(
name|pkg
argument_list|)
decl_stmt|;
for|for
control|(
name|NameValuePair
name|p
range|:
name|ps
control|)
block|{
name|retval
operator|.
name|addToCollection
argument_list|(
name|p
operator|.
name|getName
argument_list|()
argument_list|,
name|p
operator|.
name|getAttributes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/**    * Parse an import style header.<p>    *   pkg1;attrib=value;attrib=value,pkg2;attrib=value,pkg3;attrib=value    *<p>    * Result is returned as a set, as import does not allow duplicate package imports.    *    * @param s The data to parse.    * @return Map of NameValuePairs, where each Key in the Map is an imported package,    *         with its associated Value being a NameValueMap of any attributes declared.    */
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|parseImportString
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|NameValueMap
name|retval
init|=
operator|new
name|NameValueMap
argument_list|()
decl_stmt|;
name|genericImportExportProcess
argument_list|(
name|retval
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
comment|/**    * Parse a bundle symbolic name.<p>    *   bundlesymbolicname;attrib=value;attrib=value    *<p>    *    * @param s The data to parse.    * @return NameValuePair with Name being the BundleSymbolicName,    *         and Value being any attribs declared for the name.    */
specifier|public
specifier|static
name|NameValuePair
name|parseBundleSymbolicName
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|genericNameWithNameValuePairProcess
argument_list|(
name|s
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
comment|// should just return the first one
block|}
comment|/**    * Parse a version range..    *    * @param s    * @return VersionRange object.    * @throws IllegalArgumentException if the String could not be parsed as a VersionRange    */
specifier|public
specifier|static
name|VersionRange
name|parseVersionRange
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
return|return
operator|new
name|VersionRange
argument_list|(
name|s
argument_list|)
return|;
block|}
comment|/**    * Parse a version range and indicate if the version is an exact version    *    * @param s    * @param exactVersion    * @return VersionRange object.    * @throws IllegalArgumentException if the String could not be parsed as a VersionRange    */
specifier|public
specifier|static
name|VersionRange
name|parseVersionRange
parameter_list|(
name|String
name|s
parameter_list|,
name|boolean
name|exactVersion
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
return|return
operator|new
name|VersionRange
argument_list|(
name|s
argument_list|,
name|exactVersion
argument_list|)
return|;
block|}
comment|/** 	 * Generate a filter from a set of attributes. This filter will be suitable 	 * for presentation to OBR This means that, due to the way OBR works, it 	 * will include a stanza of the form, (mandatory:<*mandatoryAttribute) 	 * Filter strings generated by this method will therefore tend to break the 	 * standard OSGi Filter class. The OBR stanza can be stripped out later if 	 * required. 	 * 	 * @param attribs 	 * @return filter string 	 */
specifier|public
specifier|static
name|String
name|generateFilter
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|attribs
parameter_list|)
block|{
name|StringBuilder
name|filter
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"(&"
argument_list|)
decl_stmt|;
name|boolean
name|realAttrib
init|=
literal|false
decl_stmt|;
name|StringBuffer
name|realAttribs
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|attribs
operator|==
literal|null
condition|)
block|{
name|attribs
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|attrib
range|:
name|attribs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|attribName
init|=
name|attrib
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|attribName
operator|.
name|endsWith
argument_list|(
literal|":"
argument_list|)
condition|)
block|{
comment|// skip all directives. It is used to affect the attribs on the
comment|// filter xml.
block|}
elseif|else
if|if
condition|(
operator|(
name|Constants
operator|.
name|VERSION_ATTRIBUTE
operator|.
name|equals
argument_list|(
name|attribName
argument_list|)
operator|)
operator|||
operator|(
name|Constants
operator|.
name|BUNDLE_VERSION_ATTRIBUTE
operator|.
name|equals
argument_list|(
name|attribName
argument_list|)
operator|)
condition|)
block|{
comment|// version and bundle-version attrib requires special
comment|// conversion.
name|realAttrib
operator|=
literal|true
expr_stmt|;
name|VersionRange
name|vr
init|=
name|ManifestHeaderProcessor
operator|.
name|parseVersionRange
argument_list|(
name|attrib
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|filter
operator|.
name|append
argument_list|(
literal|"("
operator|+
name|attribName
operator|+
literal|">="
operator|+
name|vr
operator|.
name|getMinimumVersion
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|vr
operator|.
name|getMaximumVersion
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|filter
operator|.
name|append
argument_list|(
literal|")("
operator|+
name|attribName
operator|+
literal|"<="
argument_list|)
expr_stmt|;
name|filter
operator|.
name|append
argument_list|(
name|vr
operator|.
name|getMaximumVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vr
operator|.
name|getMaximumVersion
argument_list|()
operator|!=
literal|null
operator|&&
name|vr
operator|.
name|isMinimumExclusive
argument_list|()
condition|)
block|{
name|filter
operator|.
name|append
argument_list|(
literal|")(!("
operator|+
name|attribName
operator|+
literal|"="
argument_list|)
expr_stmt|;
name|filter
operator|.
name|append
argument_list|(
name|vr
operator|.
name|getMinimumVersion
argument_list|()
argument_list|)
expr_stmt|;
name|filter
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vr
operator|.
name|getMaximumVersion
argument_list|()
operator|!=
literal|null
operator|&&
name|vr
operator|.
name|isMaximumExclusive
argument_list|()
condition|)
block|{
name|filter
operator|.
name|append
argument_list|(
literal|")(!("
operator|+
name|attribName
operator|+
literal|"="
argument_list|)
expr_stmt|;
name|filter
operator|.
name|append
argument_list|(
name|vr
operator|.
name|getMaximumVersion
argument_list|()
argument_list|)
expr_stmt|;
name|filter
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|filter
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NESTED_FILTER_ATTRIBUTE
operator|.
name|equals
argument_list|(
name|attribName
argument_list|)
condition|)
block|{
comment|// Filters go in whole, no formatting needed
name|realAttrib
operator|=
literal|true
expr_stmt|;
name|filter
operator|.
name|append
argument_list|(
name|attrib
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Constants
operator|.
name|OBJECTCLASS
operator|.
name|equals
argument_list|(
name|attribName
argument_list|)
condition|)
block|{
name|realAttrib
operator|=
literal|true
expr_stmt|;
comment|// objectClass has a "," separated list of interfaces
name|String
index|[]
name|values
init|=
name|attrib
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|values
control|)
name|filter
operator|.
name|append
argument_list|(
literal|"("
operator|+
name|Constants
operator|.
name|OBJECTCLASS
operator|+
literal|"="
operator|+
name|s
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// attribName was not version..
name|realAttrib
operator|=
literal|true
expr_stmt|;
name|filter
operator|.
name|append
argument_list|(
literal|"("
operator|+
name|attribName
operator|+
literal|"="
operator|+
name|attrib
operator|.
name|getValue
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// store all attributes in order to build up the mandatory
comment|// filter and separate them with ", "
comment|// skip bundle-symbolic-name in the mandatory directive query
if|if
condition|(
operator|!
operator|!
operator|!
name|Constants
operator|.
name|BUNDLE_SYMBOLICNAME_ATTRIBUTE
operator|.
name|equals
argument_list|(
name|attribName
argument_list|)
condition|)
block|{
name|realAttribs
operator|.
name|append
argument_list|(
name|attribName
argument_list|)
expr_stmt|;
name|realAttribs
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//		/*
comment|//		 * The following is how OBR makes mandatory attributes work, we require
comment|//		 * that the set of mandatory attributes on the export is a subset of (or
comment|//		 * equal to) the set of the attributes we supply.
comment|//		 */
comment|//
comment|//		if (realAttribs.length()> 0) {
comment|//			String attribStr = (realAttribs.toString()).trim();
comment|//			// remove the final ,
comment|//			if ((attribStr.length()> 0)&& (attribStr.endsWith(","))) {
comment|//				attribStr = attribStr.substring(0, attribStr.length() - 1);
comment|//			}
comment|//			// build the mandatory filter, e.g.(mandatory:&lt;*company, local)
comment|//			filter.append("(" + Constants.MANDATORY_DIRECTIVE + ":" + "<*"
comment|//					+ attribStr + ")");
comment|//		}
comment|// Prune (& off the front and ) off end
name|String
name|filterString
init|=
name|filter
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|openBraces
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|openBraces
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|i
operator|=
name|filterString
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
else|else
block|{
name|openBraces
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|openBraces
argument_list|<
literal|3
operator|&&
name|filterString
operator|.
name|length
operator|(
operator|)
argument_list|>
literal|2
condition|)
block|{
name|filter
operator|.
name|delete
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|filter
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|String
name|result
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|realAttrib
operator|!=
literal|false
condition|)
block|{
name|result
operator|=
name|filter
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Generate a filter from a set of attributes. This filter will be suitable    * for presentation to OBR. This means that, due to the way OBR works, it will    * include a stanza of the form, (mandatory:<*mandatoryAttribute) Filter    * strings generated by this method will therefore tend to break the standard    * OSGi Filter class. The OBR stanza can be stripped out later if required.    *    * We may wish to consider relocating this method since VersionRange has its    * own top level class.    *    * @param type    * @param name    * @param attribs    * @return filter string    */
specifier|public
specifier|static
name|String
name|generateFilter
parameter_list|(
name|String
name|type
parameter_list|,
name|String
name|name
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|attribs
parameter_list|)
block|{
name|StringBuffer
name|filter
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|String
name|result
decl_stmt|;
comment|// shortcut for the simple case with no attribs.
if|if
condition|(
name|attribs
operator|==
literal|null
operator|||
name|attribs
operator|.
name|isEmpty
argument_list|()
condition|)
name|filter
operator|.
name|append
argument_list|(
literal|"("
operator|+
name|type
operator|+
literal|"="
operator|+
name|name
operator|+
literal|")"
argument_list|)
expr_stmt|;
else|else
block|{
comment|// process all the attribs passed.
comment|// find out whether there are attributes on the filter
name|filter
operator|.
name|append
argument_list|(
literal|"(&("
operator|+
name|type
operator|+
literal|"="
operator|+
name|name
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|String
name|filterString
init|=
name|generateFilter
argument_list|(
name|attribs
argument_list|)
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
name|int
name|end
init|=
name|filterString
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|filterString
operator|.
name|startsWith
argument_list|(
literal|"(&"
argument_list|)
condition|)
block|{
name|start
operator|=
literal|2
expr_stmt|;
name|end
operator|--
expr_stmt|;
block|}
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|filterString
argument_list|)
condition|)
block|{
name|filter
operator|.
name|delete
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|filter
operator|.
name|append
argument_list|(
name|filterString
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|filter
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
name|filter
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|parseFilterList
parameter_list|(
name|String
name|filter
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|negatedVersions
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|negatedBundleVersions
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|lowerVersion
init|=
literal|null
decl_stmt|;
name|String
name|upperVersion
init|=
literal|null
decl_stmt|;
name|String
name|lowerBundleVersion
init|=
literal|null
decl_stmt|;
name|String
name|upperBundleVersion
init|=
literal|null
decl_stmt|;
name|Matcher
name|m
init|=
name|FILTER_ATTR
operator|.
name|matcher
argument_list|(
name|filter
argument_list|)
decl_stmt|;
while|while
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
name|boolean
name|negation
init|=
name|m
operator|.
name|group
argument_list|(
literal|1
argument_list|)
operator|!=
literal|null
decl_stmt|;
name|String
name|attr
init|=
name|m
operator|.
name|group
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|String
name|op
init|=
name|m
operator|.
name|group
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|m
operator|.
name|group
argument_list|(
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|Constants
operator|.
name|VERSION_ATTRIBUTE
operator|.
name|equals
argument_list|(
name|attr
argument_list|)
condition|)
block|{
if|if
condition|(
name|negation
condition|)
block|{
name|negatedVersions
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|GREATER_EQ_OP
operator|.
name|equals
argument_list|(
name|op
argument_list|)
condition|)
name|lowerVersion
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|LESS_EQ_OP
operator|.
name|equals
argument_list|(
name|op
argument_list|)
condition|)
name|upperVersion
operator|=
name|value
expr_stmt|;
else|else
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|Constants
operator|.
name|BUNDLE_VERSION_ATTRIBUTE
operator|.
name|equals
argument_list|(
name|attr
argument_list|)
condition|)
block|{
comment|// bundle-version is like version, but may be specified at the
comment|// same time
comment|// therefore we have similar code with separate variables
if|if
condition|(
name|negation
condition|)
block|{
name|negatedBundleVersions
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|GREATER_EQ_OP
operator|.
name|equals
argument_list|(
name|op
argument_list|)
condition|)
name|lowerBundleVersion
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|LESS_EQ_OP
operator|.
name|equals
argument_list|(
name|op
argument_list|)
condition|)
name|upperBundleVersion
operator|=
name|value
expr_stmt|;
else|else
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
block|}
else|else
block|{
name|result
operator|.
name|put
argument_list|(
name|attr
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lowerVersion
operator|!=
literal|null
condition|)
block|{
name|StringBuilder
name|versionAttr
init|=
operator|new
name|StringBuilder
argument_list|(
name|lowerVersion
argument_list|)
decl_stmt|;
if|if
condition|(
name|upperVersion
operator|!=
literal|null
condition|)
block|{
name|versionAttr
operator|.
name|append
argument_list|(
literal|","
argument_list|)
operator|.
name|append
argument_list|(
name|upperVersion
argument_list|)
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|negatedVersions
operator|.
name|contains
argument_list|(
name|lowerVersion
argument_list|)
condition|?
literal|'('
else|:
literal|'['
argument_list|)
operator|.
name|append
argument_list|(
name|negatedVersions
operator|.
name|contains
argument_list|(
name|upperVersion
argument_list|)
condition|?
literal|')'
else|:
literal|']'
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|put
argument_list|(
name|Constants
operator|.
name|VERSION_ATTRIBUTE
argument_list|,
name|versionAttr
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Do it again for bundle-version
if|if
condition|(
name|lowerBundleVersion
operator|!=
literal|null
condition|)
block|{
name|StringBuilder
name|versionAttr
init|=
operator|new
name|StringBuilder
argument_list|(
name|lowerBundleVersion
argument_list|)
decl_stmt|;
if|if
condition|(
name|upperBundleVersion
operator|!=
literal|null
condition|)
block|{
name|versionAttr
operator|.
name|append
argument_list|(
literal|","
argument_list|)
operator|.
name|append
argument_list|(
name|upperBundleVersion
argument_list|)
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|negatedBundleVersions
operator|.
name|contains
argument_list|(
name|lowerBundleVersion
argument_list|)
condition|?
literal|'('
else|:
literal|'['
argument_list|)
operator|.
name|append
argument_list|(
name|negatedBundleVersions
operator|.
name|contains
argument_list|(
name|upperBundleVersion
argument_list|)
condition|?
literal|')'
else|:
literal|']'
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|put
argument_list|(
name|Constants
operator|.
name|BUNDLE_VERSION_ATTRIBUTE
argument_list|,
name|versionAttr
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|parseFilter
parameter_list|(
name|String
name|filter
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
name|filter
operator|.
name|startsWith
argument_list|(
literal|"(&"
argument_list|)
condition|)
block|{
name|result
operator|=
name|parseFilterList
argument_list|(
name|filter
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|filter
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|parseFilterList
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
end_class

end_unit

