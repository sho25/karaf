begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|tooling
operator|.
name|features
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|JarInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|Manifest
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|bind
operator|.
name|JAXBException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|ParserConfigurationException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|features
operator|.
name|internal
operator|.
name|model
operator|.
name|Bundle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|features
operator|.
name|internal
operator|.
name|model
operator|.
name|Dependency
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|features
operator|.
name|internal
operator|.
name|model
operator|.
name|Feature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|features
operator|.
name|internal
operator|.
name|model
operator|.
name|Features
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|features
operator|.
name|internal
operator|.
name|model
operator|.
name|JaxbUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|features
operator|.
name|internal
operator|.
name|model
operator|.
name|ObjectFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|tooling
operator|.
name|utils
operator|.
name|DependencyHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|tooling
operator|.
name|utils
operator|.
name|DependencyHelperFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|tooling
operator|.
name|utils
operator|.
name|ManifestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|tooling
operator|.
name|utils
operator|.
name|MojoSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|resolver
operator|.
name|ArtifactNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|resolver
operator|.
name|ArtifactResolutionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|execution
operator|.
name|MavenSession
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|plugin
operator|.
name|MojoExecutionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|plugin
operator|.
name|MojoFailureException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|plugin
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|plugin
operator|.
name|logging
operator|.
name|SystemStreamLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|plugins
operator|.
name|annotations
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|plugins
operator|.
name|annotations
operator|.
name|LifecyclePhase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|plugins
operator|.
name|annotations
operator|.
name|Mojo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|plugins
operator|.
name|annotations
operator|.
name|Parameter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|plugins
operator|.
name|annotations
operator|.
name|ResolutionScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|project
operator|.
name|MavenProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|shared
operator|.
name|filtering
operator|.
name|MavenFileFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|shared
operator|.
name|filtering
operator|.
name|MavenFilteringException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|shared
operator|.
name|filtering
operator|.
name|MavenResourcesExecution
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|shared
operator|.
name|filtering
operator|.
name|MavenResourcesFiltering
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|plexus
operator|.
name|PlexusContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|plexus
operator|.
name|util
operator|.
name|ReaderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|plexus
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|deployer
operator|.
name|kar
operator|.
name|KarArtifactInstaller
operator|.
name|FEATURE_CLASSIFIER
import|;
end_import

begin_comment
comment|/**  * Generates the features XML file starting with an optional source feature.xml and adding  * project dependencies as bundles and feature/car dependencies.  *   * NB this requires a recent maven-install-plugin such as 2.3.1  */
end_comment

begin_class
annotation|@
name|Mojo
argument_list|(
name|name
operator|=
literal|"features-generate-descriptor"
argument_list|,
name|defaultPhase
operator|=
name|LifecyclePhase
operator|.
name|COMPILE
argument_list|,
name|requiresDependencyResolution
operator|=
name|ResolutionScope
operator|.
name|RUNTIME
argument_list|)
specifier|public
class|class
name|GenerateDescriptorMojo
extends|extends
name|MojoSupport
block|{
comment|/**      * An (optional) input feature file to extend. The plugin reads this file, and uses it as a template      * to create the output.      * This is highly recommended as it is the only way to add<code>&lt;feature/&gt;</code>      * elements to the individual features that are generated.  Note that this file is filtered using standard Maven      * resource interpolation, allowing attributes of the input file to be set with information such as ${project.version}      * from the current build.      *<p/>      * When dependencies are processed, if they are duplicated in this file, the dependency here provides the baseline      * information and is supplemented by additional information from the dependency.      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"${project.basedir}/src/main/feature/feature.xml"
argument_list|)
specifier|private
name|File
name|inputFile
decl_stmt|;
comment|/**      * (wrapper) The filtered input file. This file holds the result of Maven resource interpolation and is generally      * not necessary to change, although it may be helpful for debugging.      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"${project.build.directory}/feature/filteredInputFeature.xml"
argument_list|)
specifier|private
name|File
name|filteredInputFile
decl_stmt|;
comment|/**      * The file to generate.  This file is attached as a project output artifact with the classifier specified by      *<code>attachmentArtifactClassifier</code>.      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"${project.build.directory}/feature/feature.xml"
argument_list|)
specifier|private
name|File
name|outputFile
decl_stmt|;
comment|/**      * Exclude some artifacts from the generated feature.      * See addBundlesToPrimaryFeature for more details.      *      */
annotation|@
name|Parameter
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|excludedArtifactIds
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * The resolver to use for the feature.  Normally null or "OBR" or "(OBR)"      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"${resolver}"
argument_list|)
specifier|private
name|String
name|resolver
decl_stmt|;
comment|/**      * The artifact type for attaching the generated file to the project      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"xml"
argument_list|)
specifier|private
name|String
name|attachmentArtifactType
init|=
literal|"xml"
decl_stmt|;
comment|/**      * (wrapper) The artifact classifier for attaching the generated file to the project      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"features"
argument_list|)
specifier|private
name|String
name|attachmentArtifactClassifier
init|=
literal|"features"
decl_stmt|;
comment|/**      * Specifies whether features dependencies of this project will be included inline in the      * final output (<code>true</code>), or simply referenced as output artifact dependencies (<code>false</code>).      * If<code>true</code>, feature dependencies' xml descriptors are read and their contents added to the features descriptor under assembly.      * If<code>false</code>, feature dependencies are added to the assembled feature as dependencies.      * Setting this value to<code>true</code> is especially helpful in multiproject builds where subprojects build their own features      * using<code>aggregateFeatures = false</code>, then combined with<code>aggregateFeatures = true</code> in an      * aggregation project with explicit dependencies to the child projects.      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"false"
argument_list|)
specifier|private
name|boolean
name|aggregateFeatures
init|=
literal|false
decl_stmt|;
comment|/**      * If present, the bundles added to the feature constructed from the dependencies will be marked with this default      * startlevel.  If this parameter is not present, no startlevel attribute will be created. Finer resolution for specific      * dependencies can be obtained by specifying the dependency in the file referenced by the<code>inputFile</code> parameter.      */
annotation|@
name|Parameter
specifier|private
name|Integer
name|startLevel
decl_stmt|;
comment|/**      * Installation mode. If present, generate "feature.install" attribute:      *<p/>      *<a href="http://karaf.apache.org/xmlns/features/v1.1.0">Installation mode</a>      *<p/>      * Can be either manual or auto. Specifies whether the feature should be automatically installed when      * dropped inside the deploy folder. Note: this attribute doesn't affect feature descriptors that are installed      * from the feature:install command or as part of the etc/org.apache.karaf.features.cfg file.      */
annotation|@
name|Parameter
specifier|private
name|String
name|installMode
decl_stmt|;
comment|/**      * Flag indicating whether transitive dependencies should be included (<code>true</code>) or not (<code>false</code>).      *<p/>      * N.B. Note the default value of this is true, but is suboptimal in cases where specific<code>&lt;feature/&gt;</code> dependencies are      * provided by the<code>inputFile</code> parameter.      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"true"
argument_list|)
specifier|private
name|boolean
name|includeTransitiveDependency
decl_stmt|;
comment|/**      * The standard behavior is to add dependencies as<code>&lt;bundle&gt;</code> elements to a<code>&lt;feature&gt;</code>      * with the same name as the artifactId of the project.  This flag disables that behavior.      * If this parameter is<code>true</code>, then two other parameters refine the list of bundles added to the primary feature:      *<code>excludedArtifactIds</code> and<code>ignoreScopeProvided</code>. Each of these specifies dependent artifacts      * that should<strong>not</strong> be added to the primary feature.      *<p>      *     Note that you may tune the<code>bundle</code> elements by including them in the<code>inputFile</code>.      *     If the<code>inputFile</code> has a<code>feature</code> element for the primary feature, the plugin will      *     respect it, so that you can, for example, set the<code>startLevel</code> or<code>start</code> attribute.      *</p>      *      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"true"
argument_list|)
specifier|private
name|boolean
name|addBundlesToPrimaryFeature
decl_stmt|;
comment|/**      * The standard behavior is to add any dependencies other than those in the<code>runtime</code> scope to the feature bundle.      * Setting this flag to "true" disables adding any dependencies (transient or otherwise) that are in      *<code>&lt;scope&gt;provided&lt;/scope&gt;</code>. See<code>addBundlesToPrimaryFeature</code> for more details.      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"false"
argument_list|)
specifier|private
name|boolean
name|ignoreScopeProvided
decl_stmt|;
comment|/**      * Flag indicating whether the main project artifact should be included (<code>true</code>) or not (<code>false</code>).      * This parameter is useful when you add an execution of this plugin to a project with some packaging that is<strong>not</strong>      *<code>feature</code>. If you don't set this, then you will get a feature that contains the dependencies but      * not the primary artifact itself.      *<p/>      * Assumes the main project artifact is a bundle and the feature will be attached alongside using<code>attachmentArtifactClassifier</code>.      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"false"
argument_list|)
specifier|private
name|boolean
name|includeProjectArtifact
decl_stmt|;
comment|// *************************************************
comment|// READ-ONLY MAVEN PLUGIN PARAMETERS
comment|// *************************************************
comment|/**      * We can't autowire strongly typed RepositorySystem from Aether because it may be Sonatype (Maven 3.0.x)      * or Eclipse (Maven 3.1.x/3.2.x) implementation, so we switch to service locator.      */
annotation|@
name|Component
specifier|private
name|PlexusContainer
name|container
decl_stmt|;
annotation|@
name|Component
specifier|protected
name|MavenResourcesFiltering
name|mavenResourcesFiltering
decl_stmt|;
annotation|@
name|Component
specifier|protected
name|MavenFileFilter
name|mavenFileFilter
decl_stmt|;
comment|// dependencies we are interested in
specifier|protected
name|Map
argument_list|<
name|?
argument_list|,
name|String
argument_list|>
name|localDependencies
decl_stmt|;
comment|// log of what happened during search
specifier|protected
name|String
name|treeListing
decl_stmt|;
comment|// an access layer for available Aether implementation
specifier|protected
name|DependencyHelper
name|dependencyHelper
decl_stmt|;
comment|// maven log
specifier|private
name|Log
name|log
decl_stmt|;
specifier|public
name|void
name|execute
parameter_list|()
throws|throws
name|MojoExecutionException
throws|,
name|MojoFailureException
block|{
try|try
block|{
name|this
operator|.
name|dependencyHelper
operator|=
name|DependencyHelperFactory
operator|.
name|createDependencyHelper
argument_list|(
name|this
operator|.
name|container
argument_list|,
name|this
operator|.
name|project
argument_list|,
name|this
operator|.
name|mavenSession
argument_list|,
name|getLog
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|dependencyHelper
operator|.
name|getDependencies
argument_list|(
name|project
argument_list|,
name|includeTransitiveDependency
argument_list|)
expr_stmt|;
name|this
operator|.
name|localDependencies
operator|=
name|dependencyHelper
operator|.
name|getLocalDependencies
argument_list|()
expr_stmt|;
name|this
operator|.
name|treeListing
operator|=
name|dependencyHelper
operator|.
name|getTreeListing
argument_list|()
expr_stmt|;
name|File
name|dir
init|=
name|outputFile
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|dir
operator|.
name|isDirectory
argument_list|()
operator|||
name|dir
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
name|PrintStream
name|out
init|=
operator|new
name|PrintStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|outputFile
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|writeFeatures
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// now lets attach it
name|projectHelper
operator|.
name|attachArtifact
argument_list|(
name|project
argument_list|,
name|attachmentArtifactType
argument_list|,
name|attachmentArtifactClassifier
argument_list|,
name|outputFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|MojoExecutionException
argument_list|(
literal|"Could not create directory for features file: "
operator|+
name|dir
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|getLog
argument_list|()
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MojoExecutionException
argument_list|(
literal|"Unable to create features.xml file: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/*      * Write all project dependencies as feature      */
specifier|private
name|void
name|writeFeatures
parameter_list|(
name|PrintStream
name|out
parameter_list|)
throws|throws
name|ArtifactResolutionException
throws|,
name|ArtifactNotFoundException
throws|,
name|IOException
throws|,
name|JAXBException
throws|,
name|SAXException
throws|,
name|ParserConfigurationException
throws|,
name|XMLStreamException
throws|,
name|MojoExecutionException
block|{
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"Generating feature descriptor file "
operator|+
name|outputFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
comment|//read in an existing feature.xml
name|ObjectFactory
name|objectFactory
init|=
operator|new
name|ObjectFactory
argument_list|()
decl_stmt|;
name|Features
name|features
decl_stmt|;
if|if
condition|(
name|inputFile
operator|.
name|exists
argument_list|()
condition|)
block|{
name|filter
argument_list|(
name|inputFile
argument_list|,
name|filteredInputFile
argument_list|)
expr_stmt|;
name|features
operator|=
name|readFeaturesFile
argument_list|(
name|filteredInputFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|features
operator|=
name|objectFactory
operator|.
name|createFeaturesRoot
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|features
operator|.
name|getName
argument_list|()
operator|==
literal|null
condition|)
block|{
name|features
operator|.
name|setName
argument_list|(
name|project
operator|.
name|getArtifactId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Feature
name|feature
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Feature
name|test
range|:
name|features
operator|.
name|getFeature
argument_list|()
control|)
block|{
if|if
condition|(
name|test
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|project
operator|.
name|getArtifactId
argument_list|()
argument_list|)
condition|)
block|{
name|feature
operator|=
name|test
expr_stmt|;
block|}
block|}
if|if
condition|(
name|feature
operator|==
literal|null
condition|)
block|{
name|feature
operator|=
name|objectFactory
operator|.
name|createFeature
argument_list|()
expr_stmt|;
name|feature
operator|.
name|setName
argument_list|(
name|project
operator|.
name|getArtifactId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|feature
operator|.
name|hasVersion
argument_list|()
condition|)
block|{
name|feature
operator|.
name|setVersion
argument_list|(
name|project
operator|.
name|getArtifact
argument_list|()
operator|.
name|getBaseVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|feature
operator|.
name|getDescription
argument_list|()
operator|==
literal|null
condition|)
block|{
name|feature
operator|.
name|setDescription
argument_list|(
name|project
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resolver
operator|!=
literal|null
condition|)
block|{
name|feature
operator|.
name|setResolver
argument_list|(
name|resolver
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|installMode
operator|!=
literal|null
condition|)
block|{
name|feature
operator|.
name|setInstall
argument_list|(
name|installMode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|project
operator|.
name|getDescription
argument_list|()
operator|!=
literal|null
operator|&&
name|feature
operator|.
name|getDetails
argument_list|()
operator|==
literal|null
condition|)
block|{
name|feature
operator|.
name|setDetails
argument_list|(
name|project
operator|.
name|getDescription
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|includeProjectArtifact
condition|)
block|{
name|Bundle
name|bundle
init|=
name|objectFactory
operator|.
name|createBundle
argument_list|()
decl_stmt|;
name|bundle
operator|.
name|setLocation
argument_list|(
name|this
operator|.
name|dependencyHelper
operator|.
name|artifactToMvn
argument_list|(
name|project
operator|.
name|getArtifact
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|startLevel
operator|!=
literal|null
condition|)
block|{
name|bundle
operator|.
name|setStartLevel
argument_list|(
name|startLevel
argument_list|)
expr_stmt|;
block|}
name|feature
operator|.
name|getBundle
argument_list|()
operator|.
name|add
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|localDependencies
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Object
name|artifact
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|excludedArtifactIds
operator|.
name|contains
argument_list|(
name|this
operator|.
name|dependencyHelper
operator|.
name|getArtifactId
argument_list|(
name|artifact
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|this
operator|.
name|dependencyHelper
operator|.
name|isArtifactAFeature
argument_list|(
name|artifact
argument_list|)
condition|)
block|{
if|if
condition|(
name|aggregateFeatures
operator|&&
name|FEATURE_CLASSIFIER
operator|.
name|equals
argument_list|(
name|this
operator|.
name|dependencyHelper
operator|.
name|getClassifier
argument_list|(
name|artifact
argument_list|)
argument_list|)
condition|)
block|{
name|File
name|featuresFile
init|=
name|this
operator|.
name|dependencyHelper
operator|.
name|resolve
argument_list|(
name|artifact
argument_list|,
name|getLog
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|featuresFile
operator|==
literal|null
operator|||
operator|!
name|featuresFile
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MojoExecutionException
argument_list|(
literal|"Cannot locate file for feature: "
operator|+
name|artifact
operator|+
literal|" at "
operator|+
name|featuresFile
argument_list|)
throw|;
block|}
name|Features
name|includedFeatures
init|=
name|readFeaturesFile
argument_list|(
name|featuresFile
argument_list|)
decl_stmt|;
comment|//TODO check for duplicates?
name|features
operator|.
name|getFeature
argument_list|()
operator|.
name|addAll
argument_list|(
name|includedFeatures
operator|.
name|getFeature
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|addBundlesToPrimaryFeature
condition|)
block|{
name|String
name|bundleName
init|=
name|this
operator|.
name|dependencyHelper
operator|.
name|artifactToMvn
argument_list|(
name|artifact
argument_list|)
decl_stmt|;
name|File
name|bundleFile
init|=
name|this
operator|.
name|dependencyHelper
operator|.
name|resolve
argument_list|(
name|artifact
argument_list|,
name|getLog
argument_list|()
argument_list|)
decl_stmt|;
name|Manifest
name|manifest
init|=
name|getManifest
argument_list|(
name|bundleFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|manifest
operator|==
literal|null
operator|||
operator|!
name|ManifestUtils
operator|.
name|isBundle
argument_list|(
name|getManifest
argument_list|(
name|bundleFile
argument_list|)
argument_list|)
condition|)
block|{
name|bundleName
operator|=
literal|"wrap:"
operator|+
name|bundleName
expr_stmt|;
block|}
name|Bundle
name|bundle
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Bundle
name|b
range|:
name|feature
operator|.
name|getBundle
argument_list|()
control|)
block|{
if|if
condition|(
name|bundleName
operator|.
name|equals
argument_list|(
name|b
operator|.
name|getLocation
argument_list|()
argument_list|)
condition|)
block|{
name|bundle
operator|=
name|b
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bundle
operator|==
literal|null
condition|)
block|{
name|bundle
operator|=
name|objectFactory
operator|.
name|createBundle
argument_list|()
expr_stmt|;
name|bundle
operator|.
name|setLocation
argument_list|(
name|bundleName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
literal|"provided"
operator|.
name|equals
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
operator|||
operator|!
name|ignoreScopeProvided
condition|)
block|{
name|feature
operator|.
name|getBundle
argument_list|()
operator|.
name|add
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|"runtime"
operator|.
name|equals
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|bundle
operator|.
name|setDependency
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|startLevel
operator|!=
literal|null
operator|&&
name|bundle
operator|.
name|getStartLevel
argument_list|()
operator|==
literal|0
condition|)
block|{
name|bundle
operator|.
name|setStartLevel
argument_list|(
name|startLevel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
operator|!
name|feature
operator|.
name|getBundle
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|feature
operator|.
name|getFeature
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
operator|!
name|features
operator|.
name|getFeature
argument_list|()
operator|.
name|contains
argument_list|(
name|feature
argument_list|)
condition|)
block|{
name|features
operator|.
name|getFeature
argument_list|()
operator|.
name|add
argument_list|(
name|feature
argument_list|)
expr_stmt|;
block|}
name|JaxbUtil
operator|.
name|marshal
argument_list|(
name|features
argument_list|,
name|out
argument_list|)
expr_stmt|;
try|try
block|{
name|checkChanges
argument_list|(
name|features
argument_list|,
name|objectFactory
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|MojoExecutionException
argument_list|(
literal|"Features contents have changed"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"...done!"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Extract the MANIFEST from the give file.      */
specifier|private
name|Manifest
name|getManifest
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
try|try
block|{
name|is
operator|=
operator|new
name|BufferedInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"Error while opening artifact"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
try|try
block|{
name|is
operator|.
name|mark
argument_list|(
literal|256
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|JarInputStream
name|jar
init|=
operator|new
name|JarInputStream
argument_list|(
name|is
argument_list|)
decl_stmt|;
name|Manifest
name|m
init|=
name|jar
operator|.
name|getManifest
argument_list|()
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|null
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"Manifest not present in the first entry of the zip - "
operator|+
name|file
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|jar
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|m
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
comment|// just in case when we did not open bundle
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|Features
name|readFeaturesFile
parameter_list|(
name|File
name|featuresFile
parameter_list|)
throws|throws
name|XMLStreamException
throws|,
name|JAXBException
throws|,
name|IOException
block|{
return|return
name|JaxbUtil
operator|.
name|unmarshal
argument_list|(
name|featuresFile
operator|.
name|toURI
argument_list|()
operator|.
name|toASCIIString
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|void
name|setLog
parameter_list|(
name|Log
name|log
parameter_list|)
block|{
name|this
operator|.
name|log
operator|=
name|log
expr_stmt|;
block|}
specifier|public
name|Log
name|getLog
parameter_list|()
block|{
if|if
condition|(
name|log
operator|==
literal|null
condition|)
block|{
name|setLog
argument_list|(
operator|new
name|SystemStreamLog
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|log
return|;
block|}
comment|//------------------------------------------------------------------------//
comment|// dependency change detection
comment|/**      * Master switch to look for and log changed dependencies.  If this is set to<code>true</code> and the file referenced by      *<code>dependencyCache</code> does not exist, it will be unconditionally generated.  If the file does exist, it is      * used to detect changes from previous builds and generate logs of those changes.  In that case,      *<code>failOnDependencyChange = true</code> will cause the build to fail.      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"false"
argument_list|)
specifier|private
name|boolean
name|checkDependencyChange
decl_stmt|;
comment|/**      * (wrapper) Location of dependency cache.  This file is generated to contain known dependencies and is generally      * located in SCM so that it may be used across separate developer builds. This is parameter is ignored unless      *<code>checkDependencyChange</code> is set to<code>true</code>.      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"${basedir}/src/main/history/dependencies.xml"
argument_list|)
specifier|private
name|File
name|dependencyCache
decl_stmt|;
comment|/**      * Location of filtered dependency file.      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"${basedir}/target/history/dependencies.xml"
argument_list|,
name|readonly
operator|=
literal|true
argument_list|)
specifier|private
name|File
name|filteredDependencyCache
decl_stmt|;
comment|/**      * Whether to fail on changed dependencies (default,<code>true</code>) or warn (<code>false</code>). This is parameter is ignored unless      *<code>checkDependencyChange</code> is set to<code>true</code> and<code>dependencyCache</code> exists to compare      * against.      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"true"
argument_list|)
specifier|private
name|boolean
name|failOnDependencyChange
decl_stmt|;
comment|/**      * Copies the contents of dependency change logs that are generated to stdout. This is parameter is ignored unless      *<code>checkDependencyChange</code> is set to<code>true</code> and<code>dependencyCache</code> exists to compare      * against.      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"false"
argument_list|)
specifier|private
name|boolean
name|logDependencyChanges
decl_stmt|;
comment|/**      * Whether to overwrite the file referenced by<code>dependencyCache</code> if it has changed.  This is parameter is      * ignored unless<code>checkDependencyChange</code> is set to<code>true</code>,<code>failOnDependencyChange</code>      * is set to<code>false</code> and<code>dependencyCache</code> exists to compare against.      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"false"
argument_list|)
specifier|private
name|boolean
name|overwriteChangedDependencies
decl_stmt|;
comment|//filtering support
comment|/**      * The character encoding scheme to be applied when filtering resources.      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"${project.build.sourceEncoding}"
argument_list|)
specifier|protected
name|String
name|encoding
decl_stmt|;
comment|/**      * Expression preceded with the String won't be interpolated      * \${foo} will be replaced with ${foo}      */
annotation|@
name|Parameter
argument_list|(
name|defaultValue
operator|=
literal|"${maven.resources.escapeString}"
argument_list|)
specifier|protected
name|String
name|escapeString
init|=
literal|"\\"
decl_stmt|;
comment|/**      * System properties.      */
annotation|@
name|Parameter
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|systemProperties
decl_stmt|;
specifier|private
name|void
name|checkChanges
parameter_list|(
name|Features
name|newFeatures
parameter_list|,
name|ObjectFactory
name|objectFactory
parameter_list|)
throws|throws
name|Exception
throws|,
name|IOException
throws|,
name|JAXBException
throws|,
name|XMLStreamException
block|{
if|if
condition|(
name|checkDependencyChange
condition|)
block|{
comment|//combine all the dependencies to one feature and strip out versions
name|Features
name|features
init|=
name|objectFactory
operator|.
name|createFeaturesRoot
argument_list|()
decl_stmt|;
name|features
operator|.
name|setName
argument_list|(
name|newFeatures
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Feature
name|feature
init|=
name|objectFactory
operator|.
name|createFeature
argument_list|()
decl_stmt|;
name|features
operator|.
name|getFeature
argument_list|()
operator|.
name|add
argument_list|(
name|feature
argument_list|)
expr_stmt|;
for|for
control|(
name|Feature
name|f
range|:
name|newFeatures
operator|.
name|getFeature
argument_list|()
control|)
block|{
for|for
control|(
name|Bundle
name|b
range|:
name|f
operator|.
name|getBundle
argument_list|()
control|)
block|{
name|Bundle
name|bundle
init|=
name|objectFactory
operator|.
name|createBundle
argument_list|()
decl_stmt|;
name|bundle
operator|.
name|setLocation
argument_list|(
name|b
operator|.
name|getLocation
argument_list|()
argument_list|)
expr_stmt|;
name|feature
operator|.
name|getBundle
argument_list|()
operator|.
name|add
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Dependency
name|d
range|:
name|f
operator|.
name|getFeature
argument_list|()
control|)
block|{
name|Dependency
name|dependency
init|=
name|objectFactory
operator|.
name|createDependency
argument_list|()
decl_stmt|;
name|dependency
operator|.
name|setName
argument_list|(
name|d
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|feature
operator|.
name|getFeature
argument_list|()
operator|.
name|add
argument_list|(
name|dependency
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|feature
operator|.
name|getBundle
argument_list|()
argument_list|,
operator|new
name|Comparator
argument_list|<
name|Bundle
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Bundle
name|bundle
parameter_list|,
name|Bundle
name|bundle1
parameter_list|)
block|{
return|return
name|bundle
operator|.
name|getLocation
argument_list|()
operator|.
name|compareTo
argument_list|(
name|bundle1
operator|.
name|getLocation
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|feature
operator|.
name|getFeature
argument_list|()
argument_list|,
operator|new
name|Comparator
argument_list|<
name|Dependency
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Dependency
name|dependency
parameter_list|,
name|Dependency
name|dependency1
parameter_list|)
block|{
return|return
name|dependency
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|dependency1
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|dependencyCache
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|//filter dependencies file
name|filter
argument_list|(
name|dependencyCache
argument_list|,
name|filteredDependencyCache
argument_list|)
expr_stmt|;
comment|//read dependency types, convert to dependencies, compare.
name|Features
name|oldfeatures
init|=
name|readFeaturesFile
argument_list|(
name|filteredDependencyCache
argument_list|)
decl_stmt|;
name|Feature
name|oldFeature
init|=
name|oldfeatures
operator|.
name|getFeature
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Bundle
argument_list|>
name|addedBundles
init|=
operator|new
name|ArrayList
argument_list|<
name|Bundle
argument_list|>
argument_list|(
name|feature
operator|.
name|getBundle
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Bundle
argument_list|>
name|removedBundles
init|=
operator|new
name|ArrayList
argument_list|<
name|Bundle
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Bundle
name|test
range|:
name|oldFeature
operator|.
name|getBundle
argument_list|()
control|)
block|{
name|boolean
name|t1
init|=
name|addedBundles
operator|.
name|contains
argument_list|(
name|test
argument_list|)
decl_stmt|;
name|int
name|s1
init|=
name|addedBundles
operator|.
name|size
argument_list|()
decl_stmt|;
name|boolean
name|t2
init|=
name|addedBundles
operator|.
name|remove
argument_list|(
name|test
argument_list|)
decl_stmt|;
name|int
name|s2
init|=
name|addedBundles
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|t1
operator|!=
name|t2
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"dependencies.contains: "
operator|+
name|t1
operator|+
literal|", dependencies.remove(test): "
operator|+
name|t2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t1
operator|==
operator|(
name|s1
operator|==
name|s2
operator|)
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"dependencies.contains: "
operator|+
name|t1
operator|+
literal|", size before: "
operator|+
name|s1
operator|+
literal|", size after: "
operator|+
name|s2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|t2
condition|)
block|{
name|removedBundles
operator|.
name|add
argument_list|(
name|test
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|Dependency
argument_list|>
name|addedDependencys
init|=
operator|new
name|ArrayList
argument_list|<
name|Dependency
argument_list|>
argument_list|(
name|feature
operator|.
name|getFeature
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Dependency
argument_list|>
name|removedDependencys
init|=
operator|new
name|ArrayList
argument_list|<
name|Dependency
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Dependency
name|test
range|:
name|oldFeature
operator|.
name|getFeature
argument_list|()
control|)
block|{
name|boolean
name|t1
init|=
name|addedDependencys
operator|.
name|contains
argument_list|(
name|test
argument_list|)
decl_stmt|;
name|int
name|s1
init|=
name|addedDependencys
operator|.
name|size
argument_list|()
decl_stmt|;
name|boolean
name|t2
init|=
name|addedDependencys
operator|.
name|remove
argument_list|(
name|test
argument_list|)
decl_stmt|;
name|int
name|s2
init|=
name|addedDependencys
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|t1
operator|!=
name|t2
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"dependencies.contains: "
operator|+
name|t1
operator|+
literal|", dependencies.remove(test): "
operator|+
name|t2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t1
operator|==
operator|(
name|s1
operator|==
name|s2
operator|)
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"dependencies.contains: "
operator|+
name|t1
operator|+
literal|", size before: "
operator|+
name|s1
operator|+
literal|", size after: "
operator|+
name|s2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|t2
condition|)
block|{
name|removedDependencys
operator|.
name|add
argument_list|(
name|test
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|addedBundles
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|removedBundles
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|addedDependencys
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|removedDependencys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|saveDependencyChanges
argument_list|(
name|addedBundles
argument_list|,
name|removedBundles
argument_list|,
name|addedDependencys
argument_list|,
name|removedDependencys
argument_list|,
name|objectFactory
argument_list|)
expr_stmt|;
if|if
condition|(
name|overwriteChangedDependencies
condition|)
block|{
name|writeDependencies
argument_list|(
name|features
argument_list|,
name|dependencyCache
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
name|saveTreeListing
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|writeDependencies
argument_list|(
name|features
argument_list|,
name|dependencyCache
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|protected
name|void
name|saveDependencyChanges
parameter_list|(
name|Collection
argument_list|<
name|Bundle
argument_list|>
name|addedBundles
parameter_list|,
name|Collection
argument_list|<
name|Bundle
argument_list|>
name|removedBundles
parameter_list|,
name|Collection
argument_list|<
name|Dependency
argument_list|>
name|addedDependencys
parameter_list|,
name|Collection
argument_list|<
name|Dependency
argument_list|>
name|removedDependencys
parameter_list|,
name|ObjectFactory
name|objectFactory
parameter_list|)
throws|throws
name|Exception
block|{
name|File
name|addedFile
init|=
operator|new
name|File
argument_list|(
name|filteredDependencyCache
operator|.
name|getParentFile
argument_list|()
argument_list|,
literal|"dependencies.added.xml"
argument_list|)
decl_stmt|;
name|Features
name|added
init|=
name|toFeatures
argument_list|(
name|addedBundles
argument_list|,
name|addedDependencys
argument_list|,
name|objectFactory
argument_list|)
decl_stmt|;
name|writeDependencies
argument_list|(
name|added
argument_list|,
name|addedFile
argument_list|)
expr_stmt|;
name|File
name|removedFile
init|=
operator|new
name|File
argument_list|(
name|filteredDependencyCache
operator|.
name|getParentFile
argument_list|()
argument_list|,
literal|"dependencies.removed.xml"
argument_list|)
decl_stmt|;
name|Features
name|removed
init|=
name|toFeatures
argument_list|(
name|removedBundles
argument_list|,
name|removedDependencys
argument_list|,
name|objectFactory
argument_list|)
decl_stmt|;
name|writeDependencies
argument_list|(
name|removed
argument_list|,
name|removedFile
argument_list|)
expr_stmt|;
name|StringWriter
name|out
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
name|saveTreeListing
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
literal|"Dependencies have changed:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addedBundles
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|addedDependencys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
literal|"\tAdded dependencies are saved here: "
operator|+
name|addedFile
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|logDependencyChanges
condition|)
block|{
name|JaxbUtil
operator|.
name|marshal
argument_list|(
name|added
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|removedBundles
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|removedDependencys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
literal|"\tRemoved dependencies are saved here: "
operator|+
name|removedFile
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|logDependencyChanges
condition|)
block|{
name|JaxbUtil
operator|.
name|marshal
argument_list|(
name|removed
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
name|out
operator|.
name|write
argument_list|(
literal|"Delete "
operator|+
name|dependencyCache
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" if you are happy with the dependency changes."
argument_list|)
expr_stmt|;
if|if
condition|(
name|failOnDependencyChange
condition|)
block|{
throw|throw
operator|new
name|MojoFailureException
argument_list|(
name|out
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
name|out
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Features
name|toFeatures
parameter_list|(
name|Collection
argument_list|<
name|Bundle
argument_list|>
name|addedBundles
parameter_list|,
name|Collection
argument_list|<
name|Dependency
argument_list|>
name|addedDependencys
parameter_list|,
name|ObjectFactory
name|objectFactory
parameter_list|)
block|{
name|Features
name|features
init|=
name|objectFactory
operator|.
name|createFeaturesRoot
argument_list|()
decl_stmt|;
name|Feature
name|feature
init|=
name|objectFactory
operator|.
name|createFeature
argument_list|()
decl_stmt|;
name|feature
operator|.
name|getBundle
argument_list|()
operator|.
name|addAll
argument_list|(
name|addedBundles
argument_list|)
expr_stmt|;
name|feature
operator|.
name|getFeature
argument_list|()
operator|.
name|addAll
argument_list|(
name|addedDependencys
argument_list|)
expr_stmt|;
name|features
operator|.
name|getFeature
argument_list|()
operator|.
name|add
argument_list|(
name|feature
argument_list|)
expr_stmt|;
return|return
name|features
return|;
block|}
specifier|private
name|void
name|writeDependencies
parameter_list|(
name|Features
name|features
parameter_list|,
name|File
name|file
parameter_list|)
throws|throws
name|JAXBException
throws|,
name|IOException
block|{
name|file
operator|.
name|getParentFile
argument_list|()
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|getParentFile
argument_list|()
operator|.
name|exists
argument_list|()
operator|||
operator|!
name|file
operator|.
name|getParentFile
argument_list|()
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot create directory at "
operator|+
name|file
operator|.
name|getParent
argument_list|()
argument_list|)
throw|;
block|}
name|FileOutputStream
name|out
init|=
operator|new
name|FileOutputStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
try|try
block|{
name|JaxbUtil
operator|.
name|marshal
argument_list|(
name|features
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|filter
parameter_list|(
name|File
name|sourceFile
parameter_list|,
name|File
name|targetFile
parameter_list|)
throws|throws
name|MojoExecutionException
block|{
try|try
block|{
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|encoding
argument_list|)
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"File encoding has not been set, using platform encoding "
operator|+
name|ReaderFactory
operator|.
name|FILE_ENCODING
operator|+
literal|", i.e. build is platform dependent!"
argument_list|)
expr_stmt|;
block|}
name|targetFile
operator|.
name|getParentFile
argument_list|()
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
specifier|final
name|MavenResourcesExecution
name|mre
init|=
operator|new
name|MavenResourcesExecution
argument_list|()
decl_stmt|;
name|mre
operator|.
name|setMavenProject
argument_list|(
name|project
argument_list|)
expr_stmt|;
name|mre
operator|.
name|setMavenSession
argument_list|(
name|mavenSession
argument_list|)
expr_stmt|;
name|mre
operator|.
name|setFilters
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|mre
operator|.
name|setEscapedBackslashesInFilePath
argument_list|(
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|LinkedHashSet
argument_list|<
name|String
argument_list|>
name|delimiters
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|delimiters
operator|.
name|add
argument_list|(
literal|"${*}"
argument_list|)
expr_stmt|;
name|mre
operator|.
name|setDelimiters
argument_list|(
name|delimiters
argument_list|)
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
name|List
name|filters
init|=
name|mavenFileFilter
operator|.
name|getDefaultFilterWrappers
argument_list|(
name|mre
argument_list|)
decl_stmt|;
name|mavenFileFilter
operator|.
name|copyFile
argument_list|(
name|sourceFile
argument_list|,
name|targetFile
argument_list|,
literal|true
argument_list|,
name|filters
argument_list|,
name|encoding
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MavenFilteringException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|MojoExecutionException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|String
name|saveTreeListing
parameter_list|()
throws|throws
name|IOException
block|{
name|File
name|treeListFile
init|=
operator|new
name|File
argument_list|(
name|filteredDependencyCache
operator|.
name|getParentFile
argument_list|()
argument_list|,
literal|"treeListing.txt"
argument_list|)
decl_stmt|;
name|OutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|treeListFile
argument_list|)
decl_stmt|;
name|BufferedWriter
name|writer
init|=
operator|new
name|BufferedWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|os
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|writer
operator|.
name|write
argument_list|(
name|treeListing
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
literal|"\tTree listing is saved here: "
operator|+
name|treeListFile
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|"\n"
return|;
block|}
block|}
end_class

end_unit

