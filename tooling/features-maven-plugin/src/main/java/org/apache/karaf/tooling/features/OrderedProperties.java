begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  Licensed to the Apache Software Foundation (ASF) under one or more  *  contributor license agreements.  See the NOTICE file distributed with  *  this work for additional information regarding copyright ownership.  *  The ASF licenses this file to You under the Apache License, Version 2.0  *  (the "License"); you may not use this file except in compliance with  *  the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|tooling
operator|.
name|features
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|IllegalCharsetNameException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|UnsupportedCharsetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessController
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|InvalidPropertiesFormatException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|DocumentBuilder
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|DocumentBuilderFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|ParserConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|EntityResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|ErrorHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|InputSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Element
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import

begin_comment
comment|//import org.apache.harmony.luni.internal.nls.Messages;
end_comment

begin_comment
comment|//import org.apache.harmony.luni.util.PriviAction;
end_comment

begin_comment
comment|/**  * This is a copy of harmony's Properties implementation modified to extend LinkedHashMap instead of Hashtable  * The default property stuff doesn't work.  *  * A {@code Properties} object is a {@code Hashtable} where the keys and values  * must be {@code String}s. Each property can have a default  * {@code Properties} list which specifies the default  * values to be used when a given key is not found in this {@code Properties}  * instance.  *  * @see LinkedHashMap  * @see java.lang.System#getProperties  */
end_comment

begin_class
specifier|public
class|class
name|OrderedProperties
extends|extends
name|LinkedHashMap
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|4112578634029874840L
decl_stmt|;
specifier|private
specifier|transient
name|DocumentBuilder
name|builder
init|=
literal|null
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|PROP_DTD_NAME
init|=
literal|"http://java.sun.com/dtd/properties.dtd"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|PROP_DTD
init|=
literal|"<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
operator|+
literal|"<!ELEMENT properties (comment?, entry*)>"
operator|+
literal|"<!ATTLIST properties version CDATA #FIXED \"1.0\">"
operator|+
literal|"<!ELEMENT comment (#PCDATA)>"
operator|+
literal|"<!ELEMENT entry (#PCDATA)>"
operator|+
literal|"<!ATTLIST entry key CDATA #REQUIRED>"
decl_stmt|;
comment|/**      * The default values for keys not found in this {@code Properties}      * instance.      */
specifier|protected
name|Properties
name|defaults
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|NONE
init|=
literal|0
decl_stmt|,
name|SLASH
init|=
literal|1
decl_stmt|,
name|UNICODE
init|=
literal|2
decl_stmt|,
name|CONTINUE
init|=
literal|3
decl_stmt|,
name|KEY_DONE
init|=
literal|4
decl_stmt|,
name|IGNORE
init|=
literal|5
decl_stmt|;
comment|/**      * Constructs a new {@code Properties} object.      */
specifier|public
name|OrderedProperties
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|/**      * Constructs a new {@code Properties} object using the specified default      * {@code Properties}.      *       * @param properties      *            the default {@code Properties}.      */
specifier|public
name|OrderedProperties
parameter_list|(
name|Properties
name|properties
parameter_list|)
block|{
name|defaults
operator|=
name|properties
expr_stmt|;
block|}
specifier|private
name|void
name|dumpString
parameter_list|(
name|StringBuilder
name|buffer
parameter_list|,
name|String
name|string
parameter_list|,
name|boolean
name|key
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|key
operator|&&
name|i
operator|<
name|string
operator|.
name|length
argument_list|()
operator|&&
name|string
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|' '
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|"\\ "
argument_list|)
expr_stmt|;
comment|//$NON-NLS-1$
name|i
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|string
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ch
init|=
name|string
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\t'
case|:
name|buffer
operator|.
name|append
argument_list|(
literal|"\\t"
argument_list|)
expr_stmt|;
comment|//$NON-NLS-1$
break|break;
case|case
literal|'\n'
case|:
name|buffer
operator|.
name|append
argument_list|(
literal|"\\n"
argument_list|)
expr_stmt|;
comment|//$NON-NLS-1$
break|break;
case|case
literal|'\f'
case|:
name|buffer
operator|.
name|append
argument_list|(
literal|"\\f"
argument_list|)
expr_stmt|;
comment|//$NON-NLS-1$
break|break;
case|case
literal|'\r'
case|:
name|buffer
operator|.
name|append
argument_list|(
literal|"\\r"
argument_list|)
expr_stmt|;
comment|//$NON-NLS-1$
break|break;
default|default:
if|if
condition|(
literal|"\\#!=:"
operator|.
name|indexOf
argument_list|(
name|ch
argument_list|)
operator|>=
literal|0
operator|||
operator|(
name|key
operator|&&
name|ch
operator|==
literal|' '
operator|)
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|>=
literal|' '
operator|&&
name|ch
operator|<=
literal|'~'
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|hex
init|=
name|Integer
operator|.
name|toHexString
argument_list|(
name|ch
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
literal|"\\u"
argument_list|)
expr_stmt|;
comment|//$NON-NLS-1$
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|4
operator|-
name|hex
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
comment|//$NON-NLS-1$
block|}
name|buffer
operator|.
name|append
argument_list|(
name|hex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Searches for the property with the specified name. If the property is not      * found, the default {@code Properties} are checked. If the property is not      * found in the default {@code Properties}, {@code null} is returned.      *       * @param name      *            the name of the property to find.      * @return the named property value, or {@code null} if it can't be found.      */
specifier|public
name|String
name|getProperty
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|Object
name|result
init|=
name|super
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|String
name|property
init|=
name|result
operator|instanceof
name|String
condition|?
operator|(
name|String
operator|)
name|result
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|property
operator|==
literal|null
operator|&&
name|defaults
operator|!=
literal|null
condition|)
block|{
name|property
operator|=
name|defaults
operator|.
name|getProperty
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|property
return|;
block|}
comment|/**      * Searches for the property with the specified name. If the property is not      * found, it looks in the default {@code Properties}. If the property is not      * found in the default {@code Properties}, it returns the specified      * default.      *       * @param name      *            the name of the property to find.      * @param defaultValue      *            the default value.      * @return the named property value.      */
specifier|public
name|String
name|getProperty
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|defaultValue
parameter_list|)
block|{
name|Object
name|result
init|=
name|super
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|String
name|property
init|=
name|result
operator|instanceof
name|String
condition|?
operator|(
name|String
operator|)
name|result
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|property
operator|==
literal|null
operator|&&
name|defaults
operator|!=
literal|null
condition|)
block|{
name|property
operator|=
name|defaults
operator|.
name|getProperty
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|property
operator|==
literal|null
condition|)
block|{
return|return
name|defaultValue
return|;
block|}
return|return
name|property
return|;
block|}
comment|/**      * Lists the mappings in this {@code Properties} to the specified      * {@code PrintStream} in a      * human readable form.      *       * @param out      *            the {@code PrintStream} to write the content to in human readable      *            form.      */
specifier|public
name|void
name|list
parameter_list|(
name|PrintStream
name|out
parameter_list|)
block|{
if|if
condition|(
name|out
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|(
literal|80
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|?
argument_list|>
name|keys
init|=
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|keys
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|keys
operator|.
name|next
argument_list|()
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|String
name|property
init|=
operator|(
name|String
operator|)
name|super
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Properties
name|def
init|=
name|defaults
decl_stmt|;
if|if
condition|(
name|property
operator|==
literal|null
condition|)
block|{
name|property
operator|=
name|def
operator|.
name|getProperty
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|property
operator|.
name|length
argument_list|()
operator|>
literal|40
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|property
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|37
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
comment|//$NON-NLS-1$
block|}
else|else
block|{
name|buffer
operator|.
name|append
argument_list|(
name|property
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|println
argument_list|(
name|buffer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Lists the mappings in this {@code Properties} to the specified      * {@code PrintWriter} in a      * human readable form.      *       * @param writer      *            the {@code PrintWriter} to write the content to in human      *            readable form.      */
specifier|public
name|void
name|list
parameter_list|(
name|PrintWriter
name|writer
parameter_list|)
block|{
if|if
condition|(
name|writer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|(
literal|80
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|?
argument_list|>
name|keys
init|=
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|keys
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|keys
operator|.
name|next
argument_list|()
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|String
name|property
init|=
operator|(
name|String
operator|)
name|super
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Properties
name|def
init|=
name|defaults
decl_stmt|;
if|if
condition|(
name|property
operator|==
literal|null
condition|)
block|{
name|property
operator|=
name|def
operator|.
name|getProperty
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|property
operator|.
name|length
argument_list|()
operator|>
literal|40
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|property
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|37
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
comment|//$NON-NLS-1$
block|}
else|else
block|{
name|buffer
operator|.
name|append
argument_list|(
name|property
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|println
argument_list|(
name|buffer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Loads properties from the specified {@code InputStream}. The encoding is      * ISO8859-1. The {@code Properties} file is interpreted according to the      * following rules:      *<ul>      *<li>Empty lines are ignored.</li>      *<li>Lines starting with either a "#" or a "!" are comment lines and are      * ignored.</li>      *<li>A backslash at the end of the line escapes the following newline      * character ("\r", "\n", "\r\n"). If there's a whitespace after the      * backslash it will just escape that whitespace instead of concatenating      * the lines. This does not apply to comment lines.</li>      *<li>A property line consists of the key, the space between the key and      * the value, and the value. The key goes up to the first whitespace, "=" or      * ":" that is not escaped. The space between the key and the value contains      * either one whitespace, one "=" or one ":" and any number of additional      * whitespaces before and after that character. The value starts with the      * first character after the space between the key and the value.</li>      *<li>Following escape sequences are recognized: "\ ", "\\", "\r", "\n",      * "\!", "\#", "\t", "\b", "\f", and "&#92;uXXXX" (unicode character).</li>      *</ul>      *       * @param in      *            the {@code InputStream}.      * @throws IOException      *             if error occurs during reading from the {@code InputStream}.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"fallthrough"
argument_list|)
specifier|public
specifier|synchronized
name|void
name|load
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
name|int
name|mode
init|=
name|NONE
decl_stmt|,
name|unicode
init|=
literal|0
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|char
name|nextChar
decl_stmt|,
name|buf
index|[]
init|=
operator|new
name|char
index|[
literal|40
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|,
name|keyLength
init|=
operator|-
literal|1
decl_stmt|,
name|intVal
decl_stmt|;
name|boolean
name|firstChar
init|=
literal|true
decl_stmt|;
name|BufferedInputStream
name|bis
init|=
operator|new
name|BufferedInputStream
argument_list|(
name|in
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|intVal
operator|=
name|bis
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|intVal
operator|==
operator|-
literal|1
condition|)
block|{
comment|// if mode is UNICODE but has less than 4 hex digits, should
comment|// throw an IllegalArgumentException
comment|// luni.08=Invalid Unicode sequence: expected format \\uxxxx
if|if
condition|(
name|mode
operator|==
name|UNICODE
operator|&&
name|count
operator|<
literal|4
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid Unicode sequence: expected format \\\\uxxxx"
argument_list|)
throw|;
comment|//$NON-NLS-1$
block|}
comment|// if mode is SLASH and no data is read, should append '\u0000'
comment|// to buf
if|if
condition|(
name|mode
operator|==
name|SLASH
condition|)
block|{
name|buf
index|[
name|offset
operator|++
index|]
operator|=
literal|'\u0000'
expr_stmt|;
block|}
break|break;
block|}
name|nextChar
operator|=
call|(
name|char
call|)
argument_list|(
name|intVal
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|buf
operator|.
name|length
condition|)
block|{
name|char
index|[]
name|newBuf
init|=
operator|new
name|char
index|[
name|buf
operator|.
name|length
operator|*
literal|2
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|newBuf
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|buf
operator|=
name|newBuf
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|UNICODE
condition|)
block|{
name|int
name|digit
init|=
name|Character
operator|.
name|digit
argument_list|(
name|nextChar
argument_list|,
literal|16
argument_list|)
decl_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|0
condition|)
block|{
name|unicode
operator|=
operator|(
name|unicode
operator|<<
literal|4
operator|)
operator|+
name|digit
expr_stmt|;
if|if
condition|(
operator|++
name|count
operator|<
literal|4
condition|)
block|{
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|count
operator|<=
literal|4
condition|)
block|{
comment|// luni.09=Invalid Unicode sequence: illegal character
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid Unicode sequence: illegal character"
argument_list|)
throw|;
comment|//$NON-NLS-1$
block|}
name|mode
operator|=
name|NONE
expr_stmt|;
name|buf
index|[
name|offset
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|unicode
expr_stmt|;
if|if
condition|(
name|nextChar
operator|!=
literal|'\n'
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|SLASH
condition|)
block|{
name|mode
operator|=
name|NONE
expr_stmt|;
switch|switch
condition|(
name|nextChar
condition|)
block|{
case|case
literal|'\r'
case|:
name|mode
operator|=
name|CONTINUE
expr_stmt|;
comment|// Look for a following \n
continue|continue;
case|case
literal|'\n'
case|:
name|mode
operator|=
name|IGNORE
expr_stmt|;
comment|// Ignore whitespace on the next line
continue|continue;
case|case
literal|'b'
case|:
name|nextChar
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|nextChar
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|nextChar
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|nextChar
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|nextChar
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|mode
operator|=
name|UNICODE
expr_stmt|;
name|unicode
operator|=
name|count
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|nextChar
condition|)
block|{
case|case
literal|'#'
case|:
case|case
literal|'!'
case|:
if|if
condition|(
name|firstChar
condition|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|intVal
operator|=
name|bis
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|intVal
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
comment|//& 0xff not required
name|nextChar
operator|=
operator|(
name|char
operator|)
name|intVal
expr_stmt|;
if|if
condition|(
name|nextChar
operator|==
literal|'\r'
operator|||
name|nextChar
operator|==
literal|'\n'
condition|)
block|{
break|break;
block|}
block|}
continue|continue;
block|}
break|break;
case|case
literal|'\n'
case|:
if|if
condition|(
name|mode
operator|==
name|CONTINUE
condition|)
block|{
comment|// Part of a \r\n sequence
name|mode
operator|=
name|IGNORE
expr_stmt|;
comment|// Ignore whitespace on the next line
continue|continue;
block|}
comment|// fall into the next case
case|case
literal|'\r'
case|:
name|mode
operator|=
name|NONE
expr_stmt|;
name|firstChar
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|offset
operator|>
literal|0
operator|||
operator|(
name|offset
operator|==
literal|0
operator|&&
name|keyLength
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|keyLength
operator|==
operator|-
literal|1
condition|)
block|{
name|keyLength
operator|=
name|offset
expr_stmt|;
block|}
name|String
name|temp
init|=
operator|new
name|String
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|put
argument_list|(
name|temp
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|keyLength
argument_list|)
argument_list|,
name|temp
operator|.
name|substring
argument_list|(
name|keyLength
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|keyLength
operator|=
operator|-
literal|1
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'\\'
case|:
if|if
condition|(
name|mode
operator|==
name|KEY_DONE
condition|)
block|{
name|keyLength
operator|=
name|offset
expr_stmt|;
block|}
name|mode
operator|=
name|SLASH
expr_stmt|;
continue|continue;
case|case
literal|':'
case|:
case|case
literal|'='
case|:
if|if
condition|(
name|keyLength
operator|==
operator|-
literal|1
condition|)
block|{
comment|// if parsing the key
name|mode
operator|=
name|NONE
expr_stmt|;
name|keyLength
operator|=
name|offset
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|nextChar
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|CONTINUE
condition|)
block|{
name|mode
operator|=
name|IGNORE
expr_stmt|;
block|}
comment|// if key length == 0 or value length == 0
if|if
condition|(
name|offset
operator|==
literal|0
operator|||
name|offset
operator|==
name|keyLength
operator|||
name|mode
operator|==
name|IGNORE
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|keyLength
operator|==
operator|-
literal|1
condition|)
block|{
comment|// if parsing the key
name|mode
operator|=
name|KEY_DONE
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|IGNORE
operator|||
name|mode
operator|==
name|CONTINUE
condition|)
block|{
name|mode
operator|=
name|NONE
expr_stmt|;
block|}
block|}
name|firstChar
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|KEY_DONE
condition|)
block|{
name|keyLength
operator|=
name|offset
expr_stmt|;
name|mode
operator|=
name|NONE
expr_stmt|;
block|}
name|buf
index|[
name|offset
operator|++
index|]
operator|=
name|nextChar
expr_stmt|;
block|}
if|if
condition|(
name|keyLength
operator|==
operator|-
literal|1
operator|&&
name|offset
operator|>
literal|0
condition|)
block|{
name|keyLength
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|keyLength
operator|>=
literal|0
condition|)
block|{
name|String
name|temp
init|=
operator|new
name|String
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|put
argument_list|(
name|temp
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|keyLength
argument_list|)
argument_list|,
name|temp
operator|.
name|substring
argument_list|(
name|keyLength
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns all of the property names that this {@code Properties} object      * contains.      *       * @return an {@code Enumeration} containing the names of all properties      *         that this {@code Properties} object contains.      */
comment|//    public Enumeration<?> propertyNames() {
comment|//        if (defaults == null) {
comment|//            return keySet().;
comment|//        }
comment|//
comment|//        Hashtable<Object, Object> set = new Hashtable<Object, Object>(defaults
comment|//                .size()
comment|//                + size());
comment|//        Enumeration<?> keys = defaults.propertyNames();
comment|//        while (keys.hasMoreElements()) {
comment|//            set.put(keys.nextElement(), set);
comment|//        }
comment|//        keys = keys();
comment|//        while (keys.hasMoreElements()) {
comment|//            set.put(keys.nextElement(), set);
comment|//        }
comment|//        return set.keys();
comment|//    }
comment|/**      * Saves the mappings in this {@code Properties} to the specified {@code      * OutputStream}, putting the specified comment at the beginning. The output      * from this method is suitable for being read by the      * {@link #load(InputStream)} method.      *       * @param out the {@code OutputStream} to write to.      * @param comment the comment to add at the beginning.      * @throws ClassCastException if the key or value of a mapping is not a      *                String.      * @deprecated This method ignores any {@code IOException} thrown while      *             writing -- use {@link #store} instead for better exception      *             handling.      */
annotation|@
name|Deprecated
specifier|public
name|void
name|save
parameter_list|(
name|OutputStream
name|out
parameter_list|,
name|String
name|comment
parameter_list|)
block|{
try|try
block|{
name|store
argument_list|(
name|out
argument_list|,
name|comment
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{         }
block|}
comment|/**      * Maps the specified key to the specified value. If the key already exists,      * the old value is replaced. The key and value cannot be {@code null}.      *       * @param name      *            the key.      * @param value      *            the value.      * @return the old value mapped to the key, or {@code null}.      */
specifier|public
name|Object
name|setProperty
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|)
block|{
return|return
name|put
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|String
name|lineSeparator
decl_stmt|;
comment|/**      * Stores the mappings in this {@code Properties} to the specified {@code      * OutputStream}, putting the specified comment at the beginning. The output      * from this method is suitable for being read by the      * {@link #load(InputStream)} method.      *       * @param out the {@code OutputStream} to write to.      * @param comment the comment to put at the beginning.      * @throws IOException if an error occurs during the write to the {@code      *             OutputStream}.      * @throws ClassCastException if the key or value of a mapping is not a      *                {@code String}.      */
specifier|public
specifier|synchronized
name|void
name|store
parameter_list|(
name|OutputStream
name|out
parameter_list|,
name|String
name|comment
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|lineSeparator
operator|==
literal|null
condition|)
block|{
name|lineSeparator
operator|=
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedAction
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
specifier|public
name|String
name|run
parameter_list|()
block|{
return|return
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|//$NON-NLS-1$
block|}
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|(
literal|200
argument_list|)
decl_stmt|;
name|OutputStreamWriter
name|writer
init|=
operator|new
name|OutputStreamWriter
argument_list|(
name|out
argument_list|,
literal|"ISO8859_1"
argument_list|)
decl_stmt|;
comment|//$NON-NLS-1$
if|if
condition|(
name|comment
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|write
argument_list|(
literal|"#"
argument_list|)
expr_stmt|;
comment|//$NON-NLS-1$
name|writer
operator|.
name|write
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|lineSeparator
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|write
argument_list|(
literal|"#"
argument_list|)
expr_stmt|;
comment|//$NON-NLS-1$
name|writer
operator|.
name|write
argument_list|(
operator|new
name|Date
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|lineSeparator
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|dumpString
argument_list|(
name|buffer
argument_list|,
name|key
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|dumpString
argument_list|(
name|buffer
argument_list|,
operator|(
name|String
operator|)
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|lineSeparator
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|buffer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**      * Loads the properties from an {@code InputStream} containing the      * properties in XML form. The XML document must begin with (and conform to)      * following DOCTYPE:      *      *<pre>      *&lt;!DOCTYPE properties SYSTEM&quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;      *</pre>      *      * Also the content of the XML data must satisfy the DTD but the xml is not      * validated against it. The DTD is not loaded from the SYSTEM ID. After      * this method returns the InputStream is not closed.      *      * @param in the InputStream containing the XML document.      * @throws IOException in case an error occurs during a read operation.      * @throws InvalidPropertiesFormatException if the XML data is not a valid      *             properties file.      */
specifier|public
specifier|synchronized
name|void
name|loadFromXML
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|InvalidPropertiesFormatException
block|{
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|DocumentBuilderFactory
name|factory
init|=
name|DocumentBuilderFactory
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|factory
operator|.
name|setValidating
argument_list|(
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|builder
operator|=
name|factory
operator|.
name|newDocumentBuilder
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParserConfigurationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|builder
operator|.
name|setErrorHandler
argument_list|(
operator|new
name|ErrorHandler
argument_list|()
block|{
specifier|public
name|void
name|warning
parameter_list|(
name|SAXParseException
name|e
parameter_list|)
throws|throws
name|SAXException
block|{
throw|throw
name|e
throw|;
block|}
specifier|public
name|void
name|error
parameter_list|(
name|SAXParseException
name|e
parameter_list|)
throws|throws
name|SAXException
block|{
throw|throw
name|e
throw|;
block|}
specifier|public
name|void
name|fatalError
parameter_list|(
name|SAXParseException
name|e
parameter_list|)
throws|throws
name|SAXException
block|{
throw|throw
name|e
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setEntityResolver
argument_list|(
operator|new
name|EntityResolver
argument_list|()
block|{
specifier|public
name|InputSource
name|resolveEntity
parameter_list|(
name|String
name|publicId
parameter_list|,
name|String
name|systemId
parameter_list|)
throws|throws
name|SAXException
throws|,
name|IOException
block|{
if|if
condition|(
name|systemId
operator|.
name|equals
argument_list|(
name|PROP_DTD_NAME
argument_list|)
condition|)
block|{
name|InputSource
name|result
init|=
operator|new
name|InputSource
argument_list|(
operator|new
name|StringReader
argument_list|(
name|PROP_DTD
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|.
name|setSystemId
argument_list|(
name|PROP_DTD_NAME
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
throw|throw
operator|new
name|SAXException
argument_list|(
literal|"Invalid DOCTYPE declaration: "
operator|+
name|systemId
argument_list|)
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Document
name|doc
init|=
name|builder
operator|.
name|parse
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|NodeList
name|entries
init|=
name|doc
operator|.
name|getElementsByTagName
argument_list|(
literal|"entry"
argument_list|)
decl_stmt|;
if|if
condition|(
name|entries
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|int
name|entriesListLength
init|=
name|entries
operator|.
name|getLength
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|entriesListLength
condition|;
name|i
operator|++
control|)
block|{
name|Element
name|entry
init|=
operator|(
name|Element
operator|)
name|entries
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|key
init|=
name|entry
operator|.
name|getAttribute
argument_list|(
literal|"key"
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|entry
operator|.
name|getTextContent
argument_list|()
decl_stmt|;
comment|/*                  * key != null& value != null but key or(and) value can be                  * empty String                  */
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InvalidPropertiesFormatException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Writes all properties stored in this instance into the {@code      * OutputStream} in XML representation. The DOCTYPE is      *      *<pre>      *&lt;!DOCTYPE properties SYSTEM&quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;      *</pre>      *      * If the comment is null, no comment is added to the output. UTF-8 is used      * as the encoding. The {@code OutputStream} is not closed at the end. A      * call to this method is the same as a call to {@code storeToXML(os,      * comment, "UTF-8")}.      *      * @param os the {@code OutputStream} to write to.      * @param comment the comment to add. If null, no comment is added.      * @throws IOException if an error occurs during writing to the output.      */
specifier|public
name|void
name|storeToXML
parameter_list|(
name|OutputStream
name|os
parameter_list|,
name|String
name|comment
parameter_list|)
throws|throws
name|IOException
block|{
name|storeToXML
argument_list|(
name|os
argument_list|,
name|comment
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
comment|//$NON-NLS-1$
block|}
comment|/**      * Writes all properties stored in this instance into the {@code      * OutputStream} in XML representation. The DOCTYPE is      *      *<pre>      *&lt;!DOCTYPE properties SYSTEM&quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;      *</pre>      *      * If the comment is null, no comment is added to the output. The parameter      * {@code encoding} defines which encoding should be used. The {@code      * OutputStream} is not closed at the end.      *      * @param os the {@code OutputStream} to write to.      * @param comment the comment to add. If null, no comment is added.      * @param encoding the code identifying the encoding that should be used to      *            write into the {@code OutputStream}.      * @throws IOException if an error occurs during writing to the output.      */
specifier|public
specifier|synchronized
name|void
name|storeToXML
parameter_list|(
name|OutputStream
name|os
parameter_list|,
name|String
name|comment
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|os
operator|==
literal|null
operator|||
name|encoding
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
comment|/*          * We can write to XML file using encoding parameter but note that some          * aliases for encodings are not supported by the XML parser. Thus we          * have to know canonical name for encoding used to store data in XML          * since the XML parser must recognize encoding name used to store data.          */
name|String
name|encodingCanonicalName
decl_stmt|;
try|try
block|{
name|encodingCanonicalName
operator|=
name|Charset
operator|.
name|forName
argument_list|(
name|encoding
argument_list|)
operator|.
name|name
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalCharsetNameException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Warning: encoding name "
operator|+
name|encoding
operator|+
literal|" is illegal, using UTF-8 as default encoding"
argument_list|)
expr_stmt|;
name|encodingCanonicalName
operator|=
literal|"UTF-8"
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedCharsetException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Warning: encoding "
operator|+
name|encoding
operator|+
literal|" is not supported, using UTF-8 as default encoding"
argument_list|)
expr_stmt|;
name|encodingCanonicalName
operator|=
literal|"UTF-8"
expr_stmt|;
block|}
name|PrintStream
name|printStream
init|=
operator|new
name|PrintStream
argument_list|(
name|os
argument_list|,
literal|false
argument_list|,
name|encodingCanonicalName
argument_list|)
decl_stmt|;
name|printStream
operator|.
name|print
argument_list|(
literal|"<?xml version=\"1.0\" encoding=\""
argument_list|)
expr_stmt|;
name|printStream
operator|.
name|print
argument_list|(
name|encodingCanonicalName
argument_list|)
expr_stmt|;
name|printStream
operator|.
name|println
argument_list|(
literal|"\"?>"
argument_list|)
expr_stmt|;
name|printStream
operator|.
name|print
argument_list|(
literal|"<!DOCTYPE properties SYSTEM \""
argument_list|)
expr_stmt|;
name|printStream
operator|.
name|print
argument_list|(
name|PROP_DTD_NAME
argument_list|)
expr_stmt|;
name|printStream
operator|.
name|println
argument_list|(
literal|"\">"
argument_list|)
expr_stmt|;
name|printStream
operator|.
name|println
argument_list|(
literal|"<properties>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|comment
operator|!=
literal|null
condition|)
block|{
name|printStream
operator|.
name|print
argument_list|(
literal|"<comment>"
argument_list|)
expr_stmt|;
name|printStream
operator|.
name|print
argument_list|(
name|substitutePredefinedEntries
argument_list|(
name|comment
argument_list|)
argument_list|)
expr_stmt|;
name|printStream
operator|.
name|println
argument_list|(
literal|"</comment>"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|entrySet
argument_list|()
control|)
block|{
name|String
name|keyValue
init|=
operator|(
name|String
operator|)
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|entryValue
init|=
operator|(
name|String
operator|)
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|printStream
operator|.
name|print
argument_list|(
literal|"<entry key=\""
argument_list|)
expr_stmt|;
name|printStream
operator|.
name|print
argument_list|(
name|substitutePredefinedEntries
argument_list|(
name|keyValue
argument_list|)
argument_list|)
expr_stmt|;
name|printStream
operator|.
name|print
argument_list|(
literal|"\">"
argument_list|)
expr_stmt|;
name|printStream
operator|.
name|print
argument_list|(
name|substitutePredefinedEntries
argument_list|(
name|entryValue
argument_list|)
argument_list|)
expr_stmt|;
name|printStream
operator|.
name|println
argument_list|(
literal|"</entry>"
argument_list|)
expr_stmt|;
block|}
name|printStream
operator|.
name|println
argument_list|(
literal|"</properties>"
argument_list|)
expr_stmt|;
name|printStream
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
specifier|private
name|String
name|substitutePredefinedEntries
parameter_list|(
name|String
name|s
parameter_list|)
block|{
comment|/*          * substitution for predefined character entities to use them safely in          * XML          */
return|return
name|s
operator|.
name|replaceAll
argument_list|(
literal|"&"
argument_list|,
literal|"&amp;"
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"<"
argument_list|,
literal|"&lt;"
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|">"
argument_list|,
literal|"&gt;"
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\u0027"
argument_list|,
literal|"&apos;"
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\""
argument_list|,
literal|"&quot;"
argument_list|)
return|;
block|}
block|}
end_class

end_unit

