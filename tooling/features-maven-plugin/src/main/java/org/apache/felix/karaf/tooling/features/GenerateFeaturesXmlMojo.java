begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|karaf
operator|.
name|tooling
operator|.
name|features
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|ZipException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|ZipFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|Artifact
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|InvalidArtifactRTException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|metadata
operator|.
name|ArtifactMetadataRetrievalException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|metadata
operator|.
name|ResolutionGroup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|resolver
operator|.
name|ArtifactNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|resolver
operator|.
name|ArtifactResolutionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|resolver
operator|.
name|DefaultArtifactCollector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|resolver
operator|.
name|filter
operator|.
name|ArtifactFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|plugin
operator|.
name|MojoExecutionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|plugin
operator|.
name|MojoFailureException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|shared
operator|.
name|dependency
operator|.
name|tree
operator|.
name|DependencyNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|shared
operator|.
name|dependency
operator|.
name|tree
operator|.
name|DependencyTreeBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|shared
operator|.
name|dependency
operator|.
name|tree
operator|.
name|DependencyTreeBuilderException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|shared
operator|.
name|dependency
operator|.
name|tree
operator|.
name|traversal
operator|.
name|DependencyNodeVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|impl
operator|.
name|bundle
operator|.
name|obr
operator|.
name|resource
operator|.
name|Manifest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|impl
operator|.
name|bundle
operator|.
name|obr
operator|.
name|resource
operator|.
name|ManifestEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|impl
operator|.
name|bundle
operator|.
name|obr
operator|.
name|resource
operator|.
name|VersionRange
import|;
end_import

begin_comment
comment|/**  * Generates the features XML file  *   * @version $Revision: 1.1 $  * @goal generate-features-xml  * @phase compile  * @execute phase="compile"  * @requiresDependencyResolution runtime  * @inheritByDefault true  * @description Generates the features XML file  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
class|class
name|GenerateFeaturesXmlMojo
extends|extends
name|MojoSupport
block|{
specifier|protected
specifier|static
specifier|final
name|String
name|SEPARATOR
init|=
literal|"/"
decl_stmt|;
comment|/**      * The dependency tree builder to use.      *       * @component      * @required      * @readonly      */
specifier|private
name|DependencyTreeBuilder
name|dependencyTreeBuilder
decl_stmt|;
comment|/**      * The file to generate      *       * @parameter default-value="${project.build.directory}/classes/feature.xml"      */
specifier|private
name|File
name|outputFile
decl_stmt|;
comment|/**      * The artifact type for attaching the generated file to the project      *       * @parameter default-value="xml"      */
specifier|private
name|String
name|attachmentArtifactType
init|=
literal|"xml"
decl_stmt|;
comment|/**      * The artifact classifier for attaching the generated file to the project      *       * @parameter default-value="features"      */
specifier|private
name|String
name|attachmentArtifactClassifier
init|=
literal|"features"
decl_stmt|;
comment|/**      * The kernel version for which to generate the bundle      *       * @parameter      */
specifier|private
name|String
name|kernelVersion
decl_stmt|;
comment|/*      * A list of packages exported by the kernel      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|VersionRange
argument_list|>
name|kernelExports
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|VersionRange
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * A file containing the list of bundles      *       * @parameter      */
specifier|private
name|File
name|bundles
decl_stmt|;
comment|/*      * A set of known bundles      */
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|knownBundles
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/*      * A list of exports by the bundles      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|VersionRange
argument_list|,
name|Artifact
argument_list|>
argument_list|>
name|bundleExports
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|VersionRange
argument_list|,
name|Artifact
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/*      * The set of system exports      */
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|systemExports
init|=
operator|new
name|LinkedList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/*      * These bundles are the features that will be built      */
specifier|private
name|Map
argument_list|<
name|Artifact
argument_list|,
name|Feature
argument_list|>
name|features
init|=
operator|new
name|HashMap
argument_list|<
name|Artifact
argument_list|,
name|Feature
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|void
name|execute
parameter_list|()
throws|throws
name|MojoExecutionException
throws|,
name|MojoFailureException
block|{
name|PrintStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
name|out
operator|=
operator|new
name|PrintStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|outputFile
argument_list|)
argument_list|)
expr_stmt|;
name|readSystemPackages
argument_list|()
expr_stmt|;
name|readKernelBundles
argument_list|()
expr_stmt|;
name|readBundles
argument_list|()
expr_stmt|;
name|discoverBundles
argument_list|()
expr_stmt|;
name|writeFeatures
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|// now lets attach it
name|projectHelper
operator|.
name|attachArtifact
argument_list|(
name|project
argument_list|,
name|attachmentArtifactType
argument_list|,
name|attachmentArtifactClassifier
argument_list|,
name|outputFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|getLog
argument_list|()
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MojoExecutionException
argument_list|(
literal|"Unable to create features.xml file: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/*      * Read all the system provided packages from the<code>config.properties</code> file       */
specifier|private
name|void
name|readSystemPackages
parameter_list|()
throws|throws
name|IOException
block|{
name|Properties
name|properties
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|properties
operator|.
name|load
argument_list|(
name|getClass
argument_list|()
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
literal|"config.properties"
argument_list|)
argument_list|)
expr_stmt|;
name|readSystemPackages
argument_list|(
name|properties
argument_list|,
literal|"jre-1.5"
argument_list|)
expr_stmt|;
name|readSystemPackages
argument_list|(
name|properties
argument_list|,
literal|"osgi"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|readSystemPackages
parameter_list|(
name|Properties
name|properties
parameter_list|,
name|String
name|key
parameter_list|)
block|{
name|String
name|packages
init|=
operator|(
name|String
operator|)
name|properties
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|pkg
range|:
name|packages
operator|.
name|split
argument_list|(
literal|";"
argument_list|)
control|)
block|{
name|systemExports
operator|.
name|add
argument_list|(
name|pkg
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Download a Kernel distro and check the list of bundles provided by the Kernel      */
specifier|private
name|void
name|readKernelBundles
parameter_list|()
throws|throws
name|ArtifactResolutionException
throws|,
name|ArtifactNotFoundException
throws|,
name|MojoExecutionException
throws|,
name|ZipException
throws|,
name|IOException
throws|,
name|DependencyTreeBuilderException
block|{
specifier|final
name|Collection
argument_list|<
name|Artifact
argument_list|>
name|kernelArtifacts
decl_stmt|;
if|if
condition|(
name|kernelVersion
operator|==
literal|null
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"Step 1: Building list of provided bundle exports"
argument_list|)
expr_stmt|;
name|kernelArtifacts
operator|=
operator|new
name|HashSet
argument_list|<
name|Artifact
argument_list|>
argument_list|()
expr_stmt|;
name|DependencyNode
name|tree
init|=
name|dependencyTreeBuilder
operator|.
name|buildDependencyTree
argument_list|(
name|project
argument_list|,
name|localRepo
argument_list|,
name|factory
argument_list|,
name|artifactMetadataSource
argument_list|,
operator|new
name|ArtifactFilter
argument_list|()
block|{
specifier|public
name|boolean
name|include
parameter_list|(
name|Artifact
name|artifact
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
argument_list|,
operator|new
name|DefaultArtifactCollector
argument_list|()
argument_list|)
decl_stmt|;
name|tree
operator|.
name|accept
argument_list|(
operator|new
name|DependencyNodeVisitor
argument_list|()
block|{
specifier|public
name|boolean
name|endVisit
parameter_list|(
name|DependencyNode
name|node
parameter_list|)
block|{
comment|// we want the next sibling too
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|visit
parameter_list|(
name|DependencyNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getState
argument_list|()
operator|!=
name|DependencyNode
operator|.
name|OMITTED_FOR_CONFLICT
condition|)
block|{
name|Artifact
name|artifact
init|=
name|node
operator|.
name|getArtifact
argument_list|()
decl_stmt|;
if|if
condition|(
name|Artifact
operator|.
name|SCOPE_PROVIDED
operator|.
name|equals
argument_list|(
name|artifact
operator|.
name|getScope
argument_list|()
argument_list|)
operator|&&
operator|!
name|artifact
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
literal|"pom"
argument_list|)
condition|)
block|{
name|kernelArtifacts
operator|.
name|add
argument_list|(
name|artifact
argument_list|)
expr_stmt|;
block|}
block|}
comment|// we want the children too
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"Step 1 : Building list of kernel exports"
argument_list|)
expr_stmt|;
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"Use of 'kernelVersion' is deprecated -- use a dependency with scope 'provided' instead"
argument_list|)
expr_stmt|;
name|Artifact
name|kernel
init|=
name|factory
operator|.
name|createArtifact
argument_list|(
literal|"org.apache.servicemix.kernel"
argument_list|,
literal|"apache-servicemix-kernel"
argument_list|,
name|kernelVersion
argument_list|,
name|Artifact
operator|.
name|SCOPE_PROVIDED
argument_list|,
literal|"pom"
argument_list|)
decl_stmt|;
name|resolver
operator|.
name|resolve
argument_list|(
name|kernel
argument_list|,
name|remoteRepos
argument_list|,
name|localRepo
argument_list|)
expr_stmt|;
name|kernelArtifacts
operator|=
name|getDependencies
argument_list|(
name|kernel
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Artifact
name|artifact
range|:
name|kernelArtifacts
control|)
block|{
name|registerKernelBundle
argument_list|(
name|artifact
argument_list|)
expr_stmt|;
block|}
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"...done!"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|registerKernelBundle
parameter_list|(
name|Artifact
name|artifact
parameter_list|)
throws|throws
name|ArtifactResolutionException
throws|,
name|ArtifactNotFoundException
throws|,
name|ZipException
throws|,
name|IOException
block|{
name|Manifest
name|manifest
init|=
name|getManifest
argument_list|(
name|artifact
argument_list|)
decl_stmt|;
if|if
condition|(
name|manifest
operator|.
name|getExports
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ManifestEntry
name|entry
range|:
operator|(
name|List
argument_list|<
name|ManifestEntry
argument_list|>
operator|)
name|manifest
operator|.
name|getExports
argument_list|()
control|)
block|{
name|kernelExports
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getName
argument_list|()
argument_list|,
name|entry
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|" adding kernel export "
operator|+
name|entry
operator|.
name|getName
argument_list|()
operator|+
literal|" ("
operator|+
name|entry
operator|.
name|getVersion
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
name|registerBundle
argument_list|(
name|artifact
argument_list|)
expr_stmt|;
block|}
comment|/*      * Read the list of bundles we can use to satisfy links      */
specifier|private
name|void
name|readBundles
parameter_list|()
throws|throws
name|IOException
throws|,
name|ArtifactResolutionException
throws|,
name|ArtifactNotFoundException
block|{
name|BufferedReader
name|reader
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|bundles
operator|!=
literal|null
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"Step 2 : Building a list of exports for bundles in "
operator|+
name|bundles
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|FileReader
argument_list|(
name|bundles
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|line
init|=
name|reader
operator|.
name|readLine
argument_list|()
decl_stmt|;
while|while
condition|(
name|line
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|line
operator|.
name|contains
argument_list|(
literal|"/"
argument_list|)
operator|&&
operator|!
name|line
operator|.
name|startsWith
argument_list|(
literal|"#"
argument_list|)
condition|)
block|{
name|String
index|[]
name|elements
init|=
name|line
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
name|Artifact
name|artifact
init|=
name|factory
operator|.
name|createArtifact
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|,
name|elements
index|[
literal|1
index|]
argument_list|,
name|elements
index|[
literal|2
index|]
argument_list|,
name|Artifact
operator|.
name|SCOPE_PROVIDED
argument_list|,
name|elements
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|registerBundle
argument_list|(
name|artifact
argument_list|)
expr_stmt|;
block|}
name|line
operator|=
name|reader
operator|.
name|readLine
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"Step 2 : No Bundle file supplied for building list of exports"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"...done!"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Auto-discover bundles currently in the dependencies      */
specifier|private
name|void
name|discoverBundles
parameter_list|()
throws|throws
name|ArtifactResolutionException
throws|,
name|ArtifactNotFoundException
throws|,
name|ZipException
throws|,
name|IOException
block|{
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"Step 3 : Discovering bundles in Maven dependencies"
argument_list|)
expr_stmt|;
for|for
control|(
name|Artifact
name|dependency
range|:
operator|(
name|Set
argument_list|<
name|Artifact
argument_list|>
operator|)
name|project
operator|.
name|getArtifacts
argument_list|()
control|)
block|{
comment|// we will generate a feature for this afterwards
if|if
condition|(
name|project
operator|.
name|getDependencyArtifacts
argument_list|()
operator|.
name|contains
argument_list|(
name|dependency
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// this is a provided bundle, has been handled in step 1
if|if
condition|(
name|dependency
operator|.
name|getScope
argument_list|()
operator|.
name|equals
argument_list|(
name|Artifact
operator|.
name|SCOPE_PROVIDED
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|isDiscoverableBundle
argument_list|(
name|dependency
argument_list|)
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"  Discovered "
operator|+
name|dependency
argument_list|)
expr_stmt|;
name|registerBundle
argument_list|(
name|dependency
argument_list|)
expr_stmt|;
block|}
block|}
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"...done!"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Write all project dependencies as feature      */
specifier|private
name|void
name|writeFeatures
parameter_list|(
name|PrintStream
name|out
parameter_list|)
throws|throws
name|ArtifactResolutionException
throws|,
name|ArtifactNotFoundException
throws|,
name|ZipException
throws|,
name|IOException
block|{
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"Step 4 : Generating "
operator|+
name|outputFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"<features>"
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Artifact
argument_list|>
name|dependencies
init|=
operator|(
name|Set
argument_list|<
name|Artifact
argument_list|>
operator|)
name|project
operator|.
name|getDependencyArtifacts
argument_list|()
decl_stmt|;
for|for
control|(
name|Artifact
name|artifact
range|:
name|dependencies
control|)
block|{
if|if
condition|(
operator|!
name|artifact
operator|.
name|getScope
argument_list|()
operator|.
name|equals
argument_list|(
name|Artifact
operator|.
name|SCOPE_PROVIDED
argument_list|)
operator|&&
operator|!
name|artifact
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
literal|"pom"
argument_list|)
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|" Generating feature "
operator|+
name|artifact
operator|.
name|getArtifactId
argument_list|()
operator|+
literal|" from "
operator|+
name|artifact
argument_list|)
expr_stmt|;
name|Feature
name|feature
init|=
name|getFeature
argument_list|(
name|artifact
argument_list|)
decl_stmt|;
name|feature
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|registerFeature
argument_list|(
name|artifact
argument_list|,
name|feature
argument_list|)
expr_stmt|;
block|}
block|}
name|out
operator|.
name|println
argument_list|(
literal|"</features>"
argument_list|)
expr_stmt|;
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"...done!"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Get the feature for an artifact       */
specifier|private
name|Feature
name|getFeature
parameter_list|(
name|Artifact
name|artifact
parameter_list|)
throws|throws
name|ArtifactResolutionException
throws|,
name|ArtifactNotFoundException
throws|,
name|ZipException
throws|,
name|IOException
block|{
name|Feature
name|feature
init|=
operator|new
name|Feature
argument_list|(
name|artifact
argument_list|)
decl_stmt|;
name|addRequirements
argument_list|(
name|artifact
argument_list|,
name|feature
argument_list|)
expr_stmt|;
return|return
name|feature
return|;
block|}
comment|/*      * Only auto-discover an OSGi bundle      * - if it is not already known as a feature itself      * - if it is not another version of an already known bundle      */
specifier|private
name|boolean
name|isDiscoverableBundle
parameter_list|(
name|Artifact
name|artifact
parameter_list|)
block|{
if|if
condition|(
name|isBundle
argument_list|(
name|artifact
argument_list|)
operator|&&
operator|!
name|isFeature
argument_list|(
name|artifact
argument_list|)
operator|&&
operator|!
name|artifact
operator|.
name|getScope
argument_list|()
operator|.
name|equals
argument_list|(
name|Artifact
operator|.
name|SCOPE_PROVIDED
argument_list|)
condition|)
block|{
for|for
control|(
name|String
name|known
range|:
name|knownBundles
control|)
block|{
name|String
index|[]
name|elements
init|=
name|known
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
if|if
condition|(
name|artifact
operator|.
name|getGroupId
argument_list|()
operator|.
name|equals
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|)
operator|&&
name|artifact
operator|.
name|getArtifactId
argument_list|()
operator|.
name|equals
argument_list|(
name|elements
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"  Avoid auto-discovery for %s because of existing bundle %s"
argument_list|,
name|toString
argument_list|(
name|artifact
argument_list|)
argument_list|,
name|known
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/*      * Check if the given artifact is a bundle      */
specifier|private
name|boolean
name|isBundle
parameter_list|(
name|Artifact
name|artifact
parameter_list|)
block|{
if|if
condition|(
name|knownBundles
operator|.
name|contains
argument_list|(
name|toString
argument_list|(
name|artifact
argument_list|)
argument_list|)
operator|||
name|artifact
operator|.
name|getArtifactHandler
argument_list|()
operator|.
name|getPackaging
argument_list|()
operator|.
name|equals
argument_list|(
literal|"bundle"
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
try|try
block|{
name|Manifest
name|manifest
init|=
name|getManifest
argument_list|(
name|artifact
argument_list|)
decl_stmt|;
if|if
condition|(
name|manifest
operator|.
name|getBsn
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"MANIFEST.MF for '%s' contains Bundle-Name '%s'"
argument_list|,
name|artifact
argument_list|,
name|manifest
operator|.
name|getBsn
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
catch|catch
parameter_list|(
name|ZipException
name|e
parameter_list|)
block|{
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"Unable to determine if "
operator|+
name|artifact
operator|+
literal|" is a bundle; defaulting to false"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"Unable to determine if "
operator|+
name|artifact
operator|+
literal|" is a bundle; defaulting to false"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"Unable to determine if "
operator|+
name|artifact
operator|+
literal|" is a bundle; defaulting to false"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/*      * Add requirements for an artifact to a feature      */
specifier|private
name|void
name|addRequirements
parameter_list|(
name|Artifact
name|artifact
parameter_list|,
name|Feature
name|feature
parameter_list|)
throws|throws
name|ArtifactResolutionException
throws|,
name|ArtifactNotFoundException
throws|,
name|ZipException
throws|,
name|IOException
block|{
name|Manifest
name|manifest
init|=
name|getManifest
argument_list|(
name|artifact
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|ManifestEntry
argument_list|>
name|remaining
init|=
name|getRemainingImports
argument_list|(
name|manifest
argument_list|)
decl_stmt|;
name|Artifact
name|previous
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ManifestEntry
name|entry
range|:
name|remaining
control|)
block|{
name|Artifact
name|add
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|VersionRange
argument_list|,
name|Artifact
argument_list|>
name|versions
init|=
name|bundleExports
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|versions
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|VersionRange
name|range
range|:
name|versions
operator|.
name|keySet
argument_list|()
control|)
block|{
name|add
operator|=
name|versions
operator|.
name|get
argument_list|(
name|range
argument_list|)
expr_stmt|;
if|if
condition|(
name|range
operator|.
name|compareTo
argument_list|(
name|entry
operator|.
name|getVersion
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|add
operator|=
name|versions
operator|.
name|get
argument_list|(
name|range
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|add
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isOptional
argument_list|(
name|entry
argument_list|)
condition|)
block|{
comment|// debug logging for optional dependency...
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"  Unable to find suitable bundle for optional dependency %s (%s)"
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|,
name|entry
operator|.
name|getVersion
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// ...but a warning for a mandatory dependency
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"  Unable to find suitable bundle for dependency %s (%s) (required by %s)"
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|,
name|entry
operator|.
name|getVersion
argument_list|()
argument_list|,
name|artifact
operator|.
name|getArtifactId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|add
operator|.
name|equals
argument_list|(
name|previous
argument_list|)
operator|&&
name|feature
operator|.
name|push
argument_list|(
name|add
argument_list|)
operator|&&
operator|!
name|isFeature
argument_list|(
name|add
argument_list|)
condition|)
block|{
comment|//and get requirements for the bundle we just added
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"  Getting requirements for "
operator|+
name|add
argument_list|)
expr_stmt|;
name|addRequirements
argument_list|(
name|add
argument_list|,
name|feature
argument_list|)
expr_stmt|;
block|}
block|}
name|previous
operator|=
name|add
expr_stmt|;
block|}
block|}
comment|/*      * Check if a given bundle is itself being generated as a feature      */
specifier|private
name|boolean
name|isFeature
parameter_list|(
name|Artifact
name|artifact
parameter_list|)
block|{
return|return
name|features
operator|.
name|containsKey
argument_list|(
name|artifact
argument_list|)
return|;
block|}
comment|/*      * Check a manifest entry and check if the resolution for the import has been marked as optional       */
specifier|private
name|boolean
name|isOptional
parameter_list|(
name|ManifestEntry
name|entry
parameter_list|)
block|{
return|return
name|entry
operator|.
name|getAttributes
argument_list|()
operator|!=
literal|null
operator|&&
name|entry
operator|.
name|getAttributes
argument_list|()
operator|.
name|get
argument_list|(
literal|"resolution:"
argument_list|)
operator|!=
literal|null
operator|&&
name|entry
operator|.
name|getAttributes
argument_list|()
operator|.
name|get
argument_list|(
literal|"resolution:"
argument_list|)
operator|.
name|equals
argument_list|(
literal|"optional"
argument_list|)
return|;
block|}
comment|/*      * Register a bundle, enlisting all packages it provides      */
specifier|private
name|void
name|registerBundle
parameter_list|(
name|Artifact
name|artifact
parameter_list|)
throws|throws
name|ArtifactResolutionException
throws|,
name|ArtifactNotFoundException
throws|,
name|ZipException
throws|,
name|IOException
block|{
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"Registering bundle "
operator|+
name|artifact
argument_list|)
expr_stmt|;
name|knownBundles
operator|.
name|add
argument_list|(
name|toString
argument_list|(
name|artifact
argument_list|)
argument_list|)
expr_stmt|;
name|Manifest
name|manifest
init|=
name|getManifest
argument_list|(
name|artifact
argument_list|)
decl_stmt|;
for|for
control|(
name|ManifestEntry
name|entry
range|:
name|getManifestEntries
argument_list|(
name|manifest
operator|.
name|getExports
argument_list|()
argument_list|)
control|)
block|{
name|Map
argument_list|<
name|VersionRange
argument_list|,
name|Artifact
argument_list|>
name|versions
init|=
name|bundleExports
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|versions
operator|==
literal|null
condition|)
block|{
name|versions
operator|=
operator|new
name|HashMap
argument_list|<
name|VersionRange
argument_list|,
name|Artifact
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|versions
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getVersion
argument_list|()
argument_list|,
name|artifact
argument_list|)
expr_stmt|;
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|" %s exported by bundle %s"
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|,
name|artifact
argument_list|)
argument_list|)
expr_stmt|;
name|bundleExports
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getName
argument_list|()
argument_list|,
name|versions
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Register a feature and also register the bundle for the feature      */
specifier|private
name|void
name|registerFeature
parameter_list|(
name|Artifact
name|artifact
parameter_list|,
name|Feature
name|feature
parameter_list|)
throws|throws
name|ArtifactResolutionException
throws|,
name|ArtifactNotFoundException
throws|,
name|ZipException
throws|,
name|IOException
block|{
name|features
operator|.
name|put
argument_list|(
name|artifact
argument_list|,
name|feature
argument_list|)
expr_stmt|;
name|registerBundle
argument_list|(
name|artifact
argument_list|)
expr_stmt|;
block|}
comment|/*      * Determine the list of imports to be resolved      */
specifier|private
name|Collection
argument_list|<
name|ManifestEntry
argument_list|>
name|getRemainingImports
parameter_list|(
name|Manifest
name|manifest
parameter_list|)
block|{
comment|// take all imports
name|Collection
argument_list|<
name|ManifestEntry
argument_list|>
name|input
init|=
name|getManifestEntries
argument_list|(
name|manifest
operator|.
name|getImports
argument_list|()
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|ManifestEntry
argument_list|>
name|output
init|=
operator|new
name|LinkedList
argument_list|<
name|ManifestEntry
argument_list|>
argument_list|(
name|input
argument_list|)
decl_stmt|;
comment|// remove imports satisfied by exports in the same bundle
for|for
control|(
name|ManifestEntry
name|entry
range|:
name|input
control|)
block|{
for|for
control|(
name|ManifestEntry
name|export
range|:
name|getManifestEntries
argument_list|(
name|manifest
operator|.
name|getExports
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|export
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|output
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// remove imports for packages exported by the kernel
for|for
control|(
name|ManifestEntry
name|entry
range|:
name|input
control|)
block|{
for|for
control|(
name|String
name|export
range|:
name|kernelExports
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|export
argument_list|)
condition|)
block|{
name|output
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// remove imports for packages exported by the system bundle
for|for
control|(
name|ManifestEntry
name|entry
range|:
name|input
control|)
block|{
if|if
condition|(
name|systemExports
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|output
operator|.
name|remove
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|output
return|;
block|}
specifier|private
name|Collection
argument_list|<
name|ManifestEntry
argument_list|>
name|getManifestEntries
parameter_list|(
name|List
name|imports
parameter_list|)
block|{
if|if
condition|(
name|imports
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|LinkedList
argument_list|<
name|ManifestEntry
argument_list|>
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|Collection
argument_list|<
name|ManifestEntry
argument_list|>
operator|)
name|imports
return|;
block|}
block|}
specifier|private
name|Manifest
name|getManifest
parameter_list|(
name|Artifact
name|artifact
parameter_list|)
throws|throws
name|ArtifactResolutionException
throws|,
name|ArtifactNotFoundException
throws|,
name|ZipException
throws|,
name|IOException
block|{
name|File
name|localFile
init|=
operator|new
name|File
argument_list|(
name|localRepo
operator|.
name|pathOf
argument_list|(
name|artifact
argument_list|)
argument_list|)
decl_stmt|;
name|ZipFile
name|file
decl_stmt|;
if|if
condition|(
name|localFile
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|//avoid going over to the repository if the file is already on the disk
name|file
operator|=
operator|new
name|ZipFile
argument_list|(
name|localFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|resolver
operator|.
name|resolve
argument_list|(
name|artifact
argument_list|,
name|remoteRepos
argument_list|,
name|localRepo
argument_list|)
expr_stmt|;
name|file
operator|=
operator|new
name|ZipFile
argument_list|(
name|artifact
operator|.
name|getFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Manifest
argument_list|(
name|file
operator|.
name|getInputStream
argument_list|(
name|file
operator|.
name|getEntry
argument_list|(
literal|"META-INF/MANIFEST.MF"
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|List
argument_list|<
name|Artifact
argument_list|>
name|getDependencies
parameter_list|(
name|Artifact
name|artifact
parameter_list|)
block|{
name|List
argument_list|<
name|Artifact
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|Artifact
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|ResolutionGroup
name|pom
init|=
name|artifactMetadataSource
operator|.
name|retrieve
argument_list|(
name|artifact
argument_list|,
name|localRepo
argument_list|,
name|remoteRepos
argument_list|)
decl_stmt|;
if|if
condition|(
name|pom
operator|!=
literal|null
condition|)
block|{
name|list
operator|.
name|addAll
argument_list|(
name|pom
operator|.
name|getArtifacts
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ArtifactMetadataRetrievalException
name|e
parameter_list|)
block|{
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"Unable to retrieve metadata for "
operator|+
name|artifact
operator|+
literal|", not including dependencies for it"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidArtifactRTException
name|e
parameter_list|)
block|{
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"Unable to retrieve metadata for "
operator|+
name|artifact
operator|+
literal|", not including dependencies for it"
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|Artifact
name|artifact
parameter_list|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%s/%s/%s"
argument_list|,
name|artifact
operator|.
name|getGroupId
argument_list|()
argument_list|,
name|artifact
operator|.
name|getArtifactId
argument_list|()
argument_list|,
name|artifact
operator|.
name|getVersion
argument_list|()
argument_list|)
return|;
block|}
specifier|private
class|class
name|Feature
block|{
specifier|private
name|Stack
argument_list|<
name|Artifact
argument_list|>
name|artifacts
init|=
operator|new
name|Stack
argument_list|<
name|Artifact
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Artifact
name|artifact
decl_stmt|;
specifier|private
name|Feature
parameter_list|(
name|Artifact
name|artifact
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|artifact
operator|=
name|artifact
expr_stmt|;
name|artifacts
operator|.
name|push
argument_list|(
name|artifact
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|push
parameter_list|(
name|Artifact
name|item
parameter_list|)
block|{
if|if
condition|(
name|artifacts
operator|.
name|contains
argument_list|(
name|item
argument_list|)
condition|)
block|{
name|artifacts
operator|.
name|remove
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|artifacts
operator|.
name|push
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|artifacts
operator|.
name|contains
argument_list|(
name|item
argument_list|)
condition|)
block|{
name|artifacts
operator|.
name|push
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|write
parameter_list|(
name|PrintStream
name|out
parameter_list|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"<feature name='"
operator|+
name|artifact
operator|.
name|getArtifactId
argument_list|()
operator|+
literal|"' version='"
operator|+
name|artifact
operator|.
name|getBaseVersion
argument_list|()
operator|+
literal|"'>"
argument_list|)
expr_stmt|;
name|Stack
argument_list|<
name|Artifact
argument_list|>
name|resulting
init|=
operator|new
name|Stack
argument_list|<
name|Artifact
argument_list|>
argument_list|()
decl_stmt|;
name|resulting
operator|.
name|addAll
argument_list|(
name|artifacts
argument_list|)
expr_stmt|;
comment|// remove dependencies for included features
for|for
control|(
name|Artifact
name|next
range|:
name|artifacts
control|)
block|{
if|if
condition|(
name|isFeature
argument_list|(
name|next
argument_list|)
condition|)
block|{
name|resulting
operator|.
name|removeAll
argument_list|(
name|features
operator|.
name|get
argument_list|(
name|next
argument_list|)
operator|.
name|getDependencies
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
name|resulting
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Artifact
name|next
init|=
name|resulting
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|isFeature
argument_list|(
name|next
argument_list|)
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"<feature version='"
operator|+
name|next
operator|.
name|getBaseVersion
argument_list|()
operator|+
literal|"'>"
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%s</feature>"
argument_list|,
name|next
operator|.
name|getArtifactId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|println
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"<bundle>mvn:%s/%s/%s</bundle>"
argument_list|,
name|next
operator|.
name|getGroupId
argument_list|()
argument_list|,
name|next
operator|.
name|getArtifactId
argument_list|()
argument_list|,
name|next
operator|.
name|getBaseVersion
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|out
operator|.
name|println
argument_list|(
literal|"</feature>"
argument_list|)
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|Artifact
argument_list|>
name|getDependencies
parameter_list|()
block|{
name|List
argument_list|<
name|Artifact
argument_list|>
name|dependencies
init|=
operator|new
name|LinkedList
argument_list|<
name|Artifact
argument_list|>
argument_list|(
name|artifacts
argument_list|)
decl_stmt|;
name|dependencies
operator|.
name|remove
argument_list|(
name|artifact
argument_list|)
expr_stmt|;
return|return
name|dependencies
return|;
block|}
block|}
block|}
end_class

end_unit

