begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *   http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|gogo
operator|.
name|runtime
package|;
end_package

begin_comment
comment|/**  * Bash-like tokenizer.  *   * Single and double quotes are just like Bash - single quotes escape everything  * (including backslashes), newlines are allowed in quotes.  * backslash-newline indicates a line continuation and is removed.  *   * Variable expansion is just like Bash: $NAME or ${NAME[[:][-+=?WORD]},  * except it can yield any Object. Variables expanded within double-quotes,  * or adjacent to a String are converted to String.  *   * Unlike bash, indirect variable expansion is supported using ${$NAME}.  *   * Only a single variable assignment is recognized, with '=' being the second token.  * (Bash allows name1=value1 name2=value2 ... command args)  *   * Comments can only start where white space is allowed:  * # or // starts a line comment, /* starts a block comment.  * The following common uses do NOT start comments:  *    ls http://example.com#anchor  *    ls $dir/*.java  *   * @see http://wiki.bash-hackers.org/syntax/basicgrammar  */
end_comment

begin_class
specifier|public
class|class
name|Tokenizer
block|{
specifier|public
enum|enum
name|Type
block|{
name|ASSIGN
argument_list|(
literal|'='
argument_list|)
block|,
name|PIPE
argument_list|(
literal|'|'
argument_list|)
block|,
name|SEMICOLON
argument_list|(
literal|';'
argument_list|)
block|,
name|NEWLINE
block|,
name|ARRAY
block|,
name|CLOSURE
block|,
name|EXPR
block|,
name|EXECUTION
block|,
name|WORD
block|,
name|EOT
block|;
specifier|private
name|char
name|c
decl_stmt|;
name|Type
parameter_list|()
block|{         }
name|Type
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|this
operator|.
name|c
operator|=
name|c
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
operator|(
name|c
operator|==
literal|0
condition|?
name|super
operator|.
name|toString
argument_list|()
else|:
literal|"'"
operator|+
name|c
operator|+
literal|"'"
operator|)
return|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|boolean
name|DEBUG
init|=
literal|false
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|EOT
init|=
operator|(
name|char
operator|)
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|final
name|CharSequence
name|text
decl_stmt|;
specifier|private
specifier|final
name|Evaluate
name|evaluate
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|inArray
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|inQuote
decl_stmt|;
comment|//extra to disable some special handling of brackets etc. needed for CQL-Completion
specifier|private
specifier|final
name|boolean
name|isExpansionEnabled
decl_stmt|;
specifier|private
name|Type
name|type
init|=
name|Type
operator|.
name|NEWLINE
decl_stmt|;
specifier|private
name|CharSequence
name|value
decl_stmt|;
specifier|private
name|Token
name|token
decl_stmt|;
specifier|private
name|short
name|line
decl_stmt|;
specifier|private
name|short
name|column
decl_stmt|;
specifier|private
name|char
name|ch
decl_stmt|;
specifier|private
name|int
name|index
decl_stmt|;
specifier|private
name|boolean
name|firstWord
decl_stmt|;
specifier|public
name|Tokenizer
parameter_list|(
name|CharSequence
name|text
parameter_list|)
block|{
name|this
argument_list|(
name|text
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Tokenizer
parameter_list|(
name|CharSequence
name|text
parameter_list|,
name|Evaluate
name|evaluate
parameter_list|,
name|boolean
name|inQuote
parameter_list|)
block|{
name|this
argument_list|(
name|text
argument_list|,
name|evaluate
argument_list|,
name|inQuote
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|//This constructor gets the isExpansionEnabled flag for extra handling of a CQL-Like shell
specifier|public
name|Tokenizer
parameter_list|(
name|CharSequence
name|text
parameter_list|,
name|Evaluate
name|evaluate
parameter_list|,
name|boolean
name|inQuote
parameter_list|,
name|boolean
name|isExpansionEnabled
parameter_list|)
block|{
name|this
operator|.
name|text
operator|=
name|text
expr_stmt|;
name|this
operator|.
name|evaluate
operator|=
name|evaluate
expr_stmt|;
name|this
operator|.
name|inQuote
operator|=
name|inQuote
expr_stmt|;
name|this
operator|.
name|isExpansionEnabled
operator|=
name|isExpansionEnabled
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
name|line
operator|=
name|column
operator|=
literal|1
expr_stmt|;
name|boolean
name|array
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|text
operator|instanceof
name|Token
condition|)
block|{
name|Token
name|t
init|=
operator|(
name|Token
operator|)
name|text
decl_stmt|;
name|line
operator|=
name|t
operator|.
name|line
expr_stmt|;
name|column
operator|=
name|t
operator|.
name|column
expr_stmt|;
name|array
operator|=
operator|(
name|Type
operator|.
name|ARRAY
operator|==
name|t
operator|.
name|type
operator|)
expr_stmt|;
block|}
name|inArray
operator|=
name|array
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
if|if
condition|(
name|inArray
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Tokenizer["
operator|+
name|text
operator|+
literal|"]"
argument_list|)
expr_stmt|;
else|else
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Tokenizer<"
operator|+
name|text
operator|+
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|Type
name|type
parameter_list|()
block|{
return|return
name|type
return|;
block|}
specifier|public
name|CharSequence
name|value
parameter_list|()
block|{
return|return
name|value
return|;
block|}
specifier|public
name|Token
name|token
parameter_list|()
block|{
return|return
name|token
return|;
block|}
specifier|public
name|Type
name|next
parameter_list|()
block|{
specifier|final
name|Type
name|prevType
init|=
name|type
decl_stmt|;
name|token
operator|=
literal|null
expr_stmt|;
name|value
operator|=
literal|null
expr_stmt|;
name|short
name|tLine
decl_stmt|;
name|short
name|tColumn
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|skipSpace
argument_list|()
expr_stmt|;
name|tLine
operator|=
name|line
expr_stmt|;
name|tColumn
operator|=
name|column
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|EOT
case|:
name|type
operator|=
name|Type
operator|.
name|EOT
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|inArray
condition|)
continue|continue;
comment|// only return NEWLINE once and not if not preceded by ; or |
switch|switch
condition|(
name|prevType
condition|)
block|{
case|case
name|PIPE
case|:
case|case
name|SEMICOLON
case|:
case|case
name|NEWLINE
case|:
continue|continue;
default|default:
name|type
operator|=
name|Type
operator|.
name|NEWLINE
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'{'
case|:
case|case
literal|'('
case|:
case|case
literal|'['
case|:
if|if
condition|(
name|isExpansionEnabled
condition|)
block|{
comment|//Disabled for CQL
name|value
operator|=
name|group
argument_list|()
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//treat it as normal word
name|value
operator|=
name|word
argument_list|()
expr_stmt|;
name|type
operator|=
name|Type
operator|.
name|WORD
expr_stmt|;
block|}
break|break;
case|case
literal|';'
case|:
name|getch
argument_list|()
expr_stmt|;
name|type
operator|=
name|Type
operator|.
name|SEMICOLON
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|getch
argument_list|()
expr_stmt|;
name|type
operator|=
name|Type
operator|.
name|PIPE
expr_stmt|;
break|break;
case|case
literal|'='
case|:
if|if
condition|(
name|firstWord
operator|||
name|inArray
condition|)
block|{
name|getch
argument_list|()
expr_stmt|;
name|type
operator|=
name|Type
operator|.
name|ASSIGN
expr_stmt|;
break|break;
block|}
comment|// fall through
default|default:
name|value
operator|=
name|word
argument_list|()
expr_stmt|;
name|type
operator|=
name|Type
operator|.
name|WORD
expr_stmt|;
block|}
name|firstWord
operator|=
operator|(
name|Type
operator|.
name|WORD
operator|==
name|type
operator|&&
operator|(
name|Type
operator|.
name|WORD
operator|!=
name|prevType
operator|&&
name|Type
operator|.
name|ASSIGN
operator|!=
name|prevType
operator|)
operator|)
expr_stmt|;
name|token
operator|=
operator|new
name|Token
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
name|tLine
argument_list|,
name|tColumn
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|print
argument_list|(
literal|"<"
operator|+
name|type
operator|+
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Type
operator|.
name|EOT
operator|==
name|type
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|type
return|;
block|}
block|}
specifier|private
name|CharSequence
name|word
parameter_list|()
block|{
name|int
name|start
init|=
name|index
operator|-
literal|1
decl_stmt|;
name|int
name|skipCR
init|=
literal|0
decl_stmt|;
do|do
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\n'
case|:
if|if
condition|(
name|index
operator|>=
literal|2
operator|&&
name|text
operator|.
name|charAt
argument_list|(
name|index
operator|-
literal|2
argument_list|)
operator|==
literal|'\r'
condition|)
name|skipCR
operator|=
literal|1
expr_stmt|;
comment|// fall through
case|case
literal|'='
case|:
if|if
condition|(
operator|(
name|Type
operator|.
name|WORD
operator|==
name|type
operator|||
name|Type
operator|.
name|ASSIGN
operator|==
name|type
operator|)
operator|&&
literal|'='
operator|==
name|ch
operator|&&
operator|!
name|inArray
condition|)
continue|continue;
comment|// fall through
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'|'
case|:
case|case
literal|';'
case|:
return|return
name|text
operator|.
name|subSequence
argument_list|(
name|start
argument_list|,
name|index
operator|-
literal|1
operator|-
name|skipCR
argument_list|)
return|;
case|case
literal|'{'
case|:
name|group
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|escape
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
name|skipQuote
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|getch
argument_list|()
operator|!=
name|EOT
condition|)
do|;
return|return
name|text
operator|.
name|subSequence
argument_list|(
name|start
argument_list|,
name|index
operator|-
literal|1
argument_list|)
return|;
block|}
specifier|private
name|CharSequence
name|group
parameter_list|()
block|{
specifier|final
name|char
name|push
init|=
name|ch
decl_stmt|;
specifier|final
name|char
name|push2
decl_stmt|;
specifier|final
name|char
name|pop
decl_stmt|;
specifier|final
name|char
name|pop2
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'{'
case|:
name|type
operator|=
name|Type
operator|.
name|CLOSURE
expr_stmt|;
name|push2
operator|=
literal|0
expr_stmt|;
name|pop
operator|=
literal|'}'
expr_stmt|;
name|pop2
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'('
case|:
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'('
condition|)
block|{
name|getch
argument_list|()
expr_stmt|;
name|push2
operator|=
literal|'('
expr_stmt|;
name|type
operator|=
name|Type
operator|.
name|EXPR
expr_stmt|;
name|pop
operator|=
literal|')'
expr_stmt|;
name|pop2
operator|=
literal|')'
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|Type
operator|.
name|EXECUTION
expr_stmt|;
name|push2
operator|=
literal|0
expr_stmt|;
name|pop
operator|=
literal|')'
expr_stmt|;
name|pop2
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'['
case|:
name|type
operator|=
name|Type
operator|.
name|ARRAY
expr_stmt|;
name|push2
operator|=
literal|0
expr_stmt|;
name|pop
operator|=
literal|']'
expr_stmt|;
name|pop2
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
assert|assert
literal|false
assert|;
name|push2
operator|=
literal|0
expr_stmt|;
name|pop
operator|=
literal|0
expr_stmt|;
name|pop2
operator|=
literal|0
expr_stmt|;
block|}
name|short
name|sLine
init|=
name|line
decl_stmt|;
name|short
name|sCol
init|=
name|column
decl_stmt|;
name|int
name|start
init|=
name|index
decl_stmt|;
name|int
name|depth
init|=
literal|1
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|boolean
name|comment
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'{'
case|:
case|case
literal|'('
case|:
case|case
literal|'['
case|:
case|case
literal|'\n'
case|:
name|comment
operator|=
literal|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|getch
argument_list|()
operator|==
name|EOT
condition|)
block|{
throw|throw
operator|new
name|EOFError
argument_list|(
name|sLine
argument_list|,
name|sCol
argument_list|,
literal|"unexpected EOT looking for matching '"
operator|+
name|pop
operator|+
literal|"'"
argument_list|)
throw|;
block|}
comment|// don't recognize comments that start within a word
if|if
condition|(
name|comment
operator|||
name|isBlank
argument_list|(
name|ch
argument_list|)
condition|)
name|skipSpace
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
name|skipQuote
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|ch
operator|=
name|escape
argument_list|()
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|push
operator|==
name|ch
condition|)
block|{
name|depth
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pop
operator|==
name|ch
operator|&&
operator|--
name|depth
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pop2
operator|==
literal|0
condition|)
return|return
name|text
operator|.
name|subSequence
argument_list|(
name|start
argument_list|,
name|index
operator|-
literal|1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|pop2
operator|==
name|peek
argument_list|()
condition|)
block|{
name|getch
argument_list|()
expr_stmt|;
return|return
name|text
operator|.
name|subSequence
argument_list|(
name|start
argument_list|,
name|index
operator|-
literal|2
argument_list|)
return|;
block|}
block|}
block|}
block|}
block|}
specifier|private
name|char
name|escape
parameter_list|()
block|{
assert|assert
literal|'\\'
operator|==
name|ch
assert|;
switch|switch
condition|(
name|getch
argument_list|()
condition|)
block|{
case|case
literal|'u'
case|:
name|getch
argument_list|()
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|EOT
operator|==
name|ch
condition|)
block|{
throw|throw
operator|new
name|EOFError
argument_list|(
name|line
argument_list|,
name|column
argument_list|,
literal|"unexpected EOT in \\u escape"
argument_list|)
throw|;
block|}
name|String
name|u
init|=
name|text
operator|.
name|subSequence
argument_list|(
name|index
operator|-
literal|4
argument_list|,
name|index
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
try|try
block|{
return|return
operator|(
name|char
operator|)
name|Integer
operator|.
name|parseInt
argument_list|(
name|u
argument_list|,
literal|16
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SyntaxError
argument_list|(
name|line
argument_list|,
name|column
argument_list|,
literal|"bad unicode escape: \\u"
operator|+
name|u
argument_list|)
throw|;
block|}
case|case
name|EOT
case|:
throw|throw
operator|new
name|EOFError
argument_list|(
name|line
argument_list|,
name|column
argument_list|,
literal|"unexpected EOT in \\ escape"
argument_list|)
throw|;
case|case
literal|'\n'
case|:
return|return
literal|'\0'
return|;
comment|// line continuation
case|case
literal|'\\'
case|:
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
case|case
literal|'$'
case|:
return|return
name|ch
return|;
default|default:
return|return
name|ch
return|;
block|}
block|}
specifier|private
name|void
name|skipQuote
parameter_list|()
block|{
assert|assert
literal|'\''
operator|==
name|ch
operator|||
literal|'"'
operator|==
name|ch
assert|;
specifier|final
name|char
name|quote
init|=
name|ch
decl_stmt|;
specifier|final
name|short
name|sLine
init|=
name|line
decl_stmt|;
specifier|final
name|short
name|sCol
init|=
name|column
decl_stmt|;
while|while
condition|(
name|getch
argument_list|()
operator|!=
name|EOT
condition|)
block|{
if|if
condition|(
name|quote
operator|==
name|ch
condition|)
return|return;
if|if
condition|(
operator|(
name|quote
operator|==
literal|'"'
operator|)
operator|&&
operator|(
literal|'\\'
operator|==
name|ch
operator|)
condition|)
name|escape
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|EOFError
argument_list|(
name|sLine
argument_list|,
name|sCol
argument_list|,
literal|"unexpected EOT looking for matching quote: "
operator|+
name|quote
argument_list|)
throw|;
block|}
specifier|private
name|void
name|skipSpace
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
while|while
condition|(
name|isBlank
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|getch
argument_list|()
expr_stmt|;
block|}
comment|// skip continuation lines, but not other escapes
if|if
condition|(
operator|(
literal|'\\'
operator|==
name|ch
operator|)
operator|&&
operator|(
name|peek
argument_list|()
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|getch
argument_list|()
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|// skip comments
if|if
condition|(
operator|(
literal|'/'
operator|==
name|ch
operator|)
operator|||
operator|(
literal|'#'
operator|==
name|ch
operator|)
condition|)
block|{
if|if
condition|(
operator|(
literal|'#'
operator|==
name|ch
operator|)
operator|||
operator|(
name|peek
argument_list|()
operator|==
literal|'/'
operator|)
condition|)
block|{
while|while
condition|(
operator|(
name|getch
argument_list|()
operator|!=
name|EOT
operator|)
operator|&&
operator|(
literal|'\n'
operator|!=
name|ch
operator|)
condition|)
block|{                     }
continue|continue;
block|}
elseif|else
if|if
condition|(
literal|'*'
operator|==
name|peek
argument_list|()
condition|)
block|{
name|short
name|sLine
init|=
name|line
decl_stmt|;
name|short
name|sCol
init|=
name|column
decl_stmt|;
name|getch
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|getch
argument_list|()
operator|!=
name|EOT
operator|)
operator|&&
operator|!
operator|(
operator|(
literal|'*'
operator|==
name|ch
operator|)
operator|&&
operator|(
name|peek
argument_list|()
operator|==
literal|'/'
operator|)
operator|)
condition|)
block|{                     }
if|if
condition|(
name|EOT
operator|==
name|ch
condition|)
block|{
throw|throw
operator|new
name|EOFError
argument_list|(
name|sLine
argument_list|,
name|sCol
argument_list|,
literal|"unexpected EOT looking for closing comment: */"
argument_list|)
throw|;
block|}
name|getch
argument_list|()
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
block|}
block|}
specifier|private
name|boolean
name|isBlank
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
literal|' '
operator|==
name|ch
operator|||
literal|'\t'
operator|==
name|ch
return|;
block|}
specifier|private
name|boolean
name|isName
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|ch
argument_list|)
operator|&&
operator|(
name|ch
operator|!=
literal|'$'
operator|)
operator|||
operator|(
literal|'.'
operator|==
name|ch
operator|)
return|;
block|}
comment|/**      * expand variables, quotes and escapes in word.      * @param vars      * @return      * @throws Exception       */
specifier|public
specifier|static
name|Object
name|expand
parameter_list|(
name|CharSequence
name|word
parameter_list|,
name|Evaluate
name|eval
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|expand
argument_list|(
name|word
argument_list|,
name|eval
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|Object
name|expand
parameter_list|(
name|CharSequence
name|word
parameter_list|,
name|Evaluate
name|eval
parameter_list|,
name|boolean
name|inQuote
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|String
name|special
init|=
literal|"$\\\"'"
decl_stmt|;
name|int
name|i
init|=
name|word
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
operator|--
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|special
operator|.
name|indexOf
argument_list|(
name|word
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{         }
comment|// shortcut if word doesn't contain any special characters
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
name|word
return|;
return|return
operator|new
name|Tokenizer
argument_list|(
name|word
argument_list|,
name|eval
argument_list|,
name|inQuote
argument_list|)
operator|.
name|expand
argument_list|()
return|;
block|}
specifier|public
name|Object
name|expand
parameter_list|(
name|CharSequence
name|word
parameter_list|,
name|short
name|line
parameter_list|,
name|short
name|column
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|expand
argument_list|(
operator|new
name|Token
argument_list|(
name|Type
operator|.
name|WORD
argument_list|,
name|word
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
argument_list|,
name|evaluate
argument_list|,
name|inQuote
argument_list|)
return|;
block|}
specifier|private
name|Token
name|word
parameter_list|(
name|CharSequence
name|value
parameter_list|)
block|{
return|return
operator|new
name|Token
argument_list|(
name|Type
operator|.
name|WORD
argument_list|,
name|value
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
return|;
block|}
specifier|private
name|Object
name|expand
parameter_list|()
throws|throws
name|Exception
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
name|ch
operator|!=
name|EOT
condition|)
block|{
name|int
name|start
init|=
name|index
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'$'
case|:
name|Object
name|val
init|=
name|expandVar
argument_list|()
decl_stmt|;
if|if
condition|(
name|EOT
operator|==
name|ch
operator|&&
name|buf
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|val
return|;
block|}
if|if
condition|(
literal|null
operator|!=
name|val
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|// expandVar() has already read next char
case|case
literal|'\\'
case|:
name|ch
operator|=
operator|(
name|inQuote
operator|&&
operator|(
literal|"u$\\\n\""
operator|.
name|indexOf
argument_list|(
name|peek
argument_list|()
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|)
condition|?
literal|'\\'
else|:
name|escape
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'\0'
condition|)
comment|// ignore line continuation
block|{
name|buf
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'"'
case|:
name|Token
name|ww
init|=
name|word
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|skipQuote
argument_list|()
expr_stmt|;
name|ww
operator|.
name|value
operator|=
name|text
operator|.
name|subSequence
argument_list|(
name|start
argument_list|,
name|index
operator|-
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|ww
expr_stmt|;
name|Object
name|expand
init|=
name|expand
argument_list|(
name|value
argument_list|,
name|evaluate
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|eot
argument_list|()
operator|&&
name|buf
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|&&
name|value
operator|==
name|expand
condition|)
block|{
comment|// FELIX-2468 avoid returning CharSequence implementation
return|return
name|ww
operator|.
name|value
operator|.
name|toString
argument_list|()
return|;
block|}
if|if
condition|(
literal|null
operator|!=
name|expand
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|expand
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
if|if
condition|(
operator|!
name|inQuote
condition|)
block|{
name|skipQuote
argument_list|()
expr_stmt|;
name|value
operator|=
name|text
operator|.
name|subSequence
argument_list|(
name|start
argument_list|,
name|index
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|eot
argument_list|()
operator|&&
name|buf
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|value
return|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// else fall through
default|default:
name|buf
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|getch
argument_list|()
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|Object
name|expandVar
parameter_list|()
throws|throws
name|Exception
block|{
assert|assert
literal|'$'
operator|==
name|ch
assert|;
name|Object
name|val
decl_stmt|;
if|if
condition|(
name|getch
argument_list|()
operator|!=
literal|'{'
condition|)
block|{
if|if
condition|(
literal|'('
operator|==
name|ch
condition|)
block|{
name|short
name|sLine
init|=
name|line
decl_stmt|;
name|short
name|sCol
init|=
name|column
decl_stmt|;
if|if
condition|(
literal|'('
operator|==
name|peek
argument_list|()
condition|)
block|{
name|val
operator|=
name|evaluate
operator|.
name|eval
argument_list|(
operator|new
name|Token
argument_list|(
name|Type
operator|.
name|EXPR
argument_list|,
name|group
argument_list|()
argument_list|,
name|sLine
argument_list|,
name|sCol
argument_list|)
argument_list|)
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// support $(...) FELIX-2433
name|val
operator|=
name|evaluate
operator|.
name|eval
argument_list|(
operator|new
name|Token
argument_list|(
name|Type
operator|.
name|EXECUTION
argument_list|,
name|group
argument_list|()
argument_list|,
name|sLine
argument_list|,
name|sCol
argument_list|)
argument_list|)
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|start
init|=
name|index
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|isName
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|getch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|-
literal|1
operator|==
name|start
condition|)
block|{
name|val
operator|=
literal|"$"
expr_stmt|;
block|}
else|else
block|{
name|String
name|name
init|=
name|text
operator|.
name|subSequence
argument_list|(
name|start
argument_list|,
name|index
operator|-
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|val
operator|=
name|evaluate
operator|.
name|get
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// ${NAME[[:]-+=?]WORD}
name|short
name|sLine
init|=
name|line
decl_stmt|;
name|short
name|sCol
init|=
name|column
decl_stmt|;
name|CharSequence
name|group
init|=
name|group
argument_list|()
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|group
operator|.
name|length
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|group
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
literal|':'
case|:
case|case
literal|'-'
case|:
case|case
literal|'+'
case|:
case|case
literal|'='
case|:
case|case
literal|'?'
case|:
break|break;
default|default:
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|sCol
operator|+=
name|i
expr_stmt|;
name|String
name|name
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|expand
argument_list|(
name|group
operator|.
name|subSequence
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|sLine
argument_list|,
name|sCol
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|name
operator|.
name|length
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
name|isName
argument_list|(
name|name
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SyntaxError
argument_list|(
name|sLine
argument_list|,
name|sCol
argument_list|,
literal|"bad name: ${"
operator|+
name|group
operator|+
literal|"}"
argument_list|)
throw|;
block|}
block|}
name|val
operator|=
name|evaluate
operator|.
name|get
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|group
operator|.
name|length
argument_list|()
condition|)
block|{
name|c
operator|=
name|group
operator|.
name|charAt
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
literal|':'
operator|==
name|c
condition|)
block|{
name|c
operator|=
operator|(
name|i
operator|<
name|group
operator|.
name|length
argument_list|()
condition|?
name|group
operator|.
name|charAt
argument_list|(
name|i
operator|++
argument_list|)
else|:
name|EOT
operator|)
expr_stmt|;
block|}
name|CharSequence
name|word
init|=
name|group
operator|.
name|subSequence
argument_list|(
name|i
argument_list|,
name|group
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'-'
case|:
case|case
literal|'='
case|:
if|if
condition|(
literal|null
operator|==
name|val
condition|)
block|{
name|val
operator|=
name|expand
argument_list|(
name|word
argument_list|,
name|evaluate
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'='
operator|==
name|c
condition|)
block|{
name|evaluate
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
literal|null
operator|!=
name|val
condition|)
block|{
name|val
operator|=
name|expand
argument_list|(
name|word
argument_list|,
name|evaluate
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'?'
case|:
if|if
condition|(
literal|null
operator|==
name|val
condition|)
block|{
name|val
operator|=
name|expand
argument_list|(
name|word
argument_list|,
name|evaluate
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|val
operator|||
name|val
operator|.
name|toString
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|val
operator|=
literal|"parameter not set"
expr_stmt|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|name
operator|+
literal|": "
operator|+
name|val
argument_list|)
throw|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|SyntaxError
argument_list|(
name|sLine
argument_list|,
name|sCol
argument_list|,
literal|"bad substitution: ${"
operator|+
name|group
operator|+
literal|"}"
argument_list|)
throw|;
block|}
block|}
name|getch
argument_list|()
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
comment|/**      * returns true if getch() will return EOT      * @return      */
specifier|private
name|boolean
name|eot
parameter_list|()
block|{
return|return
name|index
operator|>=
name|text
operator|.
name|length
argument_list|()
return|;
block|}
specifier|private
name|char
name|getch
parameter_list|()
block|{
return|return
name|ch
operator|=
name|getch
argument_list|(
literal|false
argument_list|)
return|;
block|}
specifier|private
name|char
name|peek
parameter_list|()
block|{
return|return
name|getch
argument_list|(
literal|true
argument_list|)
return|;
block|}
specifier|private
name|char
name|getch
parameter_list|(
name|boolean
name|peek
parameter_list|)
block|{
if|if
condition|(
name|eot
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|peek
condition|)
block|{
operator|++
name|index
expr_stmt|;
name|ch
operator|=
name|EOT
expr_stmt|;
block|}
return|return
name|EOT
return|;
block|}
name|int
name|current
init|=
name|index
decl_stmt|;
name|char
name|c
init|=
name|text
operator|.
name|charAt
argument_list|(
name|index
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
literal|'\r'
operator|==
name|c
operator|)
operator|&&
operator|!
name|eot
argument_list|()
operator|&&
operator|(
name|text
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
operator|==
literal|'\n'
operator|)
condition|)
name|c
operator|=
name|text
operator|.
name|charAt
argument_list|(
name|index
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
condition|)
block|{
name|index
operator|=
name|current
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|'\n'
operator|==
name|c
condition|)
block|{
operator|++
name|line
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|++
name|column
expr_stmt|;
return|return
name|c
return|;
block|}
block|}
end_class

end_unit

