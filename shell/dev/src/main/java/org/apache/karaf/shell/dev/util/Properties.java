begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|karaf
operator|.
name|shell
operator|.
name|dev
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_class
specifier|public
class|class
name|Properties
extends|extends
name|AbstractMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
block|{
comment|/** Constant for the supported comment characters.*/
specifier|private
specifier|static
specifier|final
name|String
name|COMMENT_CHARS
init|=
literal|"#!"
decl_stmt|;
comment|/** The list of possible key/value separators */
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|SEPARATORS
init|=
operator|new
name|char
index|[]
block|{
literal|'='
block|,
literal|':'
block|}
decl_stmt|;
comment|/** The white space characters used as key/value separators. */
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|WHITE_SPACE
init|=
operator|new
name|char
index|[]
block|{
literal|' '
block|,
literal|'\t'
block|,
literal|'\f'
block|}
decl_stmt|;
comment|/**      * The default encoding (ISO-8859-1 as specified by      * http://java.sun.com/j2se/1.5.0/docs/api/java/util/Properties.html)      */
specifier|private
specifier|static
specifier|final
name|String
name|DEFAULT_ENCODING
init|=
literal|"ISO-8859-1"
decl_stmt|;
comment|/** Constant for the platform specific line separator.*/
specifier|private
specifier|static
specifier|final
name|String
name|LINE_SEPARATOR
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
comment|/** Constant for the radix of hex numbers.*/
specifier|private
specifier|static
specifier|final
name|int
name|HEX_RADIX
init|=
literal|16
decl_stmt|;
comment|/** Constant for the length of a unicode literal.*/
specifier|private
specifier|static
specifier|final
name|int
name|UNICODE_LEN
init|=
literal|4
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|storage
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Layout
argument_list|>
name|layout
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Layout
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|header
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|footer
decl_stmt|;
specifier|private
name|File
name|location
decl_stmt|;
specifier|public
name|Properties
parameter_list|()
block|{     }
specifier|public
name|Properties
parameter_list|(
name|File
name|location
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|location
operator|=
name|location
expr_stmt|;
if|if
condition|(
name|location
operator|.
name|exists
argument_list|()
condition|)
name|load
argument_list|(
name|location
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|load
parameter_list|(
name|File
name|location
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStream
name|is
init|=
operator|new
name|FileInputStream
argument_list|(
name|location
argument_list|)
decl_stmt|;
try|try
block|{
name|load
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|load
parameter_list|(
name|URL
name|location
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStream
name|is
init|=
name|location
operator|.
name|openStream
argument_list|()
decl_stmt|;
try|try
block|{
name|load
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|load
parameter_list|(
name|InputStream
name|is
parameter_list|)
throws|throws
name|IOException
block|{
name|load
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|is
argument_list|,
name|DEFAULT_ENCODING
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|load
parameter_list|(
name|Reader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
name|loadLayout
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|save
parameter_list|()
throws|throws
name|IOException
block|{
name|save
argument_list|(
name|this
operator|.
name|location
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|save
parameter_list|(
name|File
name|location
parameter_list|)
throws|throws
name|IOException
block|{
name|OutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|location
argument_list|)
decl_stmt|;
try|try
block|{
name|save
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|save
parameter_list|(
name|OutputStream
name|os
parameter_list|)
throws|throws
name|IOException
block|{
name|save
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|os
argument_list|,
name|DEFAULT_ENCODING
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|save
parameter_list|(
name|Writer
name|writer
parameter_list|)
throws|throws
name|IOException
block|{
name|saveLayout
argument_list|(
name|writer
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
name|storage
operator|.
name|entrySet
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|put
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|String
name|old
init|=
name|storage
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|==
literal|null
operator|||
operator|!
name|old
operator|.
name|equals
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|Layout
name|l
init|=
name|layout
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|!=
literal|null
condition|)
block|{
name|l
operator|.
name|clearValue
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|old
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|Layout
name|l
init|=
name|layout
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|!=
literal|null
condition|)
block|{
name|l
operator|.
name|clearValue
argument_list|()
expr_stmt|;
block|}
return|return
name|storage
operator|.
name|remove
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|Layout
name|l
range|:
name|layout
operator|.
name|values
argument_list|()
control|)
block|{
name|l
operator|.
name|clearValue
argument_list|()
expr_stmt|;
block|}
name|storage
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**      * Return the comment header.      *      * @return the comment header      */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getHeader
parameter_list|()
block|{
return|return
name|header
return|;
block|}
comment|/**      * Set the comment header.      *      * @param header the header to use      */
specifier|public
name|void
name|setHeader
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|header
parameter_list|)
block|{
name|this
operator|.
name|header
operator|=
name|header
expr_stmt|;
block|}
comment|/**      * Return the comment footer.      *      * @return the comment footer      */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getFooter
parameter_list|()
block|{
return|return
name|footer
return|;
block|}
comment|/**      * Set the comment footer.      *      * @param footer the footer to use      */
specifier|public
name|void
name|setFooter
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|footer
parameter_list|)
block|{
name|this
operator|.
name|footer
operator|=
name|footer
expr_stmt|;
block|}
comment|/**      * Reads a properties file and stores its internal structure. The found      * properties will be added to the associated configuration object.      *      * @param in the reader to the properties file      * @throws java.io.IOException if an error occurs      */
specifier|protected
name|void
name|loadLayout
parameter_list|(
name|Reader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|PropertiesReader
name|reader
init|=
operator|new
name|PropertiesReader
argument_list|(
name|in
argument_list|)
decl_stmt|;
while|while
condition|(
name|reader
operator|.
name|nextProperty
argument_list|()
condition|)
block|{
name|storage
operator|.
name|put
argument_list|(
name|reader
operator|.
name|getPropertyName
argument_list|()
argument_list|,
name|reader
operator|.
name|getPropertyValue
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|idx
init|=
name|checkHeaderComment
argument_list|(
name|reader
operator|.
name|getCommentLines
argument_list|()
argument_list|)
decl_stmt|;
name|layout
operator|.
name|put
argument_list|(
name|reader
operator|.
name|getPropertyName
argument_list|()
argument_list|,
operator|new
name|Layout
argument_list|(
name|idx
operator|<
name|reader
operator|.
name|getCommentLines
argument_list|()
operator|.
name|size
argument_list|()
condition|?
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|reader
operator|.
name|getCommentLines
argument_list|()
operator|.
name|subList
argument_list|(
name|idx
argument_list|,
name|reader
operator|.
name|getCommentLines
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
else|:
literal|null
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|reader
operator|.
name|getValueLines
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|footer
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|reader
operator|.
name|getCommentLines
argument_list|()
argument_list|)
expr_stmt|;
name|performSubstitution
argument_list|(
name|storage
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes the properties file to the given writer, preserving as much of its      * structure as possible.      *      * @param out the writer      * @throws java.io.IOException if an error occurs      */
specifier|protected
name|void
name|saveLayout
parameter_list|(
name|Writer
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|PropertiesWriter
name|writer
init|=
operator|new
name|PropertiesWriter
argument_list|(
name|out
argument_list|)
decl_stmt|;
if|if
condition|(
name|header
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|s
range|:
name|header
control|)
block|{
name|writer
operator|.
name|writeln
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|String
name|key
range|:
name|storage
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Layout
name|l
init|=
name|layout
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|!=
literal|null
operator|&&
name|l
operator|.
name|getCommentLines
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|s
range|:
name|l
operator|.
name|getCommentLines
argument_list|()
control|)
block|{
name|writer
operator|.
name|writeln
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l
operator|!=
literal|null
operator|&&
name|l
operator|.
name|getValueLines
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|s
range|:
name|l
operator|.
name|getValueLines
argument_list|()
control|)
block|{
name|writer
operator|.
name|writeln
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|writer
operator|.
name|writeProperty
argument_list|(
name|key
argument_list|,
name|storage
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|footer
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|s
range|:
name|footer
control|)
block|{
name|writer
operator|.
name|writeln
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|writer
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**      * Checks if parts of the passed in comment can be used as header comment.      * This method checks whether a header comment can be defined (i.e. whether      * this is the first comment in the loaded file). If this is the case, it is      * searched for the lates blank line. This line will mark the end of the      * header comment. The return value is the index of the first line in the      * passed in list, which does not belong to the header comment.      *      * @param commentLines the comment lines      * @return the index of the next line after the header comment      */
specifier|private
name|int
name|checkHeaderComment
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|commentLines
parameter_list|)
block|{
if|if
condition|(
name|getHeader
argument_list|()
operator|==
literal|null
operator|&&
name|layout
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// This is the first comment. Search for blank lines.
name|int
name|index
init|=
name|commentLines
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|index
operator|>=
literal|0
operator|&&
name|commentLines
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|index
operator|--
expr_stmt|;
block|}
name|setHeader
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|commentLines
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|index
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|index
operator|+
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/**      * Tests whether a line is a comment, i.e. whether it starts with a comment      * character.      *      * @param line the line      * @return a flag if this is a comment line      */
specifier|static
name|boolean
name|isCommentLine
parameter_list|(
name|String
name|line
parameter_list|)
block|{
name|String
name|s
init|=
name|line
operator|.
name|trim
argument_list|()
decl_stmt|;
comment|// blank lines are also treated as comment lines
return|return
name|s
operator|.
name|length
argument_list|()
operator|<
literal|1
operator|||
name|COMMENT_CHARS
operator|.
name|indexOf
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|>=
literal|0
return|;
block|}
comment|/**      *<p>Unescapes any Java literals found in the<code>String</code> to a      *<code>Writer</code>.</p> This is a slightly modified version of the      * StringEscapeUtils.unescapeJava() function in commons-lang that doesn't      * drop escaped separators (i.e '\,').      *      * @param str  the<code>String</code> to unescape, may be null      * @return the processed string      * @throws IllegalArgumentException if the Writer is<code>null</code>      */
specifier|protected
specifier|static
name|String
name|unescapeJava
parameter_list|(
name|String
name|str
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|sz
init|=
name|str
operator|.
name|length
argument_list|()
decl_stmt|;
name|StringBuffer
name|out
init|=
operator|new
name|StringBuffer
argument_list|(
name|sz
argument_list|)
decl_stmt|;
name|StringBuffer
name|unicode
init|=
operator|new
name|StringBuffer
argument_list|(
name|UNICODE_LEN
argument_list|)
decl_stmt|;
name|boolean
name|hadSlash
init|=
literal|false
decl_stmt|;
name|boolean
name|inUnicode
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ch
init|=
name|str
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|inUnicode
condition|)
block|{
comment|// if in unicode, then we're reading unicode
comment|// values in somehow
name|unicode
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|unicode
operator|.
name|length
argument_list|()
operator|==
name|UNICODE_LEN
condition|)
block|{
comment|// unicode now contains the four hex digits
comment|// which represents our unicode character
try|try
block|{
name|int
name|value
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|unicode
operator|.
name|toString
argument_list|()
argument_list|,
name|HEX_RADIX
argument_list|)
decl_stmt|;
name|out
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|value
argument_list|)
expr_stmt|;
name|unicode
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|inUnicode
operator|=
literal|false
expr_stmt|;
name|hadSlash
operator|=
literal|false
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to parse unicode value: "
operator|+
name|unicode
argument_list|,
name|nfe
argument_list|)
throw|;
block|}
block|}
continue|continue;
block|}
if|if
condition|(
name|hadSlash
condition|)
block|{
comment|// handle an escaped value
name|hadSlash
operator|=
literal|false
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\\'
case|:
name|out
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|out
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
name|out
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|out
operator|.
name|append
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|out
operator|.
name|append
argument_list|(
literal|'\f'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|out
operator|.
name|append
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|out
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|out
operator|.
name|append
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|// uh-oh, we're in unicode country....
name|inUnicode
operator|=
literal|true
expr_stmt|;
break|break;
default|default :
name|out
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|hadSlash
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
name|out
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hadSlash
condition|)
block|{
comment|// then we're in the weird case of a \ at the end of the
comment|// string, let's output it anyway.
name|out
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
return|return
name|out
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      *<p>Escapes the characters in a<code>String</code> using Java String rules.</p>      *      *<p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.)</p>      *      *<p>So a tab becomes the characters<code>'\\'</code> and      *<code>'t'</code>.</p>      *      *<p>The only difference between Java strings and JavaScript strings      * is that in JavaScript, a single quote must be escaped.</p>      *      *<p>Example:      *<pre>      * input string: He didn't say, "Stop!"      * output string: He didn't say, \"Stop!\"      *</pre>      *</p>      *      * @param str  String to escape values in, may be null      * @return String with escaped values,<code>null</code> if null string input      */
specifier|protected
specifier|static
name|String
name|escapeJava
parameter_list|(
name|String
name|str
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|sz
init|=
name|str
operator|.
name|length
argument_list|()
decl_stmt|;
name|StringBuffer
name|out
init|=
operator|new
name|StringBuffer
argument_list|(
name|sz
operator|*
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ch
init|=
name|str
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// handle unicode
if|if
condition|(
name|ch
operator|>
literal|0xfff
condition|)
block|{
name|out
operator|.
name|append
argument_list|(
literal|"\\u"
argument_list|)
operator|.
name|append
argument_list|(
name|hex
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|>
literal|0xff
condition|)
block|{
name|out
operator|.
name|append
argument_list|(
literal|"\\u0"
argument_list|)
operator|.
name|append
argument_list|(
name|hex
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|>
literal|0x7f
condition|)
block|{
name|out
operator|.
name|append
argument_list|(
literal|"\\u00"
argument_list|)
operator|.
name|append
argument_list|(
name|hex
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
literal|32
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\b'
case|:
name|out
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|out
operator|.
name|append
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|out
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|out
operator|.
name|append
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|out
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|out
operator|.
name|append
argument_list|(
literal|'t'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|out
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|out
operator|.
name|append
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|out
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|out
operator|.
name|append
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
break|break;
default|default :
if|if
condition|(
name|ch
operator|>
literal|0xf
condition|)
block|{
name|out
operator|.
name|append
argument_list|(
literal|"\\u00"
argument_list|)
operator|.
name|append
argument_list|(
name|hex
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|append
argument_list|(
literal|"\\u000"
argument_list|)
operator|.
name|append
argument_list|(
name|hex
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'"'
case|:
name|out
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|out
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|out
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|out
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
break|break;
default|default :
name|out
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|out
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      *<p>Returns an upper case hexadecimal<code>String</code> for the given      * character.</p>      *      * @param ch The character to convert.      * @return An upper case hexadecimal<code>String</code>      */
specifier|protected
specifier|static
name|String
name|hex
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
name|Integer
operator|.
name|toHexString
argument_list|(
name|ch
argument_list|)
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
return|;
block|}
comment|/**      *<p>Checks if the value is in the given array.</p>      *      *<p>The method returns<code>false</code> if a<code>null</code> array is passed in.</p>      *      * @param array  the array to search through      * @param valueToFind  the value to find      * @return<code>true</code> if the array contains the object      */
specifier|public
specifier|static
name|boolean
name|contains
parameter_list|(
name|char
index|[]
name|array
parameter_list|,
name|char
name|valueToFind
parameter_list|)
block|{
if|if
condition|(
name|array
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|array
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|valueToFind
operator|==
name|array
index|[
name|i
index|]
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
specifier|static
specifier|final
name|char
name|ESCAPE_CHAR
init|=
literal|'\\'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|DELIM_START
init|=
literal|"${"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|DELIM_STOP
init|=
literal|"}"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|CHECKSUM_SUFFIX
init|=
literal|".checksum"
decl_stmt|;
comment|/**      * Perform substitution on a property set      *      * @param properties the property set to perform substitution on      */
specifier|public
specifier|static
name|void
name|performSubstitution
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|properties
parameter_list|)
block|{
for|for
control|(
name|String
name|name
range|:
name|properties
operator|.
name|keySet
argument_list|()
control|)
block|{
name|String
name|value
init|=
name|properties
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|properties
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|substVars
argument_list|(
name|value
argument_list|,
name|name
argument_list|,
literal|null
argument_list|,
name|properties
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      *<p>      * This method performs property variable substitution on the      * specified value. If the specified value contains the syntax      *<tt>${&lt;prop-name&gt;}</tt>, where<tt>&lt;prop-name&gt;</tt>      * refers to either a configuration property or a system property,      * then the corresponding property value is substituted for the variable      * placeholder. Multiple variable placeholders may exist in the      * specified value as well as nested variable placeholders, which      * are substituted from inner most to outer most. Configuration      * properties override system properties.      *</p>      * @param val The string on which to perform property substitution.      * @param currentKey The key of the property being evaluated used to      *        detect cycles.      * @param cycleMap Map of variable references used to detect nested cycles.      * @param configProps Set of configuration properties.      * @return The value of the specified string after system property substitution.      * @throws IllegalArgumentException If there was a syntax error in the      *         property placeholder syntax or a recursive variable reference.      **/
specifier|public
specifier|static
name|String
name|substVars
parameter_list|(
name|String
name|val
parameter_list|,
name|String
name|currentKey
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|cycleMap
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|configProps
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|cycleMap
operator|==
literal|null
condition|)
block|{
name|cycleMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|// Put the current key in the cycle map.
name|cycleMap
operator|.
name|put
argument_list|(
name|currentKey
argument_list|,
name|currentKey
argument_list|)
expr_stmt|;
comment|// Assume we have a value that is something like:
comment|// "leading ${foo.${bar}} middle ${baz} trailing"
comment|// Find the first ending '}' variable delimiter, which
comment|// will correspond to the first deepest nested variable
comment|// placeholder.
name|int
name|stopDelim
init|=
name|val
operator|.
name|indexOf
argument_list|(
name|DELIM_STOP
argument_list|)
decl_stmt|;
while|while
condition|(
name|stopDelim
operator|>
literal|0
operator|&&
name|val
operator|.
name|charAt
argument_list|(
name|stopDelim
operator|-
literal|1
argument_list|)
operator|==
name|ESCAPE_CHAR
condition|)
block|{
name|stopDelim
operator|=
name|val
operator|.
name|indexOf
argument_list|(
name|DELIM_STOP
argument_list|,
name|stopDelim
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Find the matching starting "${" variable delimiter
comment|// by looping until we find a start delimiter that is
comment|// greater than the stop delimiter we have found.
name|int
name|startDelim
init|=
name|val
operator|.
name|indexOf
argument_list|(
name|DELIM_START
argument_list|)
decl_stmt|;
while|while
condition|(
name|stopDelim
operator|>=
literal|0
condition|)
block|{
name|int
name|idx
init|=
name|val
operator|.
name|indexOf
argument_list|(
name|DELIM_START
argument_list|,
name|startDelim
operator|+
name|DELIM_START
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|idx
operator|<
literal|0
operator|)
operator|||
operator|(
name|idx
operator|>
name|stopDelim
operator|)
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|idx
operator|<
name|stopDelim
condition|)
block|{
name|startDelim
operator|=
name|idx
expr_stmt|;
block|}
block|}
comment|// If we do not have a start or stop delimiter, then just
comment|// return the existing value.
if|if
condition|(
operator|(
name|startDelim
operator|<
literal|0
operator|)
operator|||
operator|(
name|stopDelim
operator|<
literal|0
operator|)
condition|)
block|{
return|return
name|unescape
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|// At this point, we have found a variable placeholder so
comment|// we must perform a variable substitution on it.
comment|// Using the start and stop delimiter indices, extract
comment|// the first, deepest nested variable placeholder.
name|String
name|variable
init|=
name|val
operator|.
name|substring
argument_list|(
name|startDelim
operator|+
name|DELIM_START
operator|.
name|length
argument_list|()
argument_list|,
name|stopDelim
argument_list|)
decl_stmt|;
comment|// Verify that this is not a recursive variable reference.
if|if
condition|(
name|cycleMap
operator|.
name|get
argument_list|(
name|variable
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"recursive variable reference: "
operator|+
name|variable
argument_list|)
throw|;
block|}
comment|// Get the value of the deepest nested variable placeholder.
comment|// Try to configuration properties first.
name|String
name|substValue
init|=
call|(
name|String
call|)
argument_list|(
operator|(
name|configProps
operator|!=
literal|null
operator|)
condition|?
name|configProps
operator|.
name|get
argument_list|(
name|variable
argument_list|)
else|:
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|substValue
operator|==
literal|null
condition|)
block|{
comment|// Ignore unknown property values.
name|substValue
operator|=
name|variable
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|?
name|System
operator|.
name|getProperty
argument_list|(
name|variable
argument_list|,
literal|""
argument_list|)
else|:
literal|""
expr_stmt|;
block|}
comment|// Remove the found variable from the cycle map, since
comment|// it may appear more than once in the value and we don't
comment|// want such situations to appear as a recursive reference.
name|cycleMap
operator|.
name|remove
argument_list|(
name|variable
argument_list|)
expr_stmt|;
comment|// Append the leading characters, the substituted value of
comment|// the variable, and the trailing characters to get the new
comment|// value.
name|val
operator|=
name|val
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|startDelim
argument_list|)
operator|+
name|substValue
operator|+
name|val
operator|.
name|substring
argument_list|(
name|stopDelim
operator|+
name|DELIM_STOP
operator|.
name|length
argument_list|()
argument_list|,
name|val
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now perform substitution again, since there could still
comment|// be substitutions to make.
name|val
operator|=
name|substVars
argument_list|(
name|val
argument_list|,
name|currentKey
argument_list|,
name|cycleMap
argument_list|,
name|configProps
argument_list|)
expr_stmt|;
comment|// Remove escape characters preceding {, } and \
name|val
operator|=
name|unescape
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|// Return the value.
return|return
name|val
return|;
block|}
specifier|private
specifier|static
name|String
name|unescape
parameter_list|(
name|String
name|val
parameter_list|)
block|{
name|int
name|escape
init|=
name|val
operator|.
name|indexOf
argument_list|(
name|ESCAPE_CHAR
argument_list|)
decl_stmt|;
while|while
condition|(
name|escape
operator|>=
literal|0
operator|&&
name|escape
operator|<
name|val
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
name|char
name|c
init|=
name|val
operator|.
name|charAt
argument_list|(
name|escape
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
operator|||
name|c
operator|==
literal|'}'
operator|||
name|c
operator|==
name|ESCAPE_CHAR
condition|)
block|{
name|val
operator|=
name|val
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|escape
argument_list|)
operator|+
name|val
operator|.
name|substring
argument_list|(
name|escape
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|escape
operator|=
name|val
operator|.
name|indexOf
argument_list|(
name|ESCAPE_CHAR
argument_list|,
name|escape
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
comment|/**      * This class is used to read properties lines. These lines do      * not terminate with new-line chars but rather when there is no      * backslash sign a the end of the line.  This is used to      * concatenate multiple lines for readability.      */
specifier|public
specifier|static
class|class
name|PropertiesReader
extends|extends
name|LineNumberReader
block|{
comment|/** Stores the comment lines for the currently processed property.*/
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|commentLines
decl_stmt|;
comment|/** Stores the value lines for the currently processed property.*/
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|valueLines
decl_stmt|;
comment|/** Stores the name of the last read property.*/
specifier|private
name|String
name|propertyName
decl_stmt|;
comment|/** Stores the value of the last read property.*/
specifier|private
name|String
name|propertyValue
decl_stmt|;
comment|/**          * Creates a new instance of<code>PropertiesReader</code> and sets          * the underlaying reader and the list delimiter.          *          * @param reader the reader          */
specifier|public
name|PropertiesReader
parameter_list|(
name|Reader
name|reader
parameter_list|)
block|{
name|super
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|commentLines
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|valueLines
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|/**          * Reads a property line. Returns null if Stream is          * at EOF. Concatenates lines ending with "\".          * Skips lines beginning with "#" or "!" and empty lines.          * The return value is a property definition (<code>&lt;name&gt;</code>          * =<code>&lt;value&gt;</code>)          *          * @return A string containing a property value or null          *          * @throws java.io.IOException in case of an I/O error          */
specifier|public
name|String
name|readProperty
parameter_list|()
throws|throws
name|IOException
block|{
name|commentLines
operator|.
name|clear
argument_list|()
expr_stmt|;
name|valueLines
operator|.
name|clear
argument_list|()
expr_stmt|;
name|StringBuffer
name|buffer
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|line
init|=
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|line
operator|==
literal|null
condition|)
block|{
comment|// EOF
return|return
literal|null
return|;
block|}
if|if
condition|(
name|isCommentLine
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|commentLines
operator|.
name|add
argument_list|(
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|valueLines
operator|.
name|add
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
name|line
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|checkCombineLines
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|line
operator|=
name|line
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|line
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buffer
operator|.
name|append
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**          * Parses the next property from the input stream and stores the found          * name and value in internal fields. These fields can be obtained using          * the provided getter methods. The return value indicates whether EOF          * was reached (<b>false</b>) or whether further properties are          * available (<b>true</b>).          *          * @return a flag if further properties are available          * @throws java.io.IOException if an error occurs          */
specifier|public
name|boolean
name|nextProperty
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|line
init|=
name|readProperty
argument_list|()
decl_stmt|;
if|if
condition|(
name|line
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
comment|// EOF
block|}
comment|// parse the line
name|String
index|[]
name|property
init|=
name|parseProperty
argument_list|(
name|line
argument_list|)
decl_stmt|;
name|propertyName
operator|=
name|unescapeJava
argument_list|(
name|property
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|propertyValue
operator|=
name|unescapeJava
argument_list|(
name|property
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**          * Returns the comment lines that have been read for the last property.          *          * @return the comment lines for the last property returned by          *<code>readProperty()</code>          */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getCommentLines
parameter_list|()
block|{
return|return
name|commentLines
return|;
block|}
comment|/**          * Returns the value lines that have been read for the last property.          *          * @return the raw value lines for the last property returned by          *<code>readProperty()</code>          */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getValueLines
parameter_list|()
block|{
return|return
name|valueLines
return|;
block|}
comment|/**          * Returns the name of the last read property. This method can be called          * after<code>{@link #nextProperty()}</code> was invoked and its          * return value was<b>true</b>.          *          * @return the name of the last read property          */
specifier|public
name|String
name|getPropertyName
parameter_list|()
block|{
return|return
name|propertyName
return|;
block|}
comment|/**          * Returns the value of the last read property. This method can be          * called after<code>{@link #nextProperty()}</code> was invoked and          * its return value was<b>true</b>.          *          * @return the value of the last read property          */
specifier|public
name|String
name|getPropertyValue
parameter_list|()
block|{
return|return
name|propertyValue
return|;
block|}
comment|/**          * Checks if the passed in line should be combined with the following.          * This is true, if the line ends with an odd number of backslashes.          *          * @param line the line          * @return a flag if the lines should be combined          */
specifier|private
specifier|static
name|boolean
name|checkCombineLines
parameter_list|(
name|String
name|line
parameter_list|)
block|{
name|int
name|bsCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
name|line
operator|.
name|length
argument_list|()
operator|-
literal|1
init|;
name|idx
operator|>=
literal|0
operator|&&
name|line
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
operator|==
literal|'\\'
condition|;
name|idx
operator|--
control|)
block|{
name|bsCount
operator|++
expr_stmt|;
block|}
return|return
name|bsCount
operator|%
literal|2
operator|!=
literal|0
return|;
block|}
comment|/**          * Parse a property line and return the key and the value in an array.          *          * @param line the line to parse          * @return an array with the property's key and value          */
specifier|private
specifier|static
name|String
index|[]
name|parseProperty
parameter_list|(
name|String
name|line
parameter_list|)
block|{
comment|// sorry for this spaghetti code, please replace it as soon as
comment|// possible with a regexp when the Java 1.3 requirement is dropped
name|String
index|[]
name|result
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
name|StringBuffer
name|key
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|StringBuffer
name|value
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
comment|// state of the automaton:
comment|// 0: key parsing
comment|// 1: antislash found while parsing the key
comment|// 2: separator crossing
comment|// 3: value parsing
name|int
name|state
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|line
operator|.
name|length
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|char
name|c
init|=
name|line
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|state
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|contains
argument_list|(
name|WHITE_SPACE
argument_list|,
name|c
argument_list|)
condition|)
block|{
comment|// switch to the separator crossing state
name|state
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|contains
argument_list|(
name|SEPARATORS
argument_list|,
name|c
argument_list|)
condition|)
block|{
comment|// switch to the value parsing state
name|state
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|key
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|contains
argument_list|(
name|SEPARATORS
argument_list|,
name|c
argument_list|)
operator|||
name|contains
argument_list|(
name|WHITE_SPACE
argument_list|,
name|c
argument_list|)
condition|)
block|{
comment|// this is an escaped separator or white space
name|key
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// another escaped character, the '\' is preserved
name|key
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|key
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|// return to the key parsing state
name|state
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|contains
argument_list|(
name|WHITE_SPACE
argument_list|,
name|c
argument_list|)
condition|)
block|{
comment|// do nothing, eat all white spaces
name|state
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|contains
argument_list|(
name|SEPARATORS
argument_list|,
name|c
argument_list|)
condition|)
block|{
comment|// switch to the value parsing state
name|state
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
comment|// any other character indicates we encoutered the beginning of the value
name|value
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|// switch to the value parsing state
name|state
operator|=
literal|3
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
name|value
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|result
index|[
literal|0
index|]
operator|=
name|key
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
name|value
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|// class PropertiesReader
comment|/**      * This class is used to write properties lines.      */
specifier|public
specifier|static
class|class
name|PropertiesWriter
extends|extends
name|FilterWriter
block|{
comment|/**          * Constructor.          *          * @param writer a Writer object providing the underlying stream          */
specifier|public
name|PropertiesWriter
parameter_list|(
name|Writer
name|writer
parameter_list|)
block|{
name|super
argument_list|(
name|writer
argument_list|)
expr_stmt|;
block|}
comment|/**          * Writes the given property and its value.          *          * @param key the property key          * @param value the property value          * @throws java.io.IOException if an error occurs          */
specifier|public
name|void
name|writeProperty
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|escapeKey
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|escapeJava
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|writeln
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**          * Escape the separators in the key.          *          * @param key the key          * @return the escaped key          */
specifier|private
name|String
name|escapeKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|StringBuffer
name|newkey
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|key
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|key
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|contains
argument_list|(
name|SEPARATORS
argument_list|,
name|c
argument_list|)
operator|||
name|contains
argument_list|(
name|WHITE_SPACE
argument_list|,
name|c
argument_list|)
condition|)
block|{
comment|// escape the separator
name|newkey
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|newkey
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newkey
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|newkey
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**          * Helper method for writing a line with the platform specific line          * ending.          *          * @param s the content of the line (may be<b>null</b>)          * @throws java.io.IOException if an error occurs          */
specifier|public
name|void
name|writeln
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|write
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|write
argument_list|(
name|LINE_SEPARATOR
argument_list|)
expr_stmt|;
block|}
block|}
comment|// class PropertiesWriter
comment|/**      * TODO      */
specifier|protected
specifier|static
class|class
name|Layout
block|{
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|commentLines
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|valueLines
decl_stmt|;
specifier|public
name|Layout
parameter_list|()
block|{         }
specifier|public
name|Layout
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|commentLines
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|valueLines
parameter_list|)
block|{
name|this
operator|.
name|commentLines
operator|=
name|commentLines
expr_stmt|;
name|this
operator|.
name|valueLines
operator|=
name|valueLines
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getCommentLines
parameter_list|()
block|{
return|return
name|commentLines
return|;
block|}
specifier|public
name|void
name|setCommentLines
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|commentLines
parameter_list|)
block|{
name|this
operator|.
name|commentLines
operator|=
name|commentLines
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getValueLines
parameter_list|()
block|{
return|return
name|valueLines
return|;
block|}
specifier|public
name|void
name|setValueLines
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|valueLines
parameter_list|)
block|{
name|this
operator|.
name|valueLines
operator|=
name|valueLines
expr_stmt|;
block|}
specifier|public
name|void
name|clearValue
parameter_list|()
block|{
name|this
operator|.
name|valueLines
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// class Layout
block|}
end_class

end_unit

