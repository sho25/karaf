begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2007, Marc Prud'hommeaux. All rights reserved.  *  * This software is distributable under the BSD license. See the terms of the  * BSD license in the documentation provided with this software.  */
end_comment

begin_package
package|package
name|jline
operator|.
name|console
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|datatransfer
operator|.
name|Clipboard
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|datatransfer
operator|.
name|DataFlavor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|datatransfer
operator|.
name|Transferable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|datatransfer
operator|.
name|UnsupportedFlavorException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|event
operator|.
name|ActionListener
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileDescriptor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ResourceBundle
import|;
end_import

begin_import
import|import
name|jline
operator|.
name|Terminal
import|;
end_import

begin_import
import|import
name|jline
operator|.
name|TerminalFactory
import|;
end_import

begin_import
import|import
name|jline
operator|.
name|console
operator|.
name|completer
operator|.
name|CandidateListCompletionHandler
import|;
end_import

begin_import
import|import
name|jline
operator|.
name|console
operator|.
name|completer
operator|.
name|Completer
import|;
end_import

begin_import
import|import
name|jline
operator|.
name|console
operator|.
name|completer
operator|.
name|CompletionHandler
import|;
end_import

begin_import
import|import
name|jline
operator|.
name|console
operator|.
name|history
operator|.
name|History
import|;
end_import

begin_import
import|import
name|jline
operator|.
name|console
operator|.
name|history
operator|.
name|MemoryHistory
import|;
end_import

begin_import
import|import
name|jline
operator|.
name|internal
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|jline
operator|.
name|internal
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|fusesource
operator|.
name|jansi
operator|.
name|AnsiOutputStream
import|;
end_import

begin_comment
comment|/**  * A reader for console applications. It supports custom tab-completion,  * saveable command history, and command line editing. On some platforms,  * platform-specific commands will need to be issued before the reader will  * function properly. See {@link jline.Terminal#init} for convenience  * methods for issuing platform-specific setup commands.  *  * @author<a href="mailto:mwp1@cornell.edu">Marc Prud'hommeaux</a>  * @author<a href="mailto:jason@planet57.com">Jason Dillon</a>  */
end_comment

begin_class
specifier|public
class|class
name|ConsoleReader
block|{
specifier|public
specifier|static
specifier|final
name|String
name|JLINE_NOBELL
init|=
literal|"jline.nobell"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|char
name|BACKSPACE
init|=
literal|'\b'
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|char
name|RESET_LINE
init|=
literal|'\r'
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|char
name|KEYBOARD_BELL
init|=
literal|'\07'
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|char
name|NULL_MASK
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|TAB_WIDTH
init|=
literal|4
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|ResourceBundle
name|resources
init|=
name|ResourceBundle
operator|.
name|getBundle
argument_list|(
name|CandidateListCompletionHandler
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Terminal
name|terminal
decl_stmt|;
specifier|private
name|InputStream
name|in
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Byte
argument_list|>
name|streamBuffer
init|=
operator|new
name|ArrayList
argument_list|<
name|Byte
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Writer
name|out
decl_stmt|;
specifier|private
specifier|final
name|CursorBuffer
name|buf
init|=
operator|new
name|CursorBuffer
argument_list|()
decl_stmt|;
specifier|private
name|String
name|prompt
decl_stmt|;
specifier|private
name|boolean
name|bellEnabled
init|=
literal|true
decl_stmt|;
specifier|private
name|Character
name|mask
decl_stmt|;
specifier|private
name|Character
name|echoCharacter
decl_stmt|;
specifier|private
name|StringBuffer
name|searchTerm
init|=
literal|null
decl_stmt|;
specifier|private
name|String
name|previousSearchTerm
init|=
literal|""
decl_stmt|;
specifier|private
name|int
name|searchIndex
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|boolean
name|skipLF
init|=
literal|false
decl_stmt|;
specifier|public
name|ConsoleReader
parameter_list|(
specifier|final
name|InputStream
name|in
parameter_list|,
specifier|final
name|Writer
name|out
parameter_list|,
specifier|final
name|InputStream
name|bindings
parameter_list|,
specifier|final
name|Terminal
name|term
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|this
operator|.
name|out
operator|=
name|out
expr_stmt|;
name|this
operator|.
name|terminal
operator|=
name|term
operator|!=
literal|null
condition|?
name|term
else|:
name|TerminalFactory
operator|.
name|get
argument_list|()
expr_stmt|;
name|this
operator|.
name|keyBindings
operator|=
name|loadKeyBindings
argument_list|(
name|bindings
argument_list|)
expr_stmt|;
name|setBellEnabled
argument_list|(
operator|!
name|Configuration
operator|.
name|getBoolean
argument_list|(
name|JLINE_NOBELL
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ConsoleReader
parameter_list|(
specifier|final
name|InputStream
name|in
parameter_list|,
specifier|final
name|Writer
name|out
parameter_list|,
specifier|final
name|Terminal
name|term
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
literal|null
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ConsoleReader
parameter_list|(
specifier|final
name|InputStream
name|in
parameter_list|,
specifier|final
name|Writer
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a new reader using {@link FileDescriptor#in} for input and      * {@link System#out} for output.      *<p/>      * {@link FileDescriptor#in} is used because it has a better chance of not being buffered.      */
specifier|public
name|ConsoleReader
parameter_list|()
throws|throws
name|IOException
block|{
name|this
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|FileDescriptor
operator|.
name|in
argument_list|)
argument_list|,
operator|new
name|PrintWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|System
operator|.
name|out
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// FIXME: Only used for tests
name|void
name|setInput
parameter_list|(
specifier|final
name|InputStream
name|in
parameter_list|)
block|{
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
block|}
specifier|public
name|InputStream
name|getInput
parameter_list|()
block|{
return|return
name|in
return|;
block|}
specifier|public
name|Writer
name|getOutput
parameter_list|()
block|{
return|return
name|out
return|;
block|}
specifier|public
name|Terminal
name|getTerminal
parameter_list|()
block|{
return|return
name|terminal
return|;
block|}
specifier|public
name|CursorBuffer
name|getCursorBuffer
parameter_list|()
block|{
return|return
name|buf
return|;
block|}
specifier|public
name|void
name|setBellEnabled
parameter_list|(
specifier|final
name|boolean
name|enabled
parameter_list|)
block|{
name|this
operator|.
name|bellEnabled
operator|=
name|enabled
expr_stmt|;
block|}
specifier|public
name|boolean
name|isBellEnabled
parameter_list|()
block|{
return|return
name|bellEnabled
return|;
block|}
specifier|public
name|void
name|setPrompt
parameter_list|(
specifier|final
name|String
name|prompt
parameter_list|)
block|{
name|this
operator|.
name|prompt
operator|=
name|prompt
expr_stmt|;
block|}
specifier|public
name|String
name|getPrompt
parameter_list|()
block|{
return|return
name|prompt
return|;
block|}
comment|/**      * Set the echo character. For example, to have "*" entered when a password is typed:      *<p/>      *<pre>      * myConsoleReader.setEchoCharacter(new Character('*'));      *</pre>      *<p/>      * Setting the character to      *<p/>      *<pre>      * null      *</pre>      *<p/>      * will restore normal character echoing. Setting the character to      *<p/>      *<pre>      * new Character(0)      *</pre>      *<p/>      * will cause nothing to be echoed.      *      * @param c the character to echo to the console in place of the typed character.      */
specifier|public
name|void
name|setEchoCharacter
parameter_list|(
specifier|final
name|Character
name|c
parameter_list|)
block|{
name|this
operator|.
name|echoCharacter
operator|=
name|c
expr_stmt|;
block|}
comment|/**      * Returns the echo character.      */
specifier|public
name|Character
name|getEchoCharacter
parameter_list|()
block|{
return|return
name|echoCharacter
return|;
block|}
comment|/**      * Erase the current line.      *      * @return false if we failed (e.g., the buffer was empty)      */
specifier|final
name|boolean
name|resetLine
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|buf
operator|.
name|cursor
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|backspaceAll
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|int
name|getCursorPosition
parameter_list|()
block|{
comment|// FIXME: does not handle anything but a line with a prompt absolute position
name|String
name|prompt
init|=
name|getPrompt
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|prompt
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|stripAnsi
argument_list|(
name|lastLine
argument_list|(
name|prompt
argument_list|)
argument_list|)
operator|.
name|length
argument_list|()
operator|)
operator|+
name|buf
operator|.
name|cursor
return|;
block|}
comment|/**      * Returns the text after the last '\n'.      * prompt is returned if no '\n' characters are present.      * null is returned if prompt is null.      */
specifier|private
name|String
name|lastLine
parameter_list|(
name|String
name|str
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
literal|null
condition|)
return|return
literal|""
return|;
name|int
name|last
init|=
name|str
operator|.
name|lastIndexOf
argument_list|(
literal|"\n"
argument_list|)
decl_stmt|;
if|if
condition|(
name|last
operator|>=
literal|0
condition|)
block|{
return|return
name|str
operator|.
name|substring
argument_list|(
name|last
operator|+
literal|1
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
return|return
name|str
return|;
block|}
specifier|private
name|String
name|stripAnsi
parameter_list|(
name|String
name|str
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
literal|null
condition|)
return|return
literal|""
return|;
try|try
block|{
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|AnsiOutputStream
name|aos
init|=
operator|new
name|AnsiOutputStream
argument_list|(
name|baos
argument_list|)
decl_stmt|;
name|aos
operator|.
name|write
argument_list|(
name|str
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|aos
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|baos
operator|.
name|toString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
name|str
return|;
block|}
block|}
comment|/**      * Move the cursor position to the specified absolute index.      */
specifier|public
specifier|final
name|boolean
name|setCursorPosition
parameter_list|(
specifier|final
name|int
name|position
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|moveCursor
argument_list|(
name|position
operator|-
name|buf
operator|.
name|cursor
argument_list|)
operator|!=
literal|0
return|;
block|}
comment|/**      * Set the current buffer's content to the specified {@link String}. The      * visual console will be modified to show the current buffer.      *      * @param buffer the new contents of the buffer.      */
specifier|private
name|void
name|setBuffer
parameter_list|(
specifier|final
name|String
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
comment|// don't bother modifying it if it is unchanged
if|if
condition|(
name|buffer
operator|.
name|equals
argument_list|(
name|buf
operator|.
name|buffer
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// obtain the difference between the current buffer and the new one
name|int
name|sameIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|l1
init|=
name|buffer
operator|.
name|length
argument_list|()
init|,
name|l2
init|=
name|buf
operator|.
name|buffer
operator|.
name|length
argument_list|()
init|;
operator|(
name|i
operator|<
name|l1
operator|)
operator|&&
operator|(
name|i
operator|<
name|l2
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buffer
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
name|buf
operator|.
name|buffer
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|sameIndex
operator|++
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|int
name|diff
init|=
name|buf
operator|.
name|cursor
operator|-
name|sameIndex
decl_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
comment|// we can't backspace here so try from the end of the buffer
name|moveToEnd
argument_list|()
expr_stmt|;
name|diff
operator|=
name|buf
operator|.
name|buffer
operator|.
name|length
argument_list|()
operator|-
name|sameIndex
expr_stmt|;
block|}
name|backspace
argument_list|(
name|diff
argument_list|)
expr_stmt|;
comment|// go back for the differences
name|killLine
argument_list|()
expr_stmt|;
comment|// clear to the end of the line
name|buf
operator|.
name|buffer
operator|.
name|setLength
argument_list|(
name|sameIndex
argument_list|)
expr_stmt|;
comment|// the new length
name|putString
argument_list|(
name|buffer
operator|.
name|substring
argument_list|(
name|sameIndex
argument_list|)
argument_list|)
expr_stmt|;
comment|// append the differences
block|}
specifier|private
name|void
name|setBuffer
parameter_list|(
specifier|final
name|CharSequence
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
name|setBuffer
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Output put the prompt + the current buffer      */
specifier|public
specifier|final
name|void
name|drawLine
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|prompt
init|=
name|getPrompt
argument_list|()
decl_stmt|;
if|if
condition|(
name|prompt
operator|!=
literal|null
condition|)
block|{
name|print
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
block|}
name|print
argument_list|(
name|buf
operator|.
name|buffer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|.
name|length
argument_list|()
operator|!=
name|buf
operator|.
name|cursor
condition|)
block|{
comment|// not at end of line
name|back
argument_list|(
name|buf
operator|.
name|length
argument_list|()
operator|-
name|buf
operator|.
name|cursor
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Clear the line and redraw it.      */
specifier|public
specifier|final
name|void
name|redrawLine
parameter_list|()
throws|throws
name|IOException
block|{
name|print
argument_list|(
name|RESET_LINE
argument_list|)
expr_stmt|;
comment|//        flush();
name|drawLine
argument_list|()
expr_stmt|;
block|}
comment|/**      * Clear the buffer and add its contents to the history.      *      * @return the former contents of the buffer.      */
specifier|final
name|String
name|finishBuffer
parameter_list|()
throws|throws
name|IOException
block|{
comment|// FIXME: Package protected because used by tests
name|String
name|str
init|=
name|buf
operator|.
name|buffer
operator|.
name|toString
argument_list|()
decl_stmt|;
name|str
operator|=
name|expandEvents
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|// we only add it to the history if the buffer is not empty
comment|// and if mask is null, since having a mask typically means
comment|// the string was a password. We clear the mask after this call
if|if
condition|(
name|str
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mask
operator|==
literal|null
operator|&&
name|isHistoryEnabled
argument_list|()
condition|)
block|{
name|history
operator|.
name|add
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|history
operator|.
name|moveToEnd
argument_list|()
expr_stmt|;
name|buf
operator|.
name|buffer
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|.
name|cursor
operator|=
literal|0
expr_stmt|;
return|return
name|str
return|;
block|}
comment|/**      * Expand event designator such as !!, !#, !3, etc...      * See http://www.gnu.org/software/bash/manual/html_node/Event-Designators.html      *      * @param str      * @return      */
specifier|final
name|String
name|expandEvents
parameter_list|(
name|String
name|str
parameter_list|)
throws|throws
name|IOException
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|str
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|str
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'!'
case|:
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|str
operator|.
name|length
argument_list|()
condition|)
block|{
name|c
operator|=
name|str
operator|.
name|charAt
argument_list|(
operator|++
name|i
argument_list|)
expr_stmt|;
name|boolean
name|neg
init|=
literal|false
decl_stmt|;
name|String
name|rep
init|=
literal|null
decl_stmt|;
name|int
name|i1
decl_stmt|,
name|idx
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'!'
case|:
if|if
condition|(
name|history
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"!!: event not found"
argument_list|)
throw|;
block|}
name|rep
operator|=
name|history
operator|.
name|get
argument_list|(
name|history
operator|.
name|index
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|sb
operator|.
name|append
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|i1
operator|=
name|str
operator|.
name|indexOf
argument_list|(
literal|'?'
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
operator|<
literal|0
condition|)
block|{
name|i1
operator|=
name|str
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
name|String
name|sc
init|=
name|str
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|i1
argument_list|)
decl_stmt|;
name|i
operator|=
name|i1
expr_stmt|;
name|idx
operator|=
name|searchBackwards
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"!?"
operator|+
name|sc
operator|+
literal|": event not found"
argument_list|)
throw|;
block|}
else|else
block|{
name|rep
operator|=
name|history
operator|.
name|get
argument_list|(
name|idx
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|neg
operator|=
literal|true
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|// fall through
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|i1
operator|=
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|str
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|str
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
argument_list|<
literal|'0'
operator|||
name|c
argument_list|>
literal|'9'
condition|)
block|{
break|break;
block|}
block|}
name|idx
operator|=
literal|0
expr_stmt|;
try|try
block|{
name|idx
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|i1
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
operator|(
name|neg
condition|?
literal|"!-"
else|:
literal|"!"
operator|)
operator|+
name|str
operator|.
name|substring
argument_list|(
name|i1
argument_list|,
name|i
argument_list|)
operator|+
literal|": event not found"
argument_list|)
throw|;
block|}
if|if
condition|(
name|neg
condition|)
block|{
if|if
condition|(
name|idx
operator|<
name|history
operator|.
name|size
argument_list|()
condition|)
block|{
name|rep
operator|=
operator|(
name|history
operator|.
name|get
argument_list|(
name|history
operator|.
name|index
argument_list|()
operator|-
name|idx
argument_list|)
operator|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
operator|(
name|neg
condition|?
literal|"!-"
else|:
literal|"!"
operator|)
operator|+
name|str
operator|.
name|substring
argument_list|(
name|i1
argument_list|,
name|i
argument_list|)
operator|+
literal|": event not found"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|idx
operator|>=
name|history
operator|.
name|index
argument_list|()
operator|-
name|history
operator|.
name|size
argument_list|()
operator|&&
name|idx
operator|<
name|history
operator|.
name|index
argument_list|()
condition|)
block|{
name|rep
operator|=
operator|(
name|history
operator|.
name|get
argument_list|(
name|idx
argument_list|)
operator|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
operator|(
name|neg
condition|?
literal|"!-"
else|:
literal|"!"
operator|)
operator|+
name|str
operator|.
name|substring
argument_list|(
name|i1
argument_list|,
name|i
argument_list|)
operator|+
literal|": event not found"
argument_list|)
throw|;
block|}
block|}
break|break;
default|default:
name|String
name|ss
init|=
name|str
operator|.
name|substring
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|i
operator|=
name|str
operator|.
name|length
argument_list|()
expr_stmt|;
name|idx
operator|=
name|searchBackwards
argument_list|(
name|ss
argument_list|,
name|history
operator|.
name|index
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"!"
operator|+
name|ss
operator|+
literal|": event not found"
argument_list|)
throw|;
block|}
else|else
block|{
name|rep
operator|=
name|history
operator|.
name|get
argument_list|(
name|idx
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|rep
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|rep
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'^'
case|:
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|int
name|i1
init|=
name|str
operator|.
name|indexOf
argument_list|(
literal|'^'
argument_list|,
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|i2
init|=
name|str
operator|.
name|indexOf
argument_list|(
literal|'^'
argument_list|,
name|i1
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|i2
operator|<
literal|0
condition|)
block|{
name|i2
operator|=
name|str
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|i1
operator|>
literal|0
operator|&&
name|i2
operator|>
literal|0
condition|)
block|{
name|String
name|s1
init|=
name|str
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|i1
argument_list|)
decl_stmt|;
name|String
name|s2
init|=
name|str
operator|.
name|substring
argument_list|(
name|i1
operator|+
literal|1
argument_list|,
name|i2
argument_list|)
decl_stmt|;
name|String
name|s
init|=
name|history
operator|.
name|get
argument_list|(
name|history
operator|.
name|index
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|replace
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|i
operator|=
name|i2
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|String
name|result
init|=
name|sb
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|str
operator|.
name|equals
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|print
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|println
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/* Handle case where terminal does not move cursor to the next line      * when a character is inserted at the width of the terminal.  This also      * fixes backspace issue, where it assumes that the terminal is doing this.      */
specifier|private
specifier|final
name|void
name|newlineAtWrap
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|width
init|=
name|getTerminal
argument_list|()
operator|.
name|getWidth
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|getCursorPosition
argument_list|()
operator|%
name|width
operator|==
literal|0
operator|)
operator|&&
name|getCurrentPosition
argument_list|()
operator|>=
name|width
condition|)
name|println
argument_list|()
expr_stmt|;
block|}
comment|/**      * Write out the specified string to the buffer and the output stream.      */
specifier|public
specifier|final
name|void
name|putString
parameter_list|(
specifier|final
name|CharSequence
name|str
parameter_list|)
throws|throws
name|IOException
block|{
name|buf
operator|.
name|write
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|drawBuffer
argument_list|()
expr_stmt|;
name|newlineAtWrap
argument_list|()
expr_stmt|;
block|}
comment|/**      * Output the specified character, both to the buffer and the output stream.      */
specifier|private
name|void
name|putChar
parameter_list|(
specifier|final
name|int
name|c
parameter_list|,
specifier|final
name|boolean
name|print
parameter_list|)
throws|throws
name|IOException
block|{
name|buf
operator|.
name|write
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|print
condition|)
block|{
if|if
condition|(
name|mask
operator|==
literal|null
condition|)
block|{
comment|// no masking
name|print
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
operator|==
name|NULL_MASK
condition|)
block|{
comment|// Don't print anything
block|}
else|else
block|{
name|print
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
name|drawBuffer
argument_list|()
expr_stmt|;
name|newlineAtWrap
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Redraw the rest of the buffer from the cursor onwards. This is necessary      * for inserting text into the buffer.      *      * @param clear the number of characters to clear after the end of the buffer      */
specifier|private
name|void
name|drawBuffer
parameter_list|(
specifier|final
name|int
name|clear
parameter_list|)
throws|throws
name|IOException
block|{
comment|// debug ("drawBuffer: " + clear);
if|if
condition|(
name|buf
operator|.
name|cursor
operator|==
name|buf
operator|.
name|length
argument_list|()
operator|&&
name|clear
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|char
index|[]
name|chars
init|=
name|buf
operator|.
name|buffer
operator|.
name|substring
argument_list|(
name|buf
operator|.
name|cursor
argument_list|)
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
if|if
condition|(
name|mask
operator|!=
literal|null
condition|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|chars
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
name|print
argument_list|(
name|chars
argument_list|)
expr_stmt|;
name|clearAhead
argument_list|(
name|clear
argument_list|)
expr_stmt|;
if|if
condition|(
name|terminal
operator|.
name|isAnsiSupported
argument_list|()
condition|)
block|{
if|if
condition|(
name|chars
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|// don't ask, it works
name|back
argument_list|(
name|Math
operator|.
name|max
argument_list|(
name|chars
operator|.
name|length
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|back
argument_list|(
name|chars
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|//        flush();
block|}
comment|/**      * Redraw the rest of the buffer from the cursor onwards. This is necessary      * for inserting text into the buffer.      */
specifier|private
name|void
name|drawBuffer
parameter_list|()
throws|throws
name|IOException
block|{
name|drawBuffer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      * Clear ahead the specified number of characters without moving the cursor.      */
specifier|private
name|void
name|clearAhead
parameter_list|(
specifier|final
name|int
name|num
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|num
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|terminal
operator|.
name|isAnsiSupported
argument_list|()
condition|)
block|{
name|printAnsiSequence
argument_list|(
literal|"K"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// print blank extra characters
name|print
argument_list|(
literal|' '
argument_list|,
name|num
argument_list|)
expr_stmt|;
comment|// we need to flush here so a "clever" console doesn't just ignore the redundancy
comment|// of a space followed by a backspace.
comment|//        flush();
comment|// reset the visual cursor
name|back
argument_list|(
name|num
argument_list|)
expr_stmt|;
comment|//        flush();
block|}
comment|/**      * Move the visual cursor backwards without modifying the buffer cursor.      */
specifier|private
name|void
name|back
parameter_list|(
specifier|final
name|int
name|num
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|num
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|terminal
operator|.
name|isAnsiSupported
argument_list|()
condition|)
block|{
name|int
name|width
init|=
name|getTerminal
argument_list|()
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|int
name|cursor
init|=
name|getCursorPosition
argument_list|()
decl_stmt|;
comment|// debug("back: " + cursor + " + " + num + " on " + width);
name|int
name|currRow
init|=
operator|(
name|cursor
operator|+
name|num
operator|)
operator|/
name|width
decl_stmt|;
name|int
name|newRow
init|=
name|cursor
operator|/
name|width
decl_stmt|;
name|int
name|newCol
init|=
name|cursor
operator|%
name|width
operator|+
literal|1
decl_stmt|;
comment|// debug("    old row: " + currRow + " new row: " + newRow);
if|if
condition|(
name|newRow
operator|<
name|currRow
condition|)
block|{
name|printAnsiSequence
argument_list|(
operator|(
name|currRow
operator|-
name|newRow
operator|)
operator|+
literal|"A"
argument_list|)
expr_stmt|;
block|}
name|printAnsiSequence
argument_list|(
name|newCol
operator|+
literal|"G"
argument_list|)
expr_stmt|;
return|return;
block|}
name|print
argument_list|(
name|BACKSPACE
argument_list|,
name|num
argument_list|)
expr_stmt|;
comment|//        flush();
block|}
comment|/**      * Flush the console output stream. This is important for printout out single characters      * (like the keyboard backspace key) that we want the console to handle immediately.      */
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
specifier|private
name|int
name|backspaceAll
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|backspace
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
comment|/**      * Issue<em>num</em> backspaces.      *      * @return the number of characters backed up      */
specifier|private
name|int
name|backspace
parameter_list|(
specifier|final
name|int
name|num
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|buf
operator|.
name|cursor
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|termwidth
init|=
name|getTerminal
argument_list|()
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|int
name|lines
init|=
name|getCursorPosition
argument_list|()
operator|/
name|termwidth
decl_stmt|;
name|count
operator|=
name|moveCursor
argument_list|(
operator|-
literal|1
operator|*
name|num
argument_list|)
operator|*
operator|-
literal|1
expr_stmt|;
name|buf
operator|.
name|buffer
operator|.
name|delete
argument_list|(
name|buf
operator|.
name|cursor
argument_list|,
name|buf
operator|.
name|cursor
operator|+
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|getCursorPosition
argument_list|()
operator|/
name|termwidth
operator|!=
name|lines
condition|)
block|{
if|if
condition|(
name|terminal
operator|.
name|isAnsiSupported
argument_list|()
condition|)
block|{
comment|// debug("doing backspace redraw: " + getCursorPosition() + " on " + termwidth + ": " + lines);
name|printAnsiSequence
argument_list|(
literal|"K"
argument_list|)
expr_stmt|;
block|}
block|}
name|drawBuffer
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
comment|/**      * Issue a backspace.      *      * @return true if successful      */
specifier|public
name|boolean
name|backspace
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|backspace
argument_list|(
literal|1
argument_list|)
operator|==
literal|1
return|;
block|}
specifier|private
name|boolean
name|moveToEnd
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|moveCursor
argument_list|(
name|buf
operator|.
name|length
argument_list|()
operator|-
name|buf
operator|.
name|cursor
argument_list|)
operator|>
literal|0
return|;
block|}
comment|/**      * Delete the character at the current position and redraw the remainder of the buffer.      */
specifier|private
name|boolean
name|deleteCurrentCharacter
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|buf
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|||
name|buf
operator|.
name|cursor
operator|==
name|buf
operator|.
name|length
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|buf
operator|.
name|buffer
operator|.
name|deleteCharAt
argument_list|(
name|buf
operator|.
name|cursor
argument_list|)
expr_stmt|;
name|drawBuffer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|previousWord
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
name|isDelimiter
argument_list|(
name|buf
operator|.
name|current
argument_list|()
argument_list|)
operator|&&
operator|(
name|moveCursor
argument_list|(
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|// nothing
block|}
while|while
condition|(
operator|!
name|isDelimiter
argument_list|(
name|buf
operator|.
name|current
argument_list|()
argument_list|)
operator|&&
operator|(
name|moveCursor
argument_list|(
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|// nothing
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|nextWord
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
name|isDelimiter
argument_list|(
name|buf
operator|.
name|current
argument_list|()
argument_list|)
operator|&&
operator|(
name|moveCursor
argument_list|(
literal|1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|// nothing
block|}
while|while
condition|(
operator|!
name|isDelimiter
argument_list|(
name|buf
operator|.
name|current
argument_list|()
argument_list|)
operator|&&
operator|(
name|moveCursor
argument_list|(
literal|1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|// nothing
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|deletePreviousWord
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
name|isDelimiter
argument_list|(
name|buf
operator|.
name|current
argument_list|()
argument_list|)
operator|&&
name|backspace
argument_list|()
condition|)
block|{
comment|// nothing
block|}
while|while
condition|(
operator|!
name|isDelimiter
argument_list|(
name|buf
operator|.
name|current
argument_list|()
argument_list|)
operator|&&
name|backspace
argument_list|()
condition|)
block|{
comment|// nothing
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Move the cursor<i>where</i> characters.      *      * @param num   If less than 0, move abs(<i>where</i>) to the left, otherwise move<i>where</i> to the right.      * @return      The number of spaces we moved      */
specifier|public
name|int
name|moveCursor
parameter_list|(
specifier|final
name|int
name|num
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|where
init|=
name|num
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|.
name|cursor
operator|==
literal|0
operator|)
operator|&&
operator|(
name|where
operator|<=
literal|0
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|buf
operator|.
name|cursor
operator|==
name|buf
operator|.
name|buffer
operator|.
name|length
argument_list|()
operator|)
operator|&&
operator|(
name|where
operator|>=
literal|0
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|buf
operator|.
name|cursor
operator|+
name|where
operator|)
operator|<
literal|0
condition|)
block|{
name|where
operator|=
operator|-
name|buf
operator|.
name|cursor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|buf
operator|.
name|cursor
operator|+
name|where
operator|)
operator|>
name|buf
operator|.
name|buffer
operator|.
name|length
argument_list|()
condition|)
block|{
name|where
operator|=
name|buf
operator|.
name|buffer
operator|.
name|length
argument_list|()
operator|-
name|buf
operator|.
name|cursor
expr_stmt|;
block|}
name|moveInternal
argument_list|(
name|where
argument_list|)
expr_stmt|;
return|return
name|where
return|;
block|}
comment|/**      * Move the cursor<i>where</i> characters, without checking the current buffer.      *      * @param where the number of characters to move to the right or left.      */
specifier|private
name|void
name|moveInternal
parameter_list|(
specifier|final
name|int
name|where
parameter_list|)
throws|throws
name|IOException
block|{
comment|// debug ("move cursor " + where + " ("
comment|// + buf.cursor + " => " + (buf.cursor + where) + ")");
name|buf
operator|.
name|cursor
operator|+=
name|where
expr_stmt|;
if|if
condition|(
name|terminal
operator|.
name|isAnsiSupported
argument_list|()
condition|)
block|{
if|if
condition|(
name|where
operator|<
literal|0
condition|)
block|{
name|back
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|where
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|width
init|=
name|getTerminal
argument_list|()
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|int
name|cursor
init|=
name|getCursorPosition
argument_list|()
decl_stmt|;
name|int
name|oldLine
init|=
operator|(
name|cursor
operator|-
name|where
operator|)
operator|/
name|width
decl_stmt|;
name|int
name|newLine
init|=
name|cursor
operator|/
name|width
decl_stmt|;
if|if
condition|(
name|newLine
operator|>
name|oldLine
condition|)
block|{
name|printAnsiSequence
argument_list|(
operator|(
name|newLine
operator|-
name|oldLine
operator|)
operator|+
literal|"B"
argument_list|)
expr_stmt|;
block|}
name|printAnsiSequence
argument_list|(
literal|1
operator|+
operator|(
name|cursor
operator|%
name|width
operator|)
operator|+
literal|"G"
argument_list|)
expr_stmt|;
block|}
comment|//            flush();
return|return;
block|}
name|char
name|c
decl_stmt|;
if|if
condition|(
name|where
operator|<
literal|0
condition|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|buf
operator|.
name|cursor
init|;
name|i
operator|<
name|buf
operator|.
name|cursor
operator|-
name|where
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buf
operator|.
name|buffer
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'\t'
condition|)
block|{
name|len
operator|+=
name|TAB_WIDTH
expr_stmt|;
block|}
else|else
block|{
name|len
operator|++
expr_stmt|;
block|}
block|}
name|char
name|chars
index|[]
init|=
operator|new
name|char
index|[
name|len
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|chars
argument_list|,
name|BACKSPACE
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|chars
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|buf
operator|.
name|cursor
operator|==
literal|0
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|mask
operator|!=
literal|null
condition|)
block|{
name|c
operator|=
name|mask
expr_stmt|;
block|}
else|else
block|{
name|print
argument_list|(
name|buf
operator|.
name|buffer
operator|.
name|substring
argument_list|(
name|buf
operator|.
name|cursor
operator|-
name|where
argument_list|,
name|buf
operator|.
name|cursor
argument_list|)
operator|.
name|toCharArray
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// null character mask: don't output anything
if|if
condition|(
name|mask
operator|==
name|NULL_MASK
condition|)
block|{
return|return;
block|}
name|print
argument_list|(
name|c
argument_list|,
name|Math
operator|.
name|abs
argument_list|(
name|where
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// FIXME: replace() is not used
specifier|public
specifier|final
name|boolean
name|replace
parameter_list|(
specifier|final
name|int
name|num
parameter_list|,
specifier|final
name|String
name|replacement
parameter_list|)
block|{
name|buf
operator|.
name|buffer
operator|.
name|replace
argument_list|(
name|buf
operator|.
name|cursor
operator|-
name|num
argument_list|,
name|buf
operator|.
name|cursor
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
try|try
block|{
name|moveCursor
argument_list|(
operator|-
name|num
argument_list|)
expr_stmt|;
name|drawBuffer
argument_list|(
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|num
operator|-
name|replacement
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|moveCursor
argument_list|(
name|replacement
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|//
comment|// Key reading
comment|//
comment|/**      * Read a character from the console.      *      * @return the character, or -1 if an EOF is received.      */
specifier|public
specifier|final
name|int
name|readVirtualKey
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|streamBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|c
operator|=
name|terminal
operator|.
name|readVirtualKey
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|streamBuffer
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|Log
operator|.
name|trace
argument_list|(
literal|"Keystroke: "
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|// clear any echo characters
name|clearEcho
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
comment|/**      * Clear the echoed characters for the specified character code.      */
specifier|private
name|int
name|clearEcho
parameter_list|(
specifier|final
name|int
name|c
parameter_list|)
throws|throws
name|IOException
block|{
comment|// if the terminal is not echoing, then ignore
if|if
condition|(
operator|!
name|terminal
operator|.
name|isEchoEnabled
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// otherwise, clear
name|int
name|num
init|=
name|countEchoCharacters
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
decl_stmt|;
name|back
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|drawBuffer
argument_list|(
name|num
argument_list|)
expr_stmt|;
return|return
name|num
return|;
block|}
specifier|private
name|int
name|countEchoCharacters
parameter_list|(
specifier|final
name|char
name|c
parameter_list|)
block|{
comment|// tabs as special: we need to determine the number of spaces
comment|// to cancel based on what out current cursor position is
if|if
condition|(
name|c
operator|==
literal|9
condition|)
block|{
name|int
name|tabStop
init|=
literal|8
decl_stmt|;
comment|// will this ever be different?
name|int
name|position
init|=
name|getCursorPosition
argument_list|()
decl_stmt|;
return|return
name|tabStop
operator|-
operator|(
name|position
operator|%
name|tabStop
operator|)
return|;
block|}
return|return
name|getPrintableCharacters
argument_list|(
name|c
argument_list|)
operator|.
name|length
argument_list|()
return|;
block|}
comment|/**      * Return the number of characters that will be printed when the specified      * character is echoed to the screen      *      * Adapted from cat by Torbjorn Granlund, as repeated in stty by David MacKenzie.      */
specifier|private
name|StringBuilder
name|getPrintableCharacters
parameter_list|(
specifier|final
name|char
name|ch
parameter_list|)
block|{
name|StringBuilder
name|sbuff
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|32
condition|)
block|{
if|if
condition|(
name|ch
operator|<
literal|127
condition|)
block|{
name|sbuff
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|127
condition|)
block|{
name|sbuff
operator|.
name|append
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|sbuff
operator|.
name|append
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuff
operator|.
name|append
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
name|sbuff
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
operator|(
literal|128
operator|+
literal|32
operator|)
condition|)
block|{
if|if
condition|(
name|ch
operator|<
operator|(
literal|128
operator|+
literal|127
operator|)
condition|)
block|{
name|sbuff
operator|.
name|append
argument_list|(
call|(
name|char
call|)
argument_list|(
name|ch
operator|-
literal|128
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuff
operator|.
name|append
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|sbuff
operator|.
name|append
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sbuff
operator|.
name|append
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|sbuff
operator|.
name|append
argument_list|(
call|(
name|char
call|)
argument_list|(
name|ch
operator|-
literal|128
operator|+
literal|64
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|sbuff
operator|.
name|append
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|sbuff
operator|.
name|append
argument_list|(
call|(
name|char
call|)
argument_list|(
name|ch
operator|+
literal|64
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|sbuff
return|;
block|}
specifier|public
specifier|final
name|int
name|readCharacter
parameter_list|(
specifier|final
name|char
modifier|...
name|allowed
parameter_list|)
throws|throws
name|IOException
block|{
comment|// if we restrict to a limited set and the current character is not in the set, then try again.
name|char
name|c
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|allowed
argument_list|)
expr_stmt|;
comment|// always need to sort before binarySearch
while|while
condition|(
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|allowed
argument_list|,
name|c
operator|=
operator|(
name|char
operator|)
name|readVirtualKey
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// nothing
block|}
return|return
name|c
return|;
block|}
comment|//
comment|// Key Bindings
comment|//
specifier|public
specifier|static
specifier|final
name|String
name|JLINE_COMPLETION_THRESHOLD
init|=
literal|"jline.completion.threshold"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|JLINE_KEYBINDINGS
init|=
literal|"jline.keybindings"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|JLINEBINDINGS_PROPERTIES
init|=
literal|".jlinebindings.properties"
decl_stmt|;
comment|/**      * The map for logical operations.      */
specifier|private
specifier|final
name|short
index|[]
name|keyBindings
decl_stmt|;
specifier|private
name|short
index|[]
name|loadKeyBindings
parameter_list|(
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|input
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|Configuration
operator|.
name|getUserHome
argument_list|()
argument_list|,
name|JLINEBINDINGS_PROPERTIES
argument_list|)
decl_stmt|;
name|String
name|path
init|=
name|Configuration
operator|.
name|getString
argument_list|(
name|JLINE_KEYBINDINGS
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|!=
literal|null
condition|)
block|{
name|file
operator|=
operator|new
name|File
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|Log
operator|.
name|debug
argument_list|(
literal|"Loading user bindings from: "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|input
operator|=
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Log
operator|.
name|error
argument_list|(
literal|"Failed to load user bindings"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|input
operator|==
literal|null
condition|)
block|{
name|Log
operator|.
name|debug
argument_list|(
literal|"Using default bindings"
argument_list|)
expr_stmt|;
name|input
operator|=
name|getTerminal
argument_list|()
operator|.
name|getDefaultBindings
argument_list|()
expr_stmt|;
block|}
name|short
index|[]
name|keyBindings
init|=
operator|new
name|short
index|[
name|Character
operator|.
name|MAX_VALUE
operator|*
literal|2
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|keyBindings
argument_list|,
name|Operation
operator|.
name|UNKNOWN
operator|.
name|code
argument_list|)
expr_stmt|;
comment|// Loads the key bindings. Bindings file is in the format:
comment|//
comment|// keycode: operation name
if|if
condition|(
name|input
operator|!=
literal|null
condition|)
block|{
name|input
operator|=
operator|new
name|BufferedInputStream
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|Properties
name|p
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|p
operator|.
name|load
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
for|for
control|(
name|Object
name|key
range|:
name|p
operator|.
name|keySet
argument_list|()
control|)
block|{
name|String
name|val
init|=
operator|(
name|String
operator|)
name|key
decl_stmt|;
try|try
block|{
name|short
name|code
init|=
name|Short
operator|.
name|parseShort
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|p
operator|.
name|getProperty
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|Operation
name|op
init|=
name|Operation
operator|.
name|valueOf
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|keyBindings
index|[
name|code
index|]
operator|=
name|op
operator|.
name|code
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|Log
operator|.
name|error
argument_list|(
literal|"Failed to convert binding code: "
argument_list|,
name|val
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// hardwired arrow key bindings
comment|// keybindings[VK_UP] = PREV_HISTORY;
comment|// keybindings[VK_DOWN] = NEXT_HISTORY;
comment|// keybindings[VK_LEFT] = PREV_CHAR;
comment|// keybindings[VK_RIGHT] = NEXT_CHAR;
block|}
return|return
name|keyBindings
return|;
block|}
name|int
name|getKeyForAction
parameter_list|(
specifier|final
name|short
name|logicalAction
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyBindings
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|keyBindings
index|[
name|i
index|]
operator|==
name|logicalAction
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
name|int
name|getKeyForAction
parameter_list|(
specifier|final
name|Operation
name|op
parameter_list|)
block|{
assert|assert
name|op
operator|!=
literal|null
assert|;
return|return
name|getKeyForAction
argument_list|(
name|op
operator|.
name|code
argument_list|)
return|;
block|}
comment|/**      * Reads the console input and returns an array of the form [raw, key binding].      */
specifier|private
name|int
index|[]
name|readBinding
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|c
init|=
name|readVirtualKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// extract the appropriate key binding
name|short
name|code
init|=
name|keyBindings
index|[
name|c
index|]
decl_stmt|;
name|Log
operator|.
name|trace
argument_list|(
literal|"Translated: "
argument_list|,
name|c
argument_list|,
literal|" -> "
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
operator|new
name|int
index|[]
block|{
name|c
block|,
name|code
block|}
return|;
block|}
comment|//
comment|// Line Reading
comment|//
comment|/**      * Read the next line and return the contents of the buffer.      */
specifier|public
name|String
name|readLine
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readLine
argument_list|(
operator|(
name|String
operator|)
literal|null
argument_list|)
return|;
block|}
comment|/**      * Read the next line with the specified character mask. If null, then      * characters will be echoed. If 0, then no characters will be echoed.      */
specifier|public
name|String
name|readLine
parameter_list|(
specifier|final
name|Character
name|mask
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|readLine
argument_list|(
literal|null
argument_list|,
name|mask
argument_list|)
return|;
block|}
specifier|public
name|String
name|readLine
parameter_list|(
specifier|final
name|String
name|prompt
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|readLine
argument_list|(
name|prompt
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Read a line from the<i>in</i> {@link InputStream}, and return the line      * (without any trailing newlines).      *      * @param prompt    The prompt to issue to the console, may be null.      * @return          A line that is read from the terminal, or null if there was null input (e.g.,<i>CTRL-D</i>  *                      was pressed).      */
specifier|public
name|String
name|readLine
parameter_list|(
name|String
name|prompt
parameter_list|,
specifier|final
name|Character
name|mask
parameter_list|)
throws|throws
name|IOException
block|{
comment|// prompt may be null
comment|// mask may be null
comment|// FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.
name|this
operator|.
name|mask
operator|=
name|mask
expr_stmt|;
if|if
condition|(
name|prompt
operator|!=
literal|null
condition|)
block|{
name|setPrompt
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prompt
operator|=
name|getPrompt
argument_list|()
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
operator|!
name|terminal
operator|.
name|isSupported
argument_list|()
condition|)
block|{
name|beforeReadLine
argument_list|(
name|prompt
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prompt
operator|!=
literal|null
operator|&&
name|prompt
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|// if the terminal is unsupported, just use plain-java reading
if|if
condition|(
operator|!
name|terminal
operator|.
name|isSupported
argument_list|()
condition|)
block|{
return|return
name|readLine
argument_list|(
name|in
argument_list|)
return|;
block|}
name|String
name|originalPrompt
init|=
name|this
operator|.
name|prompt
decl_stmt|;
specifier|final
name|int
name|NORMAL
init|=
literal|1
decl_stmt|;
specifier|final
name|int
name|SEARCH
init|=
literal|2
decl_stmt|;
name|int
name|state
init|=
name|NORMAL
decl_stmt|;
name|boolean
name|success
init|=
literal|true
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
index|[]
name|next
init|=
name|readBinding
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|c
init|=
name|next
index|[
literal|0
index|]
decl_stmt|;
comment|// int code = next[1];
name|Operation
name|code
init|=
name|Operation
operator|.
name|valueOf
argument_list|(
name|next
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Search mode.
comment|//
comment|// Note that we have to do this first, because if there is a command
comment|// not linked to a search command, we leave the search mode and fall
comment|// through to the normal state.
if|if
condition|(
name|state
operator|==
name|SEARCH
condition|)
block|{
name|int
name|cursorDest
init|=
operator|-
literal|1
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|// This doesn't work right now, it seems CTRL-G is not passed
comment|// down correctly. :(
case|case
name|ABORT
case|:
name|state
operator|=
name|NORMAL
expr_stmt|;
break|break;
case|case
name|SEARCH_PREV
case|:
if|if
condition|(
name|searchTerm
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|searchTerm
operator|.
name|append
argument_list|(
name|previousSearchTerm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|searchIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|searchIndex
operator|=
name|searchBackwards
argument_list|(
name|searchTerm
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|searchIndex
operator|=
name|searchBackwards
argument_list|(
name|searchTerm
operator|.
name|toString
argument_list|()
argument_list|,
name|searchIndex
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DELETE_PREV_CHAR
case|:
if|if
condition|(
name|searchTerm
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|searchTerm
operator|.
name|deleteCharAt
argument_list|(
name|searchTerm
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|searchIndex
operator|=
name|searchBackwards
argument_list|(
name|searchTerm
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNKNOWN
case|:
name|searchTerm
operator|.
name|appendCodePoint
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|searchIndex
operator|=
name|searchBackwards
argument_list|(
name|searchTerm
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// Set buffer and cursor position to the found string.
if|if
condition|(
name|searchIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|history
operator|.
name|moveTo
argument_list|(
name|searchIndex
argument_list|)
expr_stmt|;
comment|// set cursor position to the found string
name|cursorDest
operator|=
name|history
operator|.
name|current
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|indexOf
argument_list|(
name|searchTerm
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|NORMAL
expr_stmt|;
break|break;
block|}
comment|// if we're still in search mode, print the search status
if|if
condition|(
name|state
operator|==
name|SEARCH
condition|)
block|{
if|if
condition|(
name|searchTerm
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|printSearchStatus
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|searchIndex
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|searchIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|printSearchStatus
argument_list|(
name|searchTerm
operator|.
name|toString
argument_list|()
argument_list|,
name|history
operator|.
name|get
argument_list|(
name|searchIndex
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// otherwise, restore the line
else|else
block|{
name|restoreLine
argument_list|(
name|originalPrompt
argument_list|,
name|cursorDest
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|state
operator|==
name|NORMAL
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EXIT
case|:
comment|// ctrl-d
if|if
condition|(
name|buf
operator|.
name|buffer
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|deleteCurrentCharacter
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|COMPLETE
case|:
comment|// tab
name|success
operator|=
name|complete
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOVE_TO_BEG
case|:
name|success
operator|=
name|setCursorPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|KILL_LINE
case|:
comment|// CTRL-K
name|success
operator|=
name|killLine
argument_list|()
expr_stmt|;
break|break;
case|case
name|CLEAR_SCREEN
case|:
comment|// CTRL-L
name|success
operator|=
name|clearScreen
argument_list|()
expr_stmt|;
break|break;
case|case
name|KILL_LINE_PREV
case|:
comment|// CTRL-U
name|success
operator|=
name|resetLine
argument_list|()
expr_stmt|;
break|break;
case|case
name|NEWLINE
case|:
comment|// enter
name|moveToEnd
argument_list|()
expr_stmt|;
name|println
argument_list|()
expr_stmt|;
comment|// output newline
name|flush
argument_list|()
expr_stmt|;
return|return
name|finishBuffer
argument_list|()
return|;
case|case
name|DELETE_PREV_CHAR
case|:
comment|// backspace
name|success
operator|=
name|backspace
argument_list|()
expr_stmt|;
break|break;
case|case
name|DELETE_NEXT_CHAR
case|:
comment|// delete
name|success
operator|=
name|deleteCurrentCharacter
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOVE_TO_END
case|:
name|success
operator|=
name|moveToEnd
argument_list|()
expr_stmt|;
break|break;
case|case
name|PREV_CHAR
case|:
name|success
operator|=
name|moveCursor
argument_list|(
operator|-
literal|1
argument_list|)
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|NEXT_CHAR
case|:
name|success
operator|=
name|moveCursor
argument_list|(
literal|1
argument_list|)
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|NEXT_HISTORY
case|:
name|success
operator|=
name|moveHistory
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|PREV_HISTORY
case|:
name|success
operator|=
name|moveHistory
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABORT
case|:
case|case
name|REDISPLAY
case|:
break|break;
case|case
name|PASTE
case|:
name|success
operator|=
name|paste
argument_list|()
expr_stmt|;
break|break;
case|case
name|DELETE_PREV_WORD
case|:
name|success
operator|=
name|deletePreviousWord
argument_list|()
expr_stmt|;
break|break;
case|case
name|PREV_WORD
case|:
name|success
operator|=
name|previousWord
argument_list|()
expr_stmt|;
break|break;
case|case
name|NEXT_WORD
case|:
name|success
operator|=
name|nextWord
argument_list|()
expr_stmt|;
break|break;
case|case
name|START_OF_HISTORY
case|:
name|success
operator|=
name|history
operator|.
name|moveToFirst
argument_list|()
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|setBuffer
argument_list|(
name|history
operator|.
name|current
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|END_OF_HISTORY
case|:
name|success
operator|=
name|history
operator|.
name|moveToLast
argument_list|()
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|setBuffer
argument_list|(
name|history
operator|.
name|current
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLEAR_LINE
case|:
name|moveInternal
argument_list|(
operator|-
operator|(
name|buf
operator|.
name|buffer
operator|.
name|length
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|killLine
argument_list|()
expr_stmt|;
break|break;
case|case
name|INSERT
case|:
name|buf
operator|.
name|setOverTyping
argument_list|(
operator|!
name|buf
operator|.
name|isOverTyping
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEARCH_PREV
case|:
comment|// CTRL-R
if|if
condition|(
name|searchTerm
operator|!=
literal|null
condition|)
block|{
name|previousSearchTerm
operator|=
name|searchTerm
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|searchTerm
operator|=
operator|new
name|StringBuffer
argument_list|(
name|buf
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|state
operator|=
name|SEARCH
expr_stmt|;
if|if
condition|(
name|searchTerm
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|searchIndex
operator|=
name|searchBackwards
argument_list|(
name|searchTerm
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
name|printSearchStatus
argument_list|(
name|searchTerm
operator|.
name|toString
argument_list|()
argument_list|,
name|searchIndex
operator|>
operator|-
literal|1
condition|?
name|history
operator|.
name|get
argument_list|(
name|searchIndex
argument_list|)
operator|.
name|toString
argument_list|()
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|searchIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|printSearchStatus
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNKNOWN
case|:
default|default:
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
comment|// ignore null chars
name|ActionListener
name|action
init|=
name|triggeredActions
operator|.
name|get
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|action
operator|!=
literal|null
condition|)
block|{
name|action
operator|.
name|actionPerformed
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putChar
argument_list|(
name|c
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|terminal
operator|.
name|isSupported
argument_list|()
condition|)
block|{
name|afterReadLine
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Read a line for unsupported terminals.      */
specifier|private
name|String
name|readLine
parameter_list|(
specifier|final
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|StringBuilder
name|buff
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|skipLF
condition|)
block|{
name|skipLF
operator|=
literal|false
expr_stmt|;
name|int
name|i
init|=
name|streamBuffer
operator|.
name|isEmpty
argument_list|()
condition|?
name|in
operator|.
name|read
argument_list|()
else|:
name|streamBuffer
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
operator|||
name|i
operator|==
literal|'\r'
condition|)
block|{
return|return
name|buff
operator|.
name|toString
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|'\n'
condition|)
block|{
comment|// ignore
block|}
else|else
block|{
name|buff
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|i
init|=
name|streamBuffer
operator|.
name|isEmpty
argument_list|()
condition|?
name|in
operator|.
name|read
argument_list|()
else|:
name|streamBuffer
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
operator|||
name|i
operator|==
literal|'\n'
condition|)
block|{
return|return
name|buff
operator|.
name|toString
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|'\r'
condition|)
block|{
name|skipLF
operator|=
literal|true
expr_stmt|;
return|return
name|buff
operator|.
name|toString
argument_list|()
return|;
block|}
else|else
block|{
name|buff
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//
comment|// Completion
comment|//
specifier|private
specifier|final
name|List
argument_list|<
name|Completer
argument_list|>
name|completers
init|=
operator|new
name|LinkedList
argument_list|<
name|Completer
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|CompletionHandler
name|completionHandler
init|=
operator|new
name|CandidateListCompletionHandler
argument_list|()
decl_stmt|;
comment|/**      * Add the specified {@link jline.console.completer.Completer} to the list of handlers for tab-completion.      *      * @param completer the {@link jline.console.completer.Completer} to add      * @return true if it was successfully added      */
specifier|public
name|boolean
name|addCompleter
parameter_list|(
specifier|final
name|Completer
name|completer
parameter_list|)
block|{
return|return
name|completers
operator|.
name|add
argument_list|(
name|completer
argument_list|)
return|;
block|}
comment|/**      * Remove the specified {@link jline.console.completer.Completer} from the list of handlers for tab-completion.      *      * @param completer     The {@link Completer} to remove      * @return              True if it was successfully removed      */
specifier|public
name|boolean
name|removeCompleter
parameter_list|(
specifier|final
name|Completer
name|completer
parameter_list|)
block|{
return|return
name|completers
operator|.
name|remove
argument_list|(
name|completer
argument_list|)
return|;
block|}
comment|/**      * Returns an unmodifiable list of all the completers.      */
specifier|public
name|Collection
argument_list|<
name|Completer
argument_list|>
name|getCompleters
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|completers
argument_list|)
return|;
block|}
specifier|public
name|void
name|setCompletionHandler
parameter_list|(
specifier|final
name|CompletionHandler
name|handler
parameter_list|)
block|{
assert|assert
name|handler
operator|!=
literal|null
assert|;
name|this
operator|.
name|completionHandler
operator|=
name|handler
expr_stmt|;
block|}
specifier|public
name|CompletionHandler
name|getCompletionHandler
parameter_list|()
block|{
return|return
name|this
operator|.
name|completionHandler
return|;
block|}
comment|/**      * Use the completers to modify the buffer with the appropriate completions.      *      * @return true if successful      */
specifier|private
name|boolean
name|complete
parameter_list|()
throws|throws
name|IOException
block|{
comment|// debug ("tab for (" + buf + ")");
if|if
condition|(
name|completers
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|CharSequence
argument_list|>
name|candidates
init|=
operator|new
name|LinkedList
argument_list|<
name|CharSequence
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|bufstr
init|=
name|buf
operator|.
name|buffer
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|cursor
init|=
name|buf
operator|.
name|cursor
decl_stmt|;
name|int
name|position
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|Completer
name|comp
range|:
name|completers
control|)
block|{
if|if
condition|(
operator|(
name|position
operator|=
name|comp
operator|.
name|complete
argument_list|(
name|bufstr
argument_list|,
name|cursor
argument_list|,
name|candidates
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
break|break;
block|}
block|}
return|return
name|candidates
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|&&
name|getCompletionHandler
argument_list|()
operator|.
name|complete
argument_list|(
name|this
argument_list|,
name|candidates
argument_list|,
name|position
argument_list|)
return|;
block|}
comment|/**      * The number of tab-completion candidates above which a warning will be      * prompted before showing all the candidates.      */
specifier|private
name|int
name|autoprintThreshold
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
name|JLINE_COMPLETION_THRESHOLD
argument_list|,
literal|100
argument_list|)
decl_stmt|;
comment|// same default as bash
comment|/**      * @param threshold the number of candidates to print without issuing a warning.      */
specifier|public
name|void
name|setAutoprintThreshold
parameter_list|(
specifier|final
name|int
name|threshold
parameter_list|)
block|{
name|this
operator|.
name|autoprintThreshold
operator|=
name|threshold
expr_stmt|;
block|}
comment|/**      * @return the number of candidates to print without issuing a warning.      */
specifier|public
name|int
name|getAutoprintThreshold
parameter_list|()
block|{
return|return
name|autoprintThreshold
return|;
block|}
specifier|private
name|boolean
name|paginationEnabled
decl_stmt|;
comment|/**      * Whether to use pagination when the number of rows of candidates exceeds the height of the terminal.      */
specifier|public
name|void
name|setPaginationEnabled
parameter_list|(
specifier|final
name|boolean
name|enabled
parameter_list|)
block|{
name|this
operator|.
name|paginationEnabled
operator|=
name|enabled
expr_stmt|;
block|}
comment|/**      * Whether to use pagination when the number of rows of candidates exceeds the height of the terminal.      */
specifier|public
name|boolean
name|isPaginationEnabled
parameter_list|()
block|{
return|return
name|paginationEnabled
return|;
block|}
comment|//
comment|// History
comment|//
specifier|private
name|History
name|history
init|=
operator|new
name|MemoryHistory
argument_list|()
decl_stmt|;
specifier|public
name|void
name|setHistory
parameter_list|(
specifier|final
name|History
name|history
parameter_list|)
block|{
name|this
operator|.
name|history
operator|=
name|history
expr_stmt|;
block|}
specifier|public
name|History
name|getHistory
parameter_list|()
block|{
return|return
name|history
return|;
block|}
specifier|private
name|boolean
name|historyEnabled
init|=
literal|true
decl_stmt|;
comment|/**      * Whether or not to add new commands to the history buffer.      */
specifier|public
name|void
name|setHistoryEnabled
parameter_list|(
specifier|final
name|boolean
name|enabled
parameter_list|)
block|{
name|this
operator|.
name|historyEnabled
operator|=
name|enabled
expr_stmt|;
block|}
comment|/**      * Whether or not to add new commands to the history buffer.      */
specifier|public
name|boolean
name|isHistoryEnabled
parameter_list|()
block|{
return|return
name|historyEnabled
return|;
block|}
comment|/**      * Move up or down the history tree.      */
specifier|private
name|boolean
name|moveHistory
parameter_list|(
specifier|final
name|boolean
name|next
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|next
operator|&&
operator|!
name|history
operator|.
name|next
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|next
operator|&&
operator|!
name|history
operator|.
name|previous
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|setBuffer
argument_list|(
name|history
operator|.
name|current
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|//
comment|// Printing
comment|//
specifier|public
specifier|static
specifier|final
name|String
name|CR
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
comment|/**      * Output the specified character to the output stream without manipulating the current buffer.      */
specifier|private
name|void
name|print
parameter_list|(
specifier|final
name|int
name|c
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|char
name|chars
index|[]
init|=
operator|new
name|char
index|[
name|TAB_WIDTH
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|chars
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|chars
argument_list|)
expr_stmt|;
return|return;
block|}
name|out
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/**      * Output the specified characters to the output stream without manipulating the current buffer.      */
specifier|private
name|void
name|print
parameter_list|(
specifier|final
name|char
modifier|...
name|buff
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|char
name|c
range|:
name|buff
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|len
operator|+=
name|TAB_WIDTH
expr_stmt|;
block|}
else|else
block|{
name|len
operator|++
expr_stmt|;
block|}
block|}
name|char
name|chars
index|[]
decl_stmt|;
if|if
condition|(
name|len
operator|==
name|buff
operator|.
name|length
condition|)
block|{
name|chars
operator|=
name|buff
expr_stmt|;
block|}
else|else
block|{
name|chars
operator|=
operator|new
name|char
index|[
name|len
index|]
expr_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|char
name|c
range|:
name|buff
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|chars
argument_list|,
name|pos
argument_list|,
name|pos
operator|+
name|TAB_WIDTH
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|TAB_WIDTH
expr_stmt|;
block|}
else|else
block|{
name|chars
index|[
name|pos
index|]
operator|=
name|c
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
block|}
block|}
name|out
operator|.
name|write
argument_list|(
name|chars
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|print
parameter_list|(
specifier|final
name|char
name|c
parameter_list|,
specifier|final
name|int
name|num
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|num
operator|==
literal|1
condition|)
block|{
name|print
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
index|[]
name|chars
init|=
operator|new
name|char
index|[
name|num
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|chars
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|chars
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Output the specified string to the output stream (but not the buffer).      */
specifier|public
specifier|final
name|void
name|print
parameter_list|(
specifier|final
name|CharSequence
name|s
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|s
operator|!=
literal|null
assert|;
name|print
argument_list|(
name|s
operator|.
name|toString
argument_list|()
operator|.
name|toCharArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|final
name|void
name|println
parameter_list|(
specifier|final
name|CharSequence
name|s
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|s
operator|!=
literal|null
assert|;
name|print
argument_list|(
name|s
operator|.
name|toString
argument_list|()
operator|.
name|toCharArray
argument_list|()
argument_list|)
expr_stmt|;
name|println
argument_list|()
expr_stmt|;
block|}
comment|/**      * Output a platform-dependant newline.      */
specifier|public
specifier|final
name|void
name|println
parameter_list|()
throws|throws
name|IOException
block|{
name|print
argument_list|(
name|CR
argument_list|)
expr_stmt|;
comment|//        flush();
block|}
comment|//
comment|// Actions
comment|//
comment|/**      * Issue a delete.      *      * @return true if successful      */
specifier|public
specifier|final
name|boolean
name|delete
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|delete
argument_list|(
literal|1
argument_list|)
operator|==
literal|1
return|;
block|}
comment|// FIXME: delete(int) only used by above + the return is always 1 and num is ignored
comment|/**      * Issue<em>num</em> deletes.      *      * @return the number of characters backed up      */
specifier|private
name|int
name|delete
parameter_list|(
specifier|final
name|int
name|num
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: Try to use jansi for this
comment|/* Commented out because of DWA-2949:         if (buf.cursor == 0) {             return 0;         }         */
name|buf
operator|.
name|buffer
operator|.
name|delete
argument_list|(
name|buf
operator|.
name|cursor
argument_list|,
name|buf
operator|.
name|cursor
operator|+
literal|1
argument_list|)
expr_stmt|;
name|drawBuffer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/**      * Kill the buffer ahead of the current cursor position.      *      * @return true if successful      */
specifier|public
name|boolean
name|killLine
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|cp
init|=
name|buf
operator|.
name|cursor
decl_stmt|;
name|int
name|len
init|=
name|buf
operator|.
name|buffer
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|cp
operator|>=
name|len
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|num
init|=
name|buf
operator|.
name|buffer
operator|.
name|length
argument_list|()
operator|-
name|cp
decl_stmt|;
name|clearAhead
argument_list|(
name|num
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|buffer
operator|.
name|deleteCharAt
argument_list|(
name|len
operator|-
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Clear the screen by issuing the ANSI "clear screen" code.      */
specifier|public
name|boolean
name|clearScreen
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|terminal
operator|.
name|isAnsiSupported
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// send the ANSI code to clear the screen
name|printAnsiSequence
argument_list|(
literal|"2J"
argument_list|)
expr_stmt|;
comment|// then send the ANSI code to go to position 1,1
name|printAnsiSequence
argument_list|(
literal|"1;1H"
argument_list|)
expr_stmt|;
name|redrawLine
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Issue an audible keyboard bell, if {@link #isBellEnabled} return true.      */
specifier|public
name|void
name|beep
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isBellEnabled
argument_list|()
condition|)
block|{
name|print
argument_list|(
name|KEYBOARD_BELL
argument_list|)
expr_stmt|;
comment|// need to flush so the console actually beeps
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Paste the contents of the clipboard into the console buffer      *      * @return true if clipboard contents pasted      */
specifier|public
name|boolean
name|paste
parameter_list|()
throws|throws
name|IOException
block|{
name|Clipboard
name|clipboard
decl_stmt|;
try|try
block|{
comment|// May throw ugly exception on system without X
name|clipboard
operator|=
name|Toolkit
operator|.
name|getDefaultToolkit
argument_list|()
operator|.
name|getSystemClipboard
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|clipboard
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Transferable
name|transferable
init|=
name|clipboard
operator|.
name|getContents
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|transferable
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
name|Object
name|content
init|=
name|transferable
operator|.
name|getTransferData
argument_list|(
name|DataFlavor
operator|.
name|plainTextFlavor
argument_list|)
decl_stmt|;
comment|// This fix was suggested in bug #1060649 at
comment|// http://sourceforge.net/tracker/index.php?func=detail&aid=1060649&group_id=64033&atid=506056
comment|// to get around the deprecated DataFlavor.plainTextFlavor, but it
comment|// raises a UnsupportedFlavorException on Mac OS X
if|if
condition|(
name|content
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|content
operator|=
operator|new
name|DataFlavor
argument_list|()
operator|.
name|getReaderForText
argument_list|(
name|transferable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
if|if
condition|(
name|content
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|String
name|value
decl_stmt|;
if|if
condition|(
name|content
operator|instanceof
name|Reader
condition|)
block|{
comment|// TODO: we might want instead connect to the input stream
comment|// so we can interpret individual lines
name|value
operator|=
literal|""
expr_stmt|;
name|String
name|line
decl_stmt|;
name|BufferedReader
name|read
init|=
operator|new
name|BufferedReader
argument_list|(
operator|(
name|Reader
operator|)
name|content
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|read
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|value
operator|+=
literal|"\n"
expr_stmt|;
block|}
name|value
operator|+=
name|line
expr_stmt|;
block|}
block|}
else|else
block|{
name|value
operator|=
name|content
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
name|putString
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedFlavorException
name|e
parameter_list|)
block|{
name|Log
operator|.
name|error
argument_list|(
literal|"Paste failed: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|//
comment|// Triggered Actions
comment|//
specifier|private
specifier|final
name|Map
argument_list|<
name|Character
argument_list|,
name|ActionListener
argument_list|>
name|triggeredActions
init|=
operator|new
name|HashMap
argument_list|<
name|Character
argument_list|,
name|ActionListener
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Adding a triggered Action allows for another course of action if a character passed the pre-processing.      *<p/>      * Say you wish to close the application if the user enters q.      * addTriggerAction('q', new ActionListener(){ System.exit(0); }); would do the trick.      */
specifier|public
name|void
name|addTriggeredAction
parameter_list|(
specifier|final
name|char
name|c
parameter_list|,
specifier|final
name|ActionListener
name|listener
parameter_list|)
block|{
name|triggeredActions
operator|.
name|put
argument_list|(
name|c
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Formatted Output
comment|//
comment|/**      * Output the specified {@link Collection} in proper columns.      */
specifier|public
name|void
name|printColumns
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|?
extends|extends
name|CharSequence
argument_list|>
name|items
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|items
operator|==
literal|null
operator|||
name|items
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|int
name|width
init|=
name|getTerminal
argument_list|()
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|int
name|height
init|=
name|getTerminal
argument_list|()
operator|.
name|getHeight
argument_list|()
decl_stmt|;
name|int
name|maxWidth
init|=
literal|0
decl_stmt|;
for|for
control|(
name|CharSequence
name|item
range|:
name|items
control|)
block|{
name|maxWidth
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxWidth
argument_list|,
name|item
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Log
operator|.
name|debug
argument_list|(
literal|"Max width: "
argument_list|,
name|maxWidth
argument_list|)
expr_stmt|;
name|int
name|showLines
decl_stmt|;
if|if
condition|(
name|isPaginationEnabled
argument_list|()
condition|)
block|{
name|showLines
operator|=
name|height
operator|-
literal|1
expr_stmt|;
comment|// page limit
block|}
else|else
block|{
name|showLines
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
name|StringBuilder
name|buff
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|CharSequence
name|item
range|:
name|items
control|)
block|{
if|if
condition|(
operator|(
name|buff
operator|.
name|length
argument_list|()
operator|+
name|maxWidth
operator|)
operator|>
name|width
condition|)
block|{
name|println
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|showLines
operator|==
literal|0
condition|)
block|{
comment|// Overflow
name|print
argument_list|(
name|resources
operator|.
name|getString
argument_list|(
literal|"display-more"
argument_list|)
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|int
name|c
init|=
name|readVirtualKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|// one step forward
name|showLines
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'q'
condition|)
block|{
comment|// page forward
name|showLines
operator|=
name|height
operator|-
literal|1
expr_stmt|;
block|}
name|back
argument_list|(
name|resources
operator|.
name|getString
argument_list|(
literal|"display-more"
argument_list|)
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'q'
condition|)
block|{
comment|// cancel
break|break;
block|}
block|}
block|}
comment|// NOTE: toString() is important here due to hiccups with AnsiString
name|buff
operator|.
name|append
argument_list|(
name|item
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|maxWidth
operator|+
literal|3
operator|-
name|item
operator|.
name|length
argument_list|()
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|buff
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buff
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|println
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// Non-supported Terminal Support
comment|//
specifier|private
name|Thread
name|maskThread
decl_stmt|;
specifier|private
name|void
name|beforeReadLine
parameter_list|(
specifier|final
name|String
name|prompt
parameter_list|,
specifier|final
name|Character
name|mask
parameter_list|)
block|{
if|if
condition|(
name|mask
operator|!=
literal|null
operator|&&
name|maskThread
operator|==
literal|null
condition|)
block|{
specifier|final
name|String
name|fullPrompt
init|=
literal|"\r"
operator|+
name|prompt
operator|+
literal|"                 "
operator|+
literal|"                 "
operator|+
literal|"                 "
operator|+
literal|"\r"
operator|+
name|prompt
decl_stmt|;
name|maskThread
operator|=
operator|new
name|Thread
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|interrupted
argument_list|()
condition|)
block|{
try|try
block|{
name|Writer
name|out
init|=
name|getOutput
argument_list|()
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
name|fullPrompt
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
return|return;
block|}
block|}
block|}
block|}
expr_stmt|;
name|maskThread
operator|.
name|setPriority
argument_list|(
name|Thread
operator|.
name|MAX_PRIORITY
argument_list|)
expr_stmt|;
name|maskThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|maskThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|afterReadLine
parameter_list|()
block|{
if|if
condition|(
name|maskThread
operator|!=
literal|null
operator|&&
name|maskThread
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|maskThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|maskThread
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * Erases the current line with the existing prompt, then redraws the line      * with the provided prompt and buffer      * @param prompt      *            the new prompt      * @param buffer      *            the buffer to be drawn      * @param cursorDest      *            where you wish to have the cursor set when the line has been drawn.      *            -1 for end of line.      * */
specifier|public
name|void
name|resetPromptLine
parameter_list|(
name|String
name|prompt
parameter_list|,
name|String
name|buffer
parameter_list|,
name|int
name|cursorDest
parameter_list|)
throws|throws
name|IOException
block|{
comment|// move cursor to end of line
name|moveToEnd
argument_list|()
expr_stmt|;
comment|// backspace all text, including prompt
name|buf
operator|.
name|buffer
operator|.
name|append
argument_list|(
name|this
operator|.
name|prompt
argument_list|)
expr_stmt|;
name|buf
operator|.
name|cursor
operator|+=
name|this
operator|.
name|prompt
operator|.
name|length
argument_list|()
expr_stmt|;
name|this
operator|.
name|prompt
operator|=
literal|""
expr_stmt|;
name|backspaceAll
argument_list|()
expr_stmt|;
name|this
operator|.
name|prompt
operator|=
name|prompt
expr_stmt|;
name|redrawLine
argument_list|()
expr_stmt|;
name|setBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|// move cursor to destination (-1 will move to end of line)
if|if
condition|(
name|cursorDest
operator|<
literal|0
condition|)
name|cursorDest
operator|=
name|buffer
operator|.
name|length
argument_list|()
expr_stmt|;
name|setCursorPosition
argument_list|(
name|cursorDest
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|printSearchStatus
parameter_list|(
name|String
name|searchTerm
parameter_list|,
name|String
name|match
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|prompt
init|=
literal|"(reverse-i-search)`"
operator|+
name|searchTerm
operator|+
literal|"': "
decl_stmt|;
name|String
name|buffer
init|=
name|match
decl_stmt|;
name|int
name|cursorDest
init|=
name|match
operator|.
name|indexOf
argument_list|(
name|searchTerm
argument_list|)
decl_stmt|;
name|resetPromptLine
argument_list|(
name|prompt
argument_list|,
name|buffer
argument_list|,
name|cursorDest
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|restoreLine
parameter_list|(
name|String
name|originalPrompt
parameter_list|,
name|int
name|cursorDest
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO move cursor to matched string
name|String
name|prompt
init|=
name|lastLine
argument_list|(
name|originalPrompt
argument_list|)
decl_stmt|;
name|String
name|buffer
init|=
name|buf
operator|.
name|buffer
operator|.
name|toString
argument_list|()
decl_stmt|;
name|resetPromptLine
argument_list|(
name|prompt
argument_list|,
name|buffer
argument_list|,
name|cursorDest
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// History search
comment|//
comment|/**      * Search backward in history from a given position.      *      * @param searchTerm substring to search for.      * @param startIndex the index from which on to search      * @return index where this substring has been found, or -1 else.      */
specifier|public
name|int
name|searchBackwards
parameter_list|(
name|String
name|searchTerm
parameter_list|,
name|int
name|startIndex
parameter_list|)
block|{
return|return
name|searchBackwards
argument_list|(
name|searchTerm
argument_list|,
name|startIndex
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Search backwards in history from the current position.      *      * @param searchTerm substring to search for.      * @return index where the substring has been found, or -1 else.      */
specifier|public
name|int
name|searchBackwards
parameter_list|(
name|String
name|searchTerm
parameter_list|)
block|{
return|return
name|searchBackwards
argument_list|(
name|searchTerm
argument_list|,
name|history
operator|.
name|index
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|int
name|searchBackwards
parameter_list|(
name|String
name|searchTerm
parameter_list|,
name|int
name|startIndex
parameter_list|,
name|boolean
name|startsWith
parameter_list|)
block|{
name|ListIterator
argument_list|<
name|History
operator|.
name|Entry
argument_list|>
name|it
init|=
name|history
operator|.
name|entries
argument_list|(
name|startIndex
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasPrevious
argument_list|()
condition|)
block|{
name|History
operator|.
name|Entry
name|e
init|=
name|it
operator|.
name|previous
argument_list|()
decl_stmt|;
if|if
condition|(
name|startsWith
condition|)
block|{
if|if
condition|(
name|e
operator|.
name|value
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|startsWith
argument_list|(
name|searchTerm
argument_list|)
condition|)
block|{
return|return
name|e
operator|.
name|index
argument_list|()
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|e
operator|.
name|value
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
name|searchTerm
argument_list|)
condition|)
block|{
return|return
name|e
operator|.
name|index
argument_list|()
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|//
comment|// Helpers
comment|//
comment|/**      * Checks to see if the specified character is a delimiter. We consider a      * character a delimiter if it is anything but a letter or digit.      *      * @param c     The character to test      * @return      True if it is a delimiter      */
specifier|private
name|boolean
name|isDelimiter
parameter_list|(
specifier|final
name|char
name|c
parameter_list|)
block|{
return|return
operator|!
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
name|c
argument_list|)
return|;
block|}
specifier|private
name|void
name|printAnsiSequence
parameter_list|(
name|String
name|sequence
parameter_list|)
throws|throws
name|IOException
block|{
name|print
argument_list|(
literal|27
argument_list|)
expr_stmt|;
name|print
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
comment|//        flush();
block|}
comment|// return column position, reported by the terminal
specifier|private
name|int
name|getCurrentPosition
parameter_list|()
block|{
comment|// check for ByteArrayInputStream to disable for unit tests
if|if
condition|(
name|terminal
operator|.
name|isAnsiSupported
argument_list|()
operator|&&
operator|!
operator|(
name|in
operator|instanceof
name|ByteArrayInputStream
operator|)
condition|)
block|{
try|try
block|{
while|while
condition|(
name|in
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|streamBuffer
operator|.
name|add
argument_list|(
operator|(
name|byte
operator|)
name|in
operator|.
name|read
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|printAnsiSequence
argument_list|(
literal|"6n"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|StringBuffer
name|b
init|=
operator|new
name|StringBuffer
argument_list|(
literal|8
argument_list|)
decl_stmt|;
comment|// position is sent as<ESC>[{ROW};{COLUMN}R
name|int
name|r
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|in
operator|.
name|read
argument_list|()
operator|)
operator|>
operator|-
literal|1
operator|&&
name|r
operator|!=
literal|'R'
condition|)
block|{
if|if
condition|(
name|r
operator|!=
literal|27
operator|&&
name|r
operator|!=
literal|'['
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|r
argument_list|)
expr_stmt|;
block|}
block|}
name|String
index|[]
name|pos
init|=
name|b
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|";"
argument_list|)
decl_stmt|;
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|pos
index|[
literal|1
index|]
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|x
parameter_list|)
block|{
comment|// no luck
block|}
block|}
return|return
operator|-
literal|1
return|;
comment|// TODO: throw exception instead?
block|}
block|}
end_class

end_unit

